{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tecnolog\u00edas de Programaci\u00f3nBienvenido a Tecnolog\u00edas de Programaci\u00f3n","text":""},{"location":"#tecnologias-de-programacion_1","title":"\ud83d\udcf1 Tecnolog\u00edas de programaci\u00f3n","text":"<p>Tecnolog\u00edas de Programaci\u00f3n es una asignatura obligatoria del 2.\u00ba curso del Grado en Ingenier\u00eda Inform\u00e1tica (1.er semestre, 6 ECTS). Su objetivo es dotar al alumnado de una formaci\u00f3n avanzada en t\u00e9cnicas y paradigmas de programaci\u00f3n que consolidan y ampl\u00edan los conocimientos adquiridos en Fundamentos de Programaci\u00f3n I y II.</p> <p>La asignatura combina teor\u00eda, ejercicios pr\u00e1cticos y actividades de laboratorio. Se fomenta la aplicaci\u00f3n de los conceptos en el dise\u00f1o y desarrollo de programas, as\u00ed como la reflexi\u00f3n cr\u00edtica sobre las soluciones propuestas. El aprendizaje progresivo a lo largo de los tres bloques permite al estudiante adquirir competencias clave para desenvolverse en entornos profesionales donde se requieren aplicaciones modulares, interactivas y con capacidad de ejecuci\u00f3n en paralelo o distribuida.</p> <p>El curso se apoya en un enfoque pr\u00e1ctico con trabajos individuales y en equipo, reforzando la capacidad de aplicar conceptos te\u00f3ricos a problemas reales de programaci\u00f3n. Esta asignatura constituye una base s\u00f3lida para asignaturas posteriores relacionadas con la ingenier\u00eda del software, los sistemas distribuidos y la inteligencia artificial.</p> <p>Profesorado:</p> <ul> <li> <p>David Freire Obreg\u00f3n. Profesor de pr\u00e1cticas. Coordinador  </p> </li> <li> <p>Ignacio Jos\u00e9 L\u00f3pez Rodr\u00edguez.</p> </li> <li> <p>Mar\u00eda Dolores Afonso Su\u00e1rez. </p> </li> </ul> <p></p> <p> </p> <p>\u00a9 2025 Mar\u00eda Dolores Afonso Su\u00e1rez. Este material se distribuye bajo licencia Creative Commons Atribuci\u00f3n 4.0 Internacional (CC BY 4.0).</p>"},{"location":"contenidos/","title":"Contenidos","text":"<p>Tecnolog\u00edas de Programaci\u00f3n (TP) Los bloques est\u00e1n dise\u00f1ados para guiar al estudiante desde los fundamentos avanzados de POO hasta los paradigmas de programaci\u00f3n concurrente y distribuida. El objetivo es consolidar las bases de un programador profesional capaz de crear aplicaciones robustas, modulares y eficientes.</p> <p>BLOQUE 1. Conceptos avanzados de Programaci\u00f3n Orientada a Objetos revisa y ampl\u00eda los fundamentos de POO, profundizando en modularidad, herencia y reutilizaci\u00f3n de c\u00f3digo. Se abordan tambi\u00e9n la genericidad y los contenedores como ejemplos de aplicaci\u00f3n, proporcionando una visi\u00f3n madura del dise\u00f1o orientado a objetos.</p> <p>BLOQUE 2. Fundamentos de la Programaci\u00f3n Guiada por Eventos e Interfaz Gr\u00e1fica introduce el paradigma basado en eventos y el dise\u00f1o de interfaces. Se trabaja con gestores de eventos, clases anidadas, componentes y layouts para construir aplicaciones interactivas y usables.</p> <p>BLOQUE 3. Programaci\u00f3n Concurrente y Distribuida explora los principios de la concurrencia (sincronizaci\u00f3n, comunicaci\u00f3n entre hilos, paralelismo) y una introducci\u00f3n a la programaci\u00f3n distribuida, competencias clave para sistemas modernos y escalables.</p>"},{"location":"Bloque1_POO/01Java_vs_Python/","title":"Java vs Python","text":"<p>Este tema presenta una comparaci\u00f3n entre dos de los lenguajes de programaci\u00f3n m\u00e1s influyentes y utilizados en la actualidad: Java y Python. Ambos tienen fortalezas y limitaciones, y su elecci\u00f3n depende en gran medida del tipo de aplicaci\u00f3n que se desee desarrollar.</p>"},{"location":"Bloque1_POO/01Java_vs_Python/#sintaxis","title":"Sintaxis","text":"<ul> <li>Java: Su sintaxis es m\u00e1s estricta, requiere punto y coma al final de cada sentencia y la declaraci\u00f3n expl\u00edcita de tipos. Esto fuerza al programador a ser m\u00e1s detallista y riguroso desde el principio.</li> <li>Python: Su sintaxis es mucho m\u00e1s simple y legible, no necesita punto y coma ni declaraci\u00f3n previa de tipos. Esto facilita la escritura de programas cortos y prototipos r\u00e1pidos.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#tipado","title":"Tipado","text":"<ul> <li>Java: Est\u00e1ticamente tipado. Los tipos de las variables son fijos y se conocen en tiempo de compilaci\u00f3n. Esto puede reducir errores en ejecuci\u00f3n y mejorar la eficiencia.</li> <li>Python: Din\u00e1micamente tipado. El tipo de las variables puede cambiar durante la ejecuci\u00f3n. Esto proporciona mayor flexibilidad pero puede provocar errores en tiempo de ejecuci\u00f3n si no se controla bien.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#velocidad-de-ejecucion","title":"Velocidad de ejecuci\u00f3n","text":"<ul> <li>Java: Generalmente m\u00e1s r\u00e1pido porque el c\u00f3digo se compila a bytecode y se ejecuta en la JVM (Java Virtual Machine), lo que optimiza el rendimiento.</li> <li>Python: M\u00e1s lento porque se interpreta l\u00ednea por l\u00ednea. Aunque existen int\u00e9rpretes optimizados, en aplicaciones de gran escala puede ser menos eficiente.</li> </ul> <p>Velocidad de ejecuci\u00f3n</p>"},{"location":"Bloque1_POO/01Java_vs_Python/#compilacion-vs-interpretacion","title":"Compilaci\u00f3n vs Interpretaci\u00f3n","text":"<ul> <li>Java: Es un lenguaje compilado a bytecode, que despu\u00e9s se ejecuta en la JVM. Esto permite portabilidad entre sistemas y cierto equilibrio entre rendimiento y flexibilidad.</li> <li>Python: Lenguaje interpretado, ejecutado l\u00ednea por l\u00ednea. Esto facilita la depuraci\u00f3n y flexibilidad, pero penaliza la velocidad.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#uso-de-memoria-y-gestion","title":"Uso de memoria y gesti\u00f3n","text":"<ul> <li>Java: Utiliza m\u00e1s memoria, pero su gesti\u00f3n se realiza mediante un recolector de basura robusto que maneja autom\u00e1ticamente la memoria no utilizada.</li> <li>Python: Su consumo de memoria suele ser menor, aunque tambi\u00e9n implementa mecanismos de recolecci\u00f3n de basura.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#paradigma-de-programacion","title":"Paradigma de programaci\u00f3n","text":"<ul> <li>Java: Lenguaje orientado a objetos puro. Todo debe formar parte de una clase. Aunque soporta elementos funcionales (como lambdas), su enfoque central es OOP.</li> <li>Python: Soporta m\u00faltiples paradigmas: orientaci\u00f3n a objetos, programaci\u00f3n funcional y programaci\u00f3n procedimental. Es m\u00e1s flexible y adaptable.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#bibliotecas-y-ecosistema","title":"Bibliotecas y ecosistema","text":"<ul> <li>Java: Ecosistema muy s\u00f3lido, especialmente en aplicaciones empresariales, m\u00f3viles (Android) y web de gran escala.</li> <li>Python: Ecosistema con gran popularidad en ciencia de datos, inteligencia artificial y aprendizaje autom\u00e1tico. Destaca por bibliotecas como NumPy, Pandas o TensorFlow.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#portabilidad","title":"Portabilidad","text":"<ul> <li>Java: Altamente portable gracias a la JVM. El lema \u201cwrite once, run anywhere\u201d refleja esta fortaleza.</li> <li>Python: Tambi\u00e9n portable, pero en ocasiones depende de bibliotecas externas que pueden no estar disponibles en todas las plataformas.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#aplicaciones-comunes","title":"Aplicaciones comunes","text":"<ul> <li>Java: Usado en aplicaciones empresariales, m\u00f3viles (Android) y sistemas web de gran rendimiento y escala.</li> <li>Python: Predomina en ciencia de datos, inteligencia artificial, automatizaci\u00f3n de tareas y desarrollo r\u00e1pido de prototipos.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#comunidad-y-aprendizaje","title":"Comunidad y aprendizaje","text":"<ul> <li>Java: Considerado m\u00e1s dif\u00edcil de aprender al inicio por la complejidad de su sintaxis y la necesidad de definir estructuras m\u00e1s r\u00edgidas.</li> <li>Python: Lenguaje valorado como uno de los m\u00e1s accesibles para principiantes. Su sintaxis clara y directa lo convierten en una excelente opci\u00f3n para iniciarse en la programaci\u00f3n.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#resumen","title":"Resumen","text":"<ul> <li>Java: Ideal para aplicaciones grandes, multiplataforma y de alto rendimiento. Aporta robustez y seguridad.</li> <li>Python: Flexible, sencillo de aprender y con un enorme protagonismo en \u00e1reas emergentes como la IA y la ciencia de datos.</li> </ul>"},{"location":"Bloque1_POO/01_codigos/","title":"Tema \u00b7 Repaso de Programaci\u00f3n Orientada a Objetos","text":"<p>Ejemplos de c\u00f3digo </p>"},{"location":"Bloque1_POO/01_codigos/#velocidad-de-ejecucion","title":"Velocidad de ejecuci\u00f3n","text":""},{"location":"Bloque1_POO/01_codigos/#java","title":"Java","text":"<pre><code>public class VelocidadJava {\n    public static void main(String[] args) {\n        long startTime = System.nanoTime();\n\n        int suma = 0;\n        for (int i = 0; i &lt; 1000000; i++) {\n            suma += i;\n        }\n\n        long endTime = System.nanoTime();\n        System.out.println(\"Tiempo de ejecuci\u00f3n en Java: \" + (endTime - startTime) + \" nanosegundos.\");\n    }\n}\n// Java. Valores aproximados a: 3927653 nanosegundos (unos 4 milisegundos)\n</code></pre> <pre><code>import time\n\nstart_time = time.time()\n\nsuma = 0\nfor i in range(1000000):\n    suma += i\n\nend_time = time.time()\nprint(\"Tiempo de ejecuci\u00f3n en Python:\", (end_time - start_time), \"segundos\")\n\n// Python. Valores aproximados a: 0.13556790351867676 segundos (unos 135 milisegundos)\n</code></pre>"},{"location":"Bloque1_POO/01_codigos/#abstraccion","title":"Abstracci\u00f3n","text":"<pre><code>// Clase abstracta que define el comportamiento de un Vehiculo\nabstract class Vehiculo {\n    // M\u00e9todo abstracto: las subclases deben implementar c\u00f3mo encender el veh\u00edculo\n    public abstract void encender();\n\n    // M\u00e9todo abstracto: las subclases deben implementar c\u00f3mo apagar el veh\u00edculo\n    public abstract void apagar();\n\n    // M\u00e9todo com\u00fan que puede ser usado por todas las subclases\n    public void mostrarTipo() {\n        System.out.println(\"Este es un veh\u00edculo.\");\n    }\n}\n\n// Clase concreta que extiende de la clase abstracta Vehiculo\nclass Coche extends Vehiculo {\n    // Implementaci\u00f3n del m\u00e9todo encender\n    public void encender() {\n        System.out.println(\"El coche est\u00e1 encendido.\");\n    }\n\n    // Implementaci\u00f3n del m\u00e9todo apagar\n    public void apagar() {\n        System.out.println(\"El coche est\u00e1 apagado.\");\n    }\n}\n\n// Clase principal que usa la abstracci\u00f3n\npublic class Main {  \n    public static void main(String[] args) {\n        // Creamos un objeto de tipo Coche\n        Coche miCoche = new Coche();\n\n        // Usamos los m\u00e9todos abstractos implementados\n        miCoche.encender();\n        miCoche.mostrarTipo();\n        miCoche.apagar();\n\n        // Intentar crear un objeto de la clase abstracta (esto va a generar un error de compilaci\u00f3n)\n        Vehiculo miVehiculo = new Vehiculo();  // &lt;-- Esto genera un error\n    }\n}\n</code></pre>"},{"location":"Bloque1_POO/01_codigos/#encapsulamiento","title":"Encapsulamiento","text":"<pre><code>class Circulo {\n    // Al ser private solo los m\u00e9todos de esta clase pueden acceder a ellos\n    private String color;\n    private int radio;\n    private int x, y;\n\n    // El constructor permite crear objetos c\u00edrculo con valores iniciales para sus atributos \n    public Circulo(String color, int radio, int x, int y) {\n        this.color = color;\n        this.radio = radio;\n        this.x = x;\n        this.y = y;\n    }\n    // M\u00e9todos que pueden alterar  los atributos de forma controlada\n        public void cambiarTamano(int nuevoRadio) {\n        this.radio = nuevoRadio;\n    }\n\n    public void cambiarPosicion(int nuevaX, int nuevaY) {\n        this.x = nuevaX;\n        this.y = nuevaY;\n    }\n    // Encapsula la representaci\u00f3n del objeto\n    public void mostrar() {\n        System.out.println(\"C\u00edrculo de color \" + color + \", radio \" + radio +\n                           \", en la posici\u00f3n (\" + x + \", \" + y + \")\");\n    }\n}\n// Clase principal. Ejemplo de uso de encapsulamiento.\npublic class Main {\n    public static void main(String[] args) {\n        Circulo circulo1 = new Circulo(\"Rojo\", 50, 100, 100);\n        Circulo circulo2 = new Circulo(\"Verde\", 30, 200, 150);\n        Circulo circulo3 = new Circulo(\"Azul\", 70, 300, 250);\n\n        circulo1.mostrar();\n        circulo2.mostrar();\n        circulo3.mostrar();\n        // Solo llama a los m\u00e9todos p\u00fablicos, no le interesa como se realizan\n        circulo1.cambiarTamano(80);\n        circulo1.cambiarPosicion(150, 200);\n\n        circulo1.mostrar();\n    }\n}\n\n</code></pre>"},{"location":"Bloque1_POO/01_codigos/#herencia","title":"Herencia","text":"<pre><code>class Animal {\n    private final String nombre;\n    Animal(String nombre) { this.nombre = nombre; }\n    public void sonar() { System.out.println(nombre + \": hace un sonido gen\u00e9rico\"); }\n    public String getNombre() { return nombre; }\n}\n\nclass Perro extends Animal {\n    Perro(String nombre) { super(nombre); }\n    // Anotaci\u00f3n de un m\u00e9todo, que indica que se sobreescribe\n    @Override public void sonar() { System.out.println(getNombre() + \": \u00a1guau!\"); }\n    public void traerPelota() { System.out.println(getNombre() + \" trae la pelota\"); }\n}\n\npublic class Main { // \u2190 Aseg\u00farate de que el archivo se llame Main.java\n    public static void main(String[] args) {\n        Animal a = new Animal(\"Animal\");\n        Animal p = new Perro(\"Toby\");\n        a.sonar();\n        p.sonar();\n        if (p instanceof Perro) ((Perro) p).traerPelota();\n    }\n}\n</code></pre>"},{"location":"Bloque1_POO/01_codigos/#polimorfismo","title":"Polimorfismo","text":"<pre><code>// Superclase/abstracci\u00f3n\nabstract class Figura {\n    private final String nombre;\n    Figura(String nombre) { this.nombre = nombre; }\n\n    public String getNombre() { return nombre; }\n\n    // M\u00e9todo polim\u00f3rfico: cada subclase lo implementa a su manera\n    public abstract double area();\n\n    // Comportamiento com\u00fan que tambi\u00e9n puede sobrescribirse\n    public void dibujar() {\n        System.out.println(\"Dibujando \" + nombre + \" gen\u00e9rico\");\n    }\n}\n\n// Subclase 1: Circulo\nclass Circulo extends Figura {\n    private final double radio;\n    //Especializa la figura para un c\u00edrculo\n    Circulo(double radio) {\n        super(\"c\u00edrculo\");\n        this.radio = radio;\n    }\n    @Override public double area() { return Math.PI * radio * radio; }\n    @Override public void dibujar() { System.out.println(\"Dibujando un c\u00edrculo\"); }\n}\n\n// Subclase 2: Rect\u00e1ngulo\nclass Rectangulo extends Figura {\n    private final double ancho, alto;\n    // Especializa la figura para un rect\u00e1ngulo\n    Rectangulo(double ancho, double alto) {\n        super(\"rect\u00e1ngulo\");\n        this.ancho = ancho; this.alto = alto;\n    }\n    @Override public double area() { return ancho * alto; }\n    // Usa el dibujar() heredado si no lo sobrescribes\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        // Polimorfismo: misma referencia (Figura), distintos objetos concretos\n        Figura[] figuras = { new Circulo(2.0), new Rectangulo(3.0, 4.0) };\n\n        for (Figura f : figuras) {\n            f.dibujar();                              // despacho din\u00e1mico\n            System.out.printf(\"\u00c1rea de %s: %.2f%n\", \n                              f.getNombre(), f.area()); // llama al override adecuado\n        }\n\n        // Otra muestra de polimorfismo en un m\u00e9todo que recibe la superclase\n\n        procesar(new Circulo(5.0));       // usa procesar(Figura f)\n        procesar(new Rectangulo(2.0, 6.0)); // usa procesar(Figura f)\n        procesar(new Circulo(3.0), \"extra\"); // usa procesar(Circulo c, String msg)\n    }\n    // Polimorfismo din\u00e1mico (sobrescritura)\n    static void procesar(Figura f) {\n        // procesar se resuelve en tiempo de compilaci\u00f3n\n        System.out.println(\"Procesando \" + f.getClass().getSimpleName()\n                           + \" con \u00e1rea \" + f.area());\n                           //f.area se resuelve en tiempo de ejecuci\u00f3n\n    }\n    // Sobrecarga espec\u00edfica para Circulo\n    static void procesar(Circulo c) {\n        System.out.println(\"Procesando espec\u00edficamente un c\u00edrculo con radio \"\n                           + c.area());\n    }\n\n    // Otra sobrecarga con par\u00e1metros adicionales\n    // Esta es una sobrecarga est\u00e1tica, se decide en tiempo de compilaci\u00f3n porque los par\u00e1metros coinciden exactamente\n    static void procesar(Circulo c, String msg) {\n        System.out.println(\"Procesando c\u00edrculo con mensaje: \" + msg \n                           + \" y \u00e1rea \" + c.area());\n    }\n}\n</code></pre> \ud83d\udca1 Overrride vs Overload  <p> Override (area(), dibujar()): </p> <p> - Misma firma que en la superclase. </p> <p> - Decide en tiempo de ejecuci\u00f3n qu\u00e9 versi\u00f3n usar. </p> <p> Overload (procesar(Figura), procesar(Circulo), procesar(Circulo,String)): </p> <p> - Mismo nombre, distinta lista de par\u00e1metros. </p> <p> - Decide en tiempo de compilaci\u00f3n qu\u00e9 versi\u00f3n usar. </p>"},{"location":"Bloque1_POO/01_codigos/#clases-y-objetos","title":"Clases y objetos","text":"<pre><code>class Persona {\n    String nombre;\n    int edad;\n\n    void saludar() {\n        System.out.println(\"Hola, me llamo \" + nombre);\n    }\n}\n\n// Creaci\u00f3n de un objeto\nPersona p1 = new Persona();\np1.nombre = \"Ana\";\np1.edad = 25;\np1.saludar();\n</code></pre>"},{"location":"Bloque1_POO/01_repaso_poo/","title":"Tema \u00b7 Repaso de Programaci\u00f3n Orientada a Objetos","text":"<p>La Programaci\u00f3n Orientada a Objetos (POO) es un paradigma de programaci\u00f3n que organiza el software en torno a entidades llamadas objetos, los cuales agrupan datos y comportamientos relacionados. Este enfoque resulta fundamental en la ingenier\u00eda del software moderna y sirve como base para muchos lenguajes de programaci\u00f3n actuales, como Java, C++ o Python.</p>"},{"location":"Bloque1_POO/01_repaso_poo/#1-principios-basicos-de-la-poo","title":"1. Principios b\u00e1sicos de la POO","text":""},{"location":"Bloque1_POO/01_repaso_poo/#abstraccion","title":"Abstracci\u00f3n","text":"<p>La abstracci\u00f3n consiste en identificar las caracter\u00edsticas esenciales de una entidad del mundo real y representarlas en un modelo computacional.  </p> <p>Ejemplo Abstracci\u00f3n</p>"},{"location":"Bloque1_POO/01_repaso_poo/#encapsulacion","title":"Encapsulaci\u00f3n","text":"<p>La encapsulaci\u00f3n protege el acceso directo a los datos internos de un objeto, control\u00e1ndolo mediante m\u00e9todos definidos. Esto mejora la seguridad y reduce la dependencia entre m\u00f3dulos.  </p> <p>Ejemplo Encapsulamiento</p>"},{"location":"Bloque1_POO/01_repaso_poo/#herencia","title":"Herencia","text":"<p>La herencia permite que una clase (subclase) herede atributos y m\u00e9todos de otra (superclase). Facilita la reutilizaci\u00f3n de c\u00f3digo y la creaci\u00f3n de jerarqu\u00edas l\u00f3gicas.  </p> <p>Ejemplo Herencia</p>"},{"location":"Bloque1_POO/01_repaso_poo/#polimorfismo","title":"Polimorfismo","text":"<p>El polimorfismo permite que un mismo m\u00e9todo tenga comportamientos distintos seg\u00fan el contexto o la clase que lo implemente.  </p> <p>Ejemplo Polimorfismo</p>"},{"location":"Bloque1_POO/01_repaso_poo/#2-objetos-y-clases","title":"2. Objetos y clases","text":"<ul> <li>Clase: Es la plantilla que define las propiedades (atributos) y comportamientos (m\u00e9todos).  </li> <li>Objeto: Es una instancia concreta de una clase, que posee valores espec\u00edficos para sus atributos.  </li> </ul> <p>Ejemplo Clase y objeto</p>"},{"location":"Bloque1_POO/01_repaso_poo/#3-ventajas-de-la-poo","title":"3. Ventajas de la POO","text":"<ul> <li>Modularidad: el c\u00f3digo se organiza en componentes independientes.  </li> <li>Reutilizaci\u00f3n: se puede extender y adaptar c\u00f3digo existente sin reescribirlo.  </li> <li>Mantenibilidad: facilita la lectura, depuraci\u00f3n y evoluci\u00f3n del software.  </li> <li>Escalabilidad: permite modelar sistemas complejos con jerarqu\u00edas de clases y objetos.</li> </ul>"},{"location":"Bloque1_POO/01_repaso_poo/#4-poo-en-la-practica","title":"4. POO en la pr\u00e1ctica","text":"<p>En la actualidad, la POO se integra con otros paradigmas. Lenguajes como Java siguen una orientaci\u00f3n a objetos estricta, mientras que Python o C# permiten combinarla con enfoques funcionales y procedimentales. El repaso de estos conceptos es crucial para afrontar los siguientes temas del bloque, donde se profundizar\u00e1 en aspectos avanzados como modularidad, herencia compleja, genericidad y el uso de contenedores.</p>"},{"location":"Bloque1_POO/01_repaso_poo/#5-conclusion","title":"5. Conclusi\u00f3n","text":"<p>La Programaci\u00f3n Orientada a Objetos constituye una base s\u00f3lida para el desarrollo de software moderno. Sus principios permiten construir sistemas m\u00e1s claros, mantenibles y robustos, y son fundamentales para abordar los contenidos m\u00e1s avanzados de la asignatura.</p> <p>Java vs Python</p>"},{"location":"Bloque1_POO/02_codigos1/","title":"Modularidad, Herencia y Reusabilidad","text":""},{"location":"Bloque1_POO/02_codigos1/#definiciones-y-ejemplos-ilustrativos","title":"Definiciones y ejemplos ilustrativos","text":""},{"location":"Bloque1_POO/02_codigos1/#tipos-primitivos-paso-por-valor","title":"Tipos primitivos - paso por valor","text":"<pre><code>public class PasoPorValorPrimitivo {\n    public static void main(String[] args) {\n        int numero = 10;\n        cambiarValor(numero);\n        System.out.println(\"Valor despu\u00e9s de llamar al m\u00e9todo: \" + numero); // Imprime 10\n    }\n\n    public static void cambiarValor(int valor) {\n        valor = 20; // Esta modificaci\u00f3n no afecta a 'numero' en el m\u00e9todo main\n    }\n}\n// En los tipos de datos primitivos se pasa una copia del valor.\n</code></pre> \ud83d\udca1 Paso de par\u00e1metros <p>En los tipos de datos primitivos se pasa una copia del valor. </p>"},{"location":"Bloque1_POO/02_codigos1/#objetos-paso-por-referencia","title":"Objetos - paso por referencia","text":"<pre><code>public class PasoPorValorReferencia {\n    public static void main(String[] args) {\n        MiObjeto objeto = new MiObjeto();\n        objeto.valor = 10;\n\n        modificarObjeto(objeto);\n        System.out.println(\"Valor despu\u00e9s de llamar al m\u00e9todo: \" + objeto.valor); // Imprime 20\n    }\n\n    public static void modificarObjeto(MiObjeto obj) {\n        obj.valor = 20; // Modifica el valor del objeto original\n    }\n}\n\nclass MiObjeto {\n    int valor;\n}\n\n</code></pre> \ud83d\udca1 Paso de par\u00e1metros <p>En los objtos se pasa una copia de la referncia, por lo que ambos apuntan al mismo objeto.  Esto permite modificar el objeto original a trav\u00e9s de la referencia. </p>"},{"location":"Bloque1_POO/02_codigos1/#paso-por-referencia-ejemplo","title":"Paso por referencia. Ejemplo.","text":"<pre><code>public class ReferenciaEjemplo {\n    public static void main(String[] args) {\n        // Creamos un objeto de la clase String\n        String mensaje = \"Hola, mundo\";\n\n        // Creamos otra referencia que apunta al mismo objeto\n        String otraReferencia = mensaje;\n\n        // Mostramos el contenido de ambas referencias\n        System.out.println(\"Mensaje original: \" + mensaje);\n        System.out.println(\"Otra referencia: \" + otraReferencia);\n\n        // Modificamos la referencia 'mensaje'\n        mensaje = \"Nuevo mensaje\";\n\n        // Mostramos el contenido despu\u00e9s de la modificaci\u00f3n\n        System.out.println(\"Mensaje despu\u00e9s de modificar: \" + mensaje);\n        System.out.println(\"Contenido de otra referencia: \" + otraReferencia);\n    }\n}\n</code></pre>"},{"location":"Bloque1_POO/02_codigos1/#calculadora-secuencial","title":"Calculadora secuencial","text":"<pre><code>import java.util.Scanner;\n\npublic class CalculadoraSecuencial {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        // Solicitar el primer n\u00famero\n        System.out.println(\"Ingrese el primer n\u00famero:\");\n        double num1 = scanner.nextDouble();\n\n        // Solicitar el segundo n\u00famero\n        System.out.println(\"Ingrese el segundo n\u00famero:\");\n        double num2 = scanner.nextDouble();\n\n        // Solicitar la operaci\u00f3n a realizar\n        System.out.println(\"Ingrese la operaci\u00f3n (+, -, *, /):\");\n        char operacion = scanner.next().charAt(0);\n\n        // Variable para almacenar el resultado\n        double resultado = 0;\n\n        // Realizar la operaci\u00f3n\n        switch (operacion) {\n            case '+':\n                resultado = num1 + num2;\n                break;\n            case '-':\n                resultado = num1 - num2;\n                break;\n            case '*':\n                resultado = num1 * num2;\n                break;\n            case '/':\n                if (num2 != 0) {\n                    resultado = num1 / num2;\n                } else {\n                    System.out.println(\"Error: Divisi\u00f3n por cero no permitida.\");\n                    return;\n                }\n                break;\n            default:\n                System.out.println(\"Operaci\u00f3n no v\u00e1lida.\");\n                return;\n        }\n\n        // Mostrar el resultado\n        System.out.println(\"El resultado es: \" + resultado);\n    }\n}\n</code></pre>"},{"location":"Bloque1_POO/02_codigos1/#calculadora-orientada-a-objetos","title":"Calculadora orientada a objetos","text":"<pre><code>import java.util.Scanner;\n\n// Clase Calculadora con los m\u00e9todos para cada operaci\u00f3n\nclass Calculadora {\n    // M\u00e9todo para sumar\n    public double sumar(double a, double b) {\n        return a + b;\n    }\n\n    // M\u00e9todo para restar\n    public double restar(double a, double b) {\n        return a - b;\n    }\n\n    // M\u00e9todo para multiplicar\n    public double multiplicar(double a, double b) {\n        return a * b;\n    }\n\n    // M\u00e9todo para dividir\n    public double dividir(double a, double b) {\n        if (b == 0) {\n            System.out.println(\"Error: Divisi\u00f3n por cero no permitida.\");\n            return 0; // O lanzar una excepci\u00f3n dependiendo del caso\n        }\n        return a / b;\n    }\n}\n\npublic class CalculadoraOrientadaObjetos {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        Calculadora calculadora = new Calculadora();\n\n        // Solicitar el primer n\u00famero\n        System.out.println(\"Ingrese el primer n\u00famero:\");\n        double num1 = scanner.nextDouble();\n\n        // Solicitar el segundo n\u00famero\n        System.out.println(\"Ingrese el segundo n\u00famero:\");\n        double num2 = scanner.nextDouble();\n\n        // Solicitar la operaci\u00f3n a realizar\n        System.out.println(\"Ingrese la operaci\u00f3n (+, -, *, /):\");\n        char operacion = scanner.next().charAt(0);\n\n        // Variable para almacenar el resultado\n        double resultado = 0;\n\n        // Realizar la operaci\u00f3n mediante los m\u00e9todos de la clase Calculadora\n        switch (operacion) {\n            case '+':\n                resultado = calculadora.sumar(num1, num2);\n                break;\n            case '-':\n                resultado = calculadora.restar(num1, num2);\n                break;\n            case '*':\n                resultado = calculadora.multiplicar(num1, num2);\n                break;\n            case '/':\n                resultado = calculadora.dividir(num1, num2);\n                break;\n            default:\n                System.out.println(\"Operaci\u00f3n no v\u00e1lida.\");\n                return;\n        }\n\n        // Mostrar el resultado\n        System.out.println(\"El resultado es: \" + resultado);\n    }\n}\n\n</code></pre> \ud83d\udca1 Detalles <p>La clase Calculadora encapsula toda la l\u00f3gica de las operaciones matem\u00e1ticas. Esto significa que la funcionalidad est\u00e1 agrupada en un \u00fanico lugar y separada de otras partes del programa (como la entrada y salida de datos en el main). </p> <p>Ventaja Si un m\u00f3dulo (la clase Calculadora) tiene un fallo o necesita ser mejorado, es f\u00e1cil modificarlo sin afectar a otras partes del c\u00f3digo. Esto facilita la localizaci\u00f3n de errores y la evoluci\u00f3n del software.</p>"},{"location":"Bloque1_POO/02_codigos1/#calculadora-orientada-a-objetos-potencia","title":"Calculadora orientada a objetos - potencia","text":"<pre><code>// Aprovechamos la modularidad incluyendo el m\u00e9todo potencia en la clase calculadora\n// de esta forma se pueden agregar nuevas funcionalidades sin alterar significativamente\n// la estructura del programa.\n\nimport java.util.Scanner;\n\n// Clase Calculadora con los m\u00e9todos para cada operaci\u00f3n\nclass Calculadora {\n    // M\u00e9todo para sumar\n    public double sumar(double a, double b) {\n        return a + b;\n    }\n\n    // M\u00e9todo para restar\n    public double restar(double a, double b) {\n        return a - b;\n    }\n\n    // M\u00e9todo para multiplicar\n    public double multiplicar(double a, double b) {\n        return a * b;\n    }\n\n    // M\u00e9todo para dividir\n    public double dividir(double a, double b) {\n        if (b == 0) {\n            System.out.println(\"Error: Divisi\u00f3n por cero no permitida.\");\n            return 0; // O lanzar una excepci\u00f3n dependiendo del caso\n        }\n        return a / b;\n    }\n\n    // Nuevo m\u00e9todo para calcular la potencia\n    public double potencia(double base, double exponente) {\n        return Math.pow(base, exponente);\n    }\n}\n\npublic class CalculadoraOrientadaObjetosPotencia {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        Calculadora calculadora = new Calculadora();\n\n        // Solicitar el primer n\u00famero\n        System.out.println(\"Ingrese el primer n\u00famero:\");\n        double num1 = scanner.nextDouble();\n\n        // Solicitar el segundo n\u00famero\n        System.out.println(\"Ingrese el segundo n\u00famero:\");\n        double num2 = scanner.nextDouble();\n\n        // Solicitar la operaci\u00f3n a realizar\n        System.out.println(\"Ingrese la operaci\u00f3n (+, -, *, /, ^):\");\n        char operacion = scanner.next().charAt(0);\n\n        // Variable para almacenar el resultado\n        double resultado = 0;\n\n        // Realizar la operaci\u00f3n mediante los m\u00e9todos de la clase Calculadora\n        switch (operacion) {\n            case '+':\n                resultado = calculadora.sumar(num1, num2);\n                break;\n            case '-':\n                resultado = calculadora.restar(num1, num2);\n                break;\n            case '*':\n                resultado = calculadora.multiplicar(num1, num2);\n                break;\n            case '/':\n                resultado = calculadora.dividir(num1, num2);\n                break;\n            case '^':  // Nueva operaci\u00f3n para calcular la potencia\n                resultado = calculadora.potencia(num1, num2);\n                break;\n            default:\n                System.out.println(\"Operaci\u00f3n no v\u00e1lida.\");\n                return;\n        }\n\n        // Mostrar el resultado\n        System.out.println(\"El resultado es: \" + resultado);\n    }\n}\n\n</code></pre> \ud83d\udca1 Detalles <p>La clase Calculadora puede ser utilizada en otros programas. Si en al\u00fan otro sistema es necesario realizar operaciones m\u00e1tem\u00e1ticas, se podr\u00eda integrar f\u00e1cilmente la clase sin necesidad de reescribir la l\u00f3gica. </p> <p>Ventajas: </p> <p>- Reutilizaci\u00f3n. Evita la duplicaci\u00f3n de c\u00f3digo, lo que mejora la eficiencia y reduce la posibilidad de errores.</p> <p>- Mantenimiento. Si el c\u00f3digo crece o cambia, se puede realizar sin modificar el flujo principal de la aplicaci\u00f3n. Adem\u00e1s, cualquier correcci\u00f3n que se deba hacer se puede realizar directamente en la clase Calculadora sin tocar otras partes del c\u00f3digo. El c\u00f3digo estar\u00e1 mejor organizado.</p> <p>- Flexibilidad. Se puede extender la clase Calculadora sin modificarla directamente, utilizando herencia o composici\u00f3n. Se podr\u00eda crear una nueva clase, como CalculadoraAvanzada, que extienda la funcionalidad de la calculadora b\u00e1sica, y siga reutilizando el c\u00f3digo existente.</p> <p>- Encapsulamiento. La l\u00f3gica de cada operaci\u00f3n (suma, resta, multiplicaci\u00f3n y divisi\u00f3n) est\u00e1 contenida dentro de m\u00e9todos privados a la clase Calculadora. Esto significa que el main no necesita saber c\u00f3mo se implementa cada operaci\u00f3n; solo llama a los m\u00e9todos correspondientes. Al ocultar los detalles internos, el c\u00f3digo que interact\u00faa con la clase Calculadora (como el c\u00f3digo del main) es m\u00e1s simple y menos propenso a errores. Adem\u00e1s, si cambia la implementaci\u00f3n interna (por ejemplo, optimizando el c\u00e1lculo de la multiplicaci\u00f3n), el resto del programa no se ve afectado.</p> <p>- Escalabilidad. La capacidad para adaptarse al crecimiento, tanto en tama\u00f1o como en complejidad. : La estructura orientada a objetos es naturalmente m\u00e1s escalable. A medida que el programa crezca (por ejemplo, a\u00f1adiendo nuevas funciones o integraciones), se pueden mantener las operaciones matem\u00e1ticas en la clase Calculadora o derivarlas a subclases especializadas sin tener que reestructurar el flujo general del programa.</p>"},{"location":"Bloque1_POO/02_codigos1/#calculadora-orientada-a-objetos-potencia-interfaz","title":"Calculadora orientada a objetos - potencia - interfaz","text":"<pre><code>import java.util.Scanner;\n\n// Interfaz Operacion que define un m\u00e9todo para ejecutar cualquier operaci\u00f3n\ninterface Operacion {\n    double ejecutar(double a, double b);\n}\n\n// Clase para sumar\nclass Suma implements Operacion {\n    @Override\n    public double ejecutar(double a, double b) {\n        return a + b;\n    }\n}\n\n// Clase para restar\nclass Resta implements Operacion {\n    @Override\n    public double ejecutar(double a, double b) {\n        return a - b;\n    }\n}\n\n// Clase para multiplicar\nclass Multiplicacion implements Operacion {\n    @Override\n    public double ejecutar(double a, double b) {\n        return a * b;\n    }\n}\n\n// Clase para dividir\nclass Division implements Operacion {\n    @Override\n    public double ejecutar(double a, double b) {\n        if (b == 0) {\n            System.out.println(\"Error: Divisi\u00f3n por cero no permitida.\");\n            return 0;\n        }\n        return a / b;\n    }\n}\n\n// Clase para potencia\nclass Potencia implements Operacion {\n    @Override\n    public double ejecutar(double base, double exponente) {\n        return Math.pow(base, exponente);\n    }\n}\n\n// Clase Calculadora que usa la interfaz Operacion\nclass Calculadora {\n    public double operar(Operacion operacion, double a, double b) {\n        return operacion.ejecutar(a, b);\n    }\n}\n\npublic class CalculadoraOrientadaObjetosPotenciaInterfaz {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        Calculadora calculadora = new Calculadora();\n\n        // Solicitar el primer n\u00famero\n        System.out.println(\"Ingrese el primer n\u00famero:\");\n        double num1 = scanner.nextDouble();\n\n        // Solicitar el segundo n\u00famero\n        System.out.println(\"Ingrese el segundo n\u00famero:\");\n        double num2 = scanner.nextDouble();\n\n        // Solicitar la operaci\u00f3n a realizar\n        System.out.println(\"Ingrese la operaci\u00f3n (+, -, *, /, ^):\");\n        char operacion = scanner.next().charAt(0);\n\n        // Variable para almacenar el resultado\n        double resultado = 0;\n\n        // Definir la operaci\u00f3n basada en la entrada\n        Operacion op = null;\n        switch (operacion) {\n            case '+':\n                op = new Suma();\n                break;\n            case '-':\n                op = new Resta();\n                break;\n            case '*':\n                op = new Multiplicacion();\n                break;\n            case '/':\n                op = new Division();\n                break;\n            case '^':\n                op = new Potencia();\n                break;\n            default:\n                System.out.println(\"Operaci\u00f3n no v\u00e1lida.\");\n                return;\n        }\n\n        // Realizar la operaci\u00f3n mediante la interfaz Operacion\n        if (op != null) {\n            resultado = calculadora.operar(op, num1, num2);\n        }\n\n        // Mostrar el resultado\n        System.out.println(\"El resultado es: \" + resultado);\n    }\n}\n</code></pre>"},{"location":"Bloque1_POO/02_codigos1/#diagrama-de-modulos","title":"Diagrama de m\u00f3dulos","text":""},{"location":"Bloque1_POO/02_codigos1/#relacion-real","title":"Relaci\u00f3n real","text":"<ul> <li>La clase Calculadora es una clase independiente que contiene los m\u00e9todos para realizar las operaciones b\u00e1sicas (suma, resta, multiplicaci\u00f3n y divisi\u00f3n).  </li> <li>La clase CalculadoraOrientadaObjetos es simplemente la clase principal donde se solicita la entrada del usuario y se utiliza un objeto de la clase Calculadora para realizar las operaciones.  </li> </ul>"},{"location":"Bloque1_POO/02_codigos1/#interaccion","title":"Interacci\u00f3n","text":"<p>La clase CalculadoraOrientadaObjetos crea una instancia de Calculadora y llama a sus m\u00e9todos. Es un ejemplo de composici\u00f3n (usar un objeto dentro de otro) y no de herencia.  </p>"},{"location":"Bloque1_POO/02_codigos1/#diferencias-clave","title":"Diferencias clave","text":"<ul> <li>Herencia: Una clase hija hereda los m\u00e9todos y propiedades de la clase padre, y puede sobreescribir o extender la funcionalidad de la clase padre.  </li> <li>Composici\u00f3n: Una clase contiene una instancia de otra clase y utiliza sus m\u00e9todos, pero no hereda de ella.  </li> </ul> <p>En este caso, la clase principal (CalculadoraOrientadaObjetos) utiliza la clase Calculadora, pero no es una subclase de ella.  </p> \ud83d\udca1 extends <p>Solo puedes extender de UNA sola clase (Java no permite herencia m\u00faltiple de clases).</p> <p>Heredas atributos y m\u00e9todos de la superclase.</p> <p>Puedes sobrescribir (override) m\u00e9todos para dar un comportamiento espec\u00edfico.</p> <p>Puedes a\u00f1adir nuevos atributos o m\u00e9todos.</p> <p>extends significa: soy un tipo m\u00e1s espec\u00edfico de esa clase.</p> \ud83d\udca1 implements <p>Una interfaz define un contrato (qu\u00e9 m\u00e9todos debe tener la clase), pero no la implementaci\u00f3n.</p> <p>Una clase puede implementar varias interfaces \u2192 es la forma de tener herencia m\u00faltiple en Java.</p> <p>Obliga a la clase a implementar todos los m\u00e9todos declarados en la interfaz (salvo que la clase sea abstracta).</p> <p>Puedes a\u00f1adir nuevos atributos o m\u00e9todos.</p> <p>implements significa: cumplo el contrato de esta interfaz.</p>"},{"location":"Bloque1_POO/02_codigos1/#conclusion","title":"Conclusi\u00f3n","text":"<p>Esto significa que la relaci\u00f3n entre ambas clases es de uso o colaboraci\u00f3n, y no de herencia.  </p>"},{"location":"Bloque1_POO/02_codigos2/","title":"Modularidad, Herencia y Reusabilidad","text":""},{"location":"Bloque1_POO/02_codigos2/#definiciones-y-ejemplos-ilustrativos","title":"Definiciones y ejemplos ilustrativos","text":""},{"location":"Bloque1_POO/02_codigos2/#metodos-constructores-accesores-transformadores-y-productores","title":"M\u00e9todos: constructores, accesores, transformadores y productores","text":"<pre><code>public class Persona {\n    // Atributos privados de la clase\n    private String nombre;\n    private int edad;\n    private double altura;\n\n    // *** Constructor: Se utiliza para inicializar los atributos de la clase cuando se crea un objeto\n    public Persona(String nombre, int edad, double altura) {\n        this.nombre = nombre;\n        this.edad = edad;\n        this.altura = altura;\n    }\n\n    // *** M\u00e9todo Accesor (getter): Permite acceder al valor del atributo 'nombre'\n    public String getNombre() {\n        return nombre;\n    }\n\n    // *** M\u00e9todo Accesor (getter): Permite acceder al valor del atributo 'edad'\n    public int getEdad() {\n        return edad;\n    }\n\n    // *** M\u00e9todo Accesor (getter): Permite acceder al valor del atributo 'altura'\n    public double getAltura() {\n        return altura;\n    }\n\n    // *** M\u00e9todo Transformador (setter): Permite modificar el valor del atributo 'nombre'\n    public void setNombre(String nombre) {\n        this.nombre = nombre;\n    }\n\n    // *** M\u00e9todo Transformador (setter): Permite modificar el valor del atributo 'edad'\n    public void setEdad(int edad) {\n        this.edad = edad;\n    }\n\n    // *** M\u00e9todo Transformador (setter): Permite modificar el valor del atributo 'altura'\n    public void setAltura(double altura) {\n        this.altura = altura;\n    }\n\n    // *** M\u00e9todo Productor: Crea y devuelve una cadena con la informaci\u00f3n de la persona\n    public String informacionCompleta() {\n        return \"Nombre: \" + nombre + \", Edad: \" + edad + \" a\u00f1os, Altura: \" + altura + \" m\";\n    }\n\n    // *** M\u00e9todo Productor: Calcula el a\u00f1o de nacimiento de la persona basado en su edad\n    public int calcularAnioNacimiento() {\n        int anioActual = java.util.Calendar.getInstance().get(java.util.Calendar.YEAR);\n        return anioActual - edad;\n    }\n\n    // M\u00e9todo principal para probar la clase Persona\n    public static void main(String[] args) {\n        // Creaci\u00f3n de un objeto de la clase Persona usando el constructor\n        Persona persona = new Persona(\"Juan\", 25, 1.75);\n\n        // Uso de los m\u00e9todos accesores\n        System.out.println(\"Nombre: \" + persona.getNombre());\n        System.out.println(\"Edad: \" + persona.getEdad());\n        System.out.println(\"Altura: \" + persona.getAltura());\n\n        // Uso de los m\u00e9todos transformadores\n        persona.setNombre(\"Carlos\");\n        persona.setEdad(30);\n        persona.setAltura(1.80);\n\n        // Mostrar la informaci\u00f3n completa usando el m\u00e9todo productor\n        System.out.println(\"Informaci\u00f3n actualizada: \" + persona.informacionCompleta());\n\n        // Uso de otro m\u00e9todo productor\n        System.out.println(\"A\u00f1o de nacimiento: \" + persona.calcularAnioNacimiento());\n    }\n}\n</code></pre> \ud83d\udca1 Caracter\u00edsticas <p>Los atributos (nombre, edad, altura) son privados (-).</p> <p>Todos los m\u00e9todos son p\u00fablicos (+).</p> <p>Esto es un caso cl\u00e1sico de encapsulaci\u00f3n fuerte:</p> <p>Los datos se ocultan (private).</p> <p>Se accede a ellos solo a trav\u00e9s de getters y setters.</p> <p>El usuario de la clase no puede manipular directamente los atributos.</p>"},{"location":"Bloque1_POO/02_codigos2/#metodos-constructores-accesores-transformadores-y-productores_1","title":"M\u00e9todos: constructores, accesores, transformadores y productores","text":"<pre><code>public class PersonaNiveles {\n    // Atributos de la clase con diferentes modificadores de acceso\n    private String nombre;   // Solo accesible desde dentro de la clase Persona\n    protected int edad;      // Accesible desde la clase Persona y sus subclases (en el mismo paquete o diferentes paquetes)\n    public double altura;    // Accesible desde cualquier clase\n\n    // *** Constructor p\u00fablico: Se utiliza para inicializar los atributos de la clase cuando se crea un objeto\n    public PersonaNiveles(String nombre, int edad, double altura) {\n        this.nombre = nombre;\n        this.edad = edad;\n        this.altura = altura;\n    }\n\n    // *** M\u00e9todo Accesor (getter) p\u00fablico: Permite acceder al valor del atributo 'nombre'\n    public String getNombre() {\n        return nombre;\n    }\n\n    // *** M\u00e9todo Accesor (getter) protegido: Permite acceder al valor del atributo 'edad'\n    protected int getEdad() {\n        return edad;\n    }\n\n    // *** M\u00e9todo Accesor (getter) p\u00fablico: Permite acceder al valor del atributo 'altura'\n    public double getAltura() {\n        return altura;\n    }\n\n    // *** M\u00e9todo Transformador (setter) p\u00fablico: Permite modificar el valor del atributo 'nombre'\n    public void setNombre(String nombre) {\n        this.nombre = nombre;\n    }\n\n    // *** M\u00e9todo Transformador (setter) protegido: Permite modificar el valor del atributo 'edad'\n    protected void setEdad(int edad) {\n        this.edad = edad;\n    }\n\n    // *** M\u00e9todo Transformador (setter) p\u00fablico: Permite modificar el valor del atributo 'altura'\n    public void setAltura(double altura) {\n        this.altura = altura;\n    }\n\n    // *** M\u00e9todo Productor p\u00fablico: Crea y devuelve una cadena con la informaci\u00f3n de la persona\n    public String informacionCompleta() {\n        return \"Nombre: \" + nombre + \", Edad: \" + edad + \" a\u00f1os, Altura: \" + altura + \" m\";\n    }\n\n    // *** M\u00e9todo Productor protegido: Calcula el a\u00f1o de nacimiento de la persona basado en su edad\n    protected int calcularAnioNacimiento() {\n        int anioActual = java.util.Calendar.getInstance().get(java.util.Calendar.YEAR);\n        return anioActual - edad;\n    }\n\n    // M\u00e9todo principal para probar la clase PersonaNiveles\n    public static void main(String[] args) {\n        // Creaci\u00f3n de un objeto de la clase PersonaNiveles usando el constructor\n        PersonaNiveles persona = new PersonaNiveles(\"Juan\", 25, 1.75);\n\n        // Uso de los m\u00e9todos accesores\n        System.out.println(\"Nombre: \" + persona.getNombre());\n        System.out.println(\"Edad: \" + persona.getEdad());\n        System.out.println(\"Altura: \" + persona.getAltura());\n\n        // Uso de los m\u00e9todos transformadores\n        persona.setNombre(\"Carlos\");\n        persona.setEdad(30);\n        persona.setAltura(1.80);\n\n        // Mostrar la informaci\u00f3n completa usando el m\u00e9todo productor\n        // Genera una cadena completa con la informaci\u00f3n de la persona\n\n        System.out.println(\"Informaci\u00f3n actualizada: \" + persona.informacionCompleta());\n\n        // Uso de otro m\u00e9todo productor\n        // Calcula y devuelve el a\u00f1o de nacimiento basado en la edad\n        System.out.println(\"A\u00f1o de nacimiento: \" + persona.calcularAnioNacimiento());\n    }\n}\n\n// Nota:\n// Aunque el atributo nombre es private, su valor \n//se puede mostrar porque el m\u00e9todo getNombre() es public y \n//proporciona un medio autorizado y controlado para acceder a \n//ese valor desde fuera de la clase.\n//El uso de atributos private junto con m\u00e9todos public (getters \n//y setters) es un principio fundamental de encapsulaci\u00f3n en la \n//programaci\u00f3n orientada a objetos.\n</code></pre> \ud83d\udca1 Caracter\u00edsticas <p>nombre es privado (-) \u2192 solo accesible desde dentro de la clase.</p> <p>edad es protegido (#) \u2192 accesible desde la clase y las subclases..</p> <p>altura es p\u00fablico (+) \u2192 accesible desde cualquier parte del programa.</p> <p>Lo mismo ocurre con algunos m\u00e9todos:</p> <p>getEdad(), setEdad() y calcularAnioNacimiento() son protegidos.</p> <p>Los dem\u00e1s (getNombre(), getAltura(), etc.) son p\u00fablicos.</p>"},{"location":"Bloque1_POO/02_codigos2/#gestion-de-operaciones","title":"Gesti\u00f3n de operaciones","text":"<pre><code>import java.util.Scanner;\n\n// Clase Cilindro para gestionar las operaciones con el cilindro\nclass Cilindro {\n    private double altura;\n    private double radio;\n\n    // M\u00e9todo para inicializar los valores de altura y radio\n    public void inicializar(double altura, double radio) {\n        this.altura = altura;\n        this.radio = radio;\n    }\n\n    // M\u00e9todo para calcular el volumen del cilindro\n    public double calculaVolumen() {\n        return Math.PI * Math.pow(radio, 2) * altura;\n    }\n}\n\n// Clase principal UsaCilindro\npublic class UsaCilindro {\n    public static void main(String[] args) {\n        double alt, rad;\n\n        // Creaci\u00f3n del objeto Scanner para la entrada de datos\n        Scanner teclado = new Scanner(System.in);\n\n        // Solicitar la altura del cilindro\n        System.out.print(\"Introduce la altura: \");\n        alt = teclado.nextDouble();\n\n        // Solicitar el radio del cilindro\n        System.out.print(\"Introduce el radio: \");\n        rad = teclado.nextDouble();\n\n        // Crear un objeto de la clase Cilindro\n        Cilindro c = new Cilindro();\n        c.inicializar(alt, rad);\n\n        // Calcular y mostrar el volumen del cilindro\n        System.out.println(\"El volumen del cilindro es: \" + c.calculaVolumen());\n\n        // Cerrar el objeto Scanner\n        teclado.close();\n    }\n}\n</code></pre>"},{"location":"Bloque1_POO/02_codigos3.3/","title":"Modularidad, Herencia y Reusabilidad","text":""},{"location":"Bloque1_POO/02_codigos3.3/#definiciones-y-ejemplos-ilustrativos","title":"Definiciones y ejemplos ilustrativos","text":""},{"location":"Bloque1_POO/02_codigos3.3/#sobrecarga-de-metodos","title":"Sobrecarga de m\u00e9todos","text":"<pre><code>//Sin sobrecarga\nimport java.util.Scanner;\n\npublic class SinSobrecarga {\n    // M\u00e9todo para mostrar informaci\u00f3n con solo el nombre\n    public void mostrarDatosNombre(String nombre) {\n        System.out.println(\"Nombre: \" + nombre);\n    }\n\n    // M\u00e9todo para mostrar informaci\u00f3n con nombre y edad\n    public void mostrarDatosNombreYEdad(String nombre, int edad) {\n        System.out.println(\"Nombre: \" + nombre + \", Edad: \" + edad);\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        SinSobrecarga ejemplo = new SinSobrecarga();\n\n        System.out.print(\"Introduce tu nombre: \");\n        String nombre = scanner.nextLine();\n\n        System.out.print(\"Introduce tu edad (o deja en blanco si no quieres ingresar la edad): \");\n        String edadInput = scanner.nextLine();\n\n        if (!edadInput.isEmpty()) {\n            int edad = Integer.parseInt(edadInput);\n            ejemplo.mostrarDatosNombreYEdad(nombre, edad);\n        } else {\n            ejemplo.mostrarDatosNombre(nombre);\n        }\n    }\n}\n</code></pre> <pre><code>//Con sobrecarga\nimport java.util.Scanner;\n\npublic class ConSobrecarga {\n    // M\u00e9todo sobrecargado para mostrar solo el nombre\n    public void mostrarDatos(String nombre) {\n        System.out.println(\"Nombre: \" + nombre);\n    }\n\n    // M\u00e9todo sobrecargado para mostrar el nombre y la edad\n    public void mostrarDatos(String nombre, int edad) {\n        System.out.println(\"Nombre: \" + nombre + \", Edad: \" + edad);\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        ConSobrecarga ejemplo = new ConSobrecarga();\n\n        System.out.print(\"Introduce tu nombre: \");\n        String nombre = scanner.nextLine();\n\n        System.out.print(\"Introduce tu edad (o deja en blanco si no quieres ingresar la edad): \");\n        String edadInput = scanner.nextLine();\n\n        if (!edadInput.isEmpty()) {\n            int edad = Integer.parseInt(edadInput);\n            ejemplo.mostrarDatos(nombre, edad); // Llama al m\u00e9todo con dos par\u00e1metros\n        } else {\n            ejemplo.mostrarDatos(nombre); // Llama al m\u00e9todo con un par\u00e1metro\n        }\n    }\n}\n\n</code></pre> <pre><code>//Sin sobrecarga\npublic class CalculoAreaSinSobrecarga {\n\n    // M\u00e9todo para calcular el \u00e1rea de un tri\u00e1ngulo\n    public double calcularAreaTriangulo(double base, double altura) {\n        return (base * altura) / 2;\n    }\n\n    // M\u00e9todo para calcular el \u00e1rea de un rect\u00e1ngulo\n    public double calcularAreaRectangulo(double longitud, double ancho) {\n        return longitud * ancho;\n    }\n\n    // M\u00e9todo para calcular el \u00e1rea de un \u00f3valo\n    public double calcularAreaOvalo(double ejeMayor, double ejeMenor) {\n        return Math.PI * (ejeMayor / 2) * (ejeMenor / 2);\n    }\n\n    // M\u00e9todo para calcular el \u00e1rea de un pent\u00e1gono regular\n    public double calcularAreaPentagono(double lado, double apotema) {\n        return (5 * lado * apotema) / 2;\n    }\n\n    public static void main(String[] args) {\n        CalculoAreaSinSobrecarga calculo = new CalculoAreaSinSobrecarga();\n\n        // Calcular el \u00e1rea de un tri\u00e1ngulo\n        double areaTriangulo = calculo.calcularAreaTriangulo(5, 10);\n        System.out.println(\"\u00c1rea del tri\u00e1ngulo: \" + areaTriangulo);\n\n        // Calcular el \u00e1rea de un rect\u00e1ngulo\n        double areaRectangulo = calculo.calcularAreaRectangulo(8, 4);\n        System.out.println(\"\u00c1rea del rect\u00e1ngulo: \" + areaRectangulo);\n\n        // Calcular el \u00e1rea de un \u00f3valo\n        double areaOvalo = calculo.calcularAreaOvalo(10, 6);\n        System.out.println(\"\u00c1rea del \u00f3valo: \" + areaOvalo);\n\n        // Calcular el \u00e1rea de un pent\u00e1gono\n        double areaPentagono = calculo.calcularAreaPentagono(6, 4);\n        System.out.println(\"\u00c1rea del pent\u00e1gono: \" + areaPentagono);\n    }\n}\n\n</code></pre> <pre><code>//Con sobrecarga\npublic class CalculoAreaSobrecarga {\n\n    //  javac -encoding UTF-8 CalculoAreaSobrecarga.java\n\n    // M\u00e9todo para calcular el \u00e1rea de un tri\u00e1ngulo\n    public double calcularArea(double basetriangulo, double altura) {\n        return (basetriangulo * altura) / 2;\n    }\n\n    // M\u00e9todo para calcular el \u00e1rea de un rect\u00e1ngulo\n    public double calcularArea(double longitud, double ancho) {\n           return longitud * ancho;\n        }\n\n    // M\u00e9todo para calcular el \u00e1rea de un \u00f3valo\n    public double calcularArea(double ejeMayor, double ejeMenor, boolean esOvalo) {\n        if (esOvalo) {\n            return Math.PI * (ejeMayor / 2) * (ejeMenor / 2);\n        }\n        return 0;\n    }\n\n    // M\u00e9todo para calcular el \u00e1rea de un pent\u00e1gono regular\n    public double calcularArea(double lado, int numeroLados, double apotema) {\n        if (numeroLados == 5) {\n            return (5 * lado * apotema) / 2;\n        }\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        CalculoAreaSobrecarga calculo = new CalculoAreaSobrecarga();\n\n        // Calcular el \u00e1rea de un tri\u00e1ngulo\n        double areaTriangulo = calculo.calcularArea(5, 10);\n        System.out.println(\"Area del tri\u00e1ngulo: \" + areaTriangulo);\n\n        // Calcular el \u00e1rea de un rect\u00e1ngulo\n        double areaRectangulo = calculo.calcularArea(8, 4);\n        System.out.println(\"Area del rect\u00e1ngulo: \" + areaRectangulo);\n\n        // Calcular el \u00e1rea de un \u00f3valo\n        double areaOvalo = calculo.calcularArea(10, 6, true);\n        System.out.println(\"Area del \u00f3valo: \" + areaOvalo);\n\n        // Calcular el \u00e1rea de un pent\u00e1gono\n        double areaPentagono = calculo.calcularArea(6, 5, 4);\n        System.out.println(\"Area del pent\u00e1gono: \" + areaPentagono);\n    }\n}\n\n</code></pre> <pre><code>public class SistemaDeCerraduras {\n\n    // M\u00e9todo para abrir una cerradura con una llave est\u00e1ndar\n    public void abrir(String llave) {\n        if (llave.equals(\"llaveEstandar\")) {\n            System.out.println(\"La cerradura se ha abierto con la llave est\u00e1ndar.\");\n        } else {\n            System.out.println(\"Llave incorrecta. No se puede abrir la cerradura.\");\n        }\n    }\n\n    // M\u00e9todo sobrecargado para abrir una cerradura con una tarjeta magn\u00e9tica\n    public void abrir(int codigoTarjeta) {\n        if (codigoTarjeta == 1234) {\n            System.out.println(\"La cerradura se ha abierto con la tarjeta magn\u00e9tica.\");\n        } else {\n            System.out.println(\"C\u00f3digo de tarjeta incorrecto. No se puede abrir la cerradura.\");\n        }\n    }\n\n    // M\u00e9todo sobrecargado para abrir una cerradura con la llave maestra\n    public void abrir(boolean esLlaveMaestra) {\n        if (esLlaveMaestra) {\n            System.out.println(\"La cerradura se ha abierto con la llave maestra.\");\n        } else {\n            System.out.println(\"No tienes acceso con esta llave.\");\n        }\n    }\n\n    public static void main(String[] args) {\n        SistemaDeCerraduras cerradura = new SistemaDeCerraduras();\n\n        // Abrir la cerradura con una llave est\u00e1ndar\n        cerradura.abrir(\"llaveEstandar\"); // La cerradura se ha abierto con la llave est\u00e1ndar.\n\n        // Abrir la cerradura con una tarjeta magn\u00e9tica\n        cerradura.abrir(1234); // La cerradura se ha abierto con la tarjeta magn\u00e9tica.\n\n        // Abrir la cerradura con la llave maestra\n        cerradura.abrir(true); // La cerradura se ha abierto con la llave maestra.\n    }\n}\n\n</code></pre> <pre><code>import java.util.Scanner;\n\npublic class SistemaDeCerradurasElije {\n\n    // M\u00e9todo para abrir una cerradura con una llave est\u00e1ndar\n    public void abrir(String llave) {\n        if (llave.equals(\"llaveEstandar\")) {\n            System.out.println(\"La cerradura se ha abierto con la llave est\u00e1ndar.\");\n        } else {\n            System.out.println(\"Llave incorrecta. No se puede abrir la cerradura.\");\n        }\n    }\n\n    // M\u00e9todo sobrecargado para abrir una cerradura con una tarjeta magn\u00e9tica\n    public void abrir(int codigoTarjeta) {\n        if (codigoTarjeta == 1234) {\n            System.out.println(\"La cerradura se ha abierto con la tarjeta magn\u00e9tica.\");\n        } else {\n            System.out.println(\"C\u00f3digo de tarjeta incorrecto. No se puede abrir la cerradura.\");\n        }\n    }\n\n    // M\u00e9todo sobrecargado para abrir una cerradura con la llave maestra\n    public void abrir(boolean esLlaveMaestra) {\n        if (esLlaveMaestra) {\n            System.out.println(\"La cerradura se ha abierto con la llave maestra.\");\n        } else {\n            System.out.println(\"No tienes acceso con esta llave.\");\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        SistemaDeCerradurasElije cerradura = new SistemaDeCerradurasElije();\n\n        // Pedir al usuario que seleccione el tipo de cerradura a abrir\n        System.out.println(\"Seleccione el tipo de cerradura que desea abrir:\");\n        System.out.println(\"1. Cerradura con llave est\u00e1ndar\");\n        System.out.println(\"2. Cerradura con tarjeta magn\u00e9tica\");\n        System.out.println(\"3. Cerradura con llave maestra\");\n\n        int opcion = scanner.nextInt();\n        scanner.nextLine(); // Limpiar el buffer\n\n        switch (opcion) {\n            case 1:\n                System.out.print(\"Ingrese la llave est\u00e1ndar: \");\n                String llave = scanner.nextLine();\n                cerradura.abrir(llave);\n                break;\n\n            case 2:\n                System.out.print(\"Ingrese el c\u00f3digo de la tarjeta magn\u00e9tica: \");\n                int codigoTarjeta = scanner.nextInt();\n                cerradura.abrir(codigoTarjeta);\n                break;\n\n            case 3:\n                System.out.print(\"\u00bfTiene la llave maestra? (true/false): \");\n                boolean esLlaveMaestra = scanner.nextBoolean();\n                cerradura.abrir(esLlaveMaestra);\n                break;\n\n            default:\n                System.out.println(\"Opci\u00f3n no v\u00e1lida. Por favor, seleccione una opci\u00f3n correcta.\");\n                break;\n        }\n\n        scanner.close();\n    }\n}\n\n</code></pre>"},{"location":"Bloque1_POO/02_codigos3.3/#this","title":"This","text":"<pre><code>// Clase principal Persona\npublic class Persona {\n    private String nombre;\n    private int edad;\n\n    // 1. Diferenciar entre variables de instancia y par\u00e1metros del m\u00e9todo o constructor\n    // Se usa this.nombre para diferenciar entre la variable de instancia nombre y el par\u00e1metro \n    //del constructor con el mismo nombre.\n\n    public Persona(String nombre) {\n        this.nombre = nombre; // 'this.nombre' se refiere a la variable de instancia\n    }\n\n    // Constructor adicional para el encadenamiento de constructores\n    public Persona(String nombre, int edad) {\n        this.nombre = nombre;\n        this.edad = edad;\n    }\n\n    // M\u00e9todo para mostrar los datos de la persona\n    public void mostrar() {\n        System.out.println(\"Nombre: \" + nombre + \", Edad: \" + edad);\n    }\n\n    // 2. Llamar a otros constructores de la misma clase (Constructor Chaining)\n    // Se usa this(\"Nombre por defecto\", 0) en el constructor Persona() para llamar \n    // al constructor que toma dos par\u00e1metros, evitando duplicar c\u00f3digo.\n\n    public Persona() {\n        this(\"Nombre por defecto\", 0); // Llama al constructor que toma dos par\u00e1metros\n    }\n\n    // 3. Pasar el objeto actual como argumento a otro m\u00e9todo o constructor\n    // El m\u00e9todo mostrarUtilidades() utiliza this para pasar la referencia \n    // del objeto actual al m\u00e9todo imprimir de la clase Utilidades.\n\n    public void mostrarUtilidades() {\n        Utilidades.imprimir(this); // Pasar el objeto actual al m\u00e9todo 'imprimir'\n    }\n\n    // 4. Devolver la referencia actual de un m\u00e9todo (Method Chaining)\n    // Los m\u00e9todos setNombre y setEdad devuelven this, lo que permite encadenar las \n    //llamadas de m\u00e9todos en una sola l\u00ednea (persona1.setNombre(\"Carlos\").setEdad(25);).\n\n    public Persona setNombre(String nombre) {\n        this.nombre = nombre;\n        return this; // Devuelve la referencia actual para encadenar\n    }\n\n    public Persona setEdad(int edad) {\n        this.edad = edad;\n        return this; // Devuelve la referencia actual para encadenar\n    }\n\n    // Getters para acceder a las variables privadas\n    public String getNombre() {\n        return nombre;\n    }\n\n    public int getEdad() {\n        return edad;\n    }\n\n    public static void main(String[] args) {\n        // 1. Diferenciar entre variables de instancia y par\u00e1metros\n        Persona persona1 = new Persona(\"Juan\");\n        persona1.mostrar(); // Output: Nombre: Juan, Edad: 0\n\n        // 2. Llamar a otros constructores de la misma clase (Constructor Chaining)\n        Persona persona2 = new Persona();\n        persona2.mostrar(); // Output: Nombre: Nombre por defecto, Edad: 0\n\n        // 3. Pasar el objeto actual como argumento a otro m\u00e9todo o constructor\n        persona1.mostrarUtilidades(); // Output: Utilidades - Nombre: Juan, Edad: 0\n\n        // 4. Devolver la referencia actual de un m\u00e9todo (Method Chaining)\n        persona1.setNombre(\"Carlos\").setEdad(25); // Encadenamiento de m\u00e9todos\n        persona1.mostrar(); // Output: Nombre: Carlos, Edad: 25\n    }\n}\n\n// Clase auxiliar para el ejemplo 3\nclass Utilidades {\n    public static void imprimir(Persona persona) {\n        // Utilizamos los getters para acceder a los atributos privados\n        System.out.println(\"Utilidades - Nombre: \" + persona.getNombre() + \", Edad: \" + persona.getEdad());\n    }\n}\n</code></pre> <pre><code>public class PersonaChain {\n    private String nombre;\n    private int edad;\n\n    // Constructor 1: Constructor sin par\u00e1metros\n    public PersonaChain() {\n        this(\"Nombre por defecto\", 0); // Llama al constructor con dos par\u00e1metros\n        System.out.println(\"Constructor sin par\u00e1metros llamado\");\n    }\n\n    // Constructor 2: Constructor con un par\u00e1metro\n    public PersonaChain(String nombre) {\n        this(nombre, 0); // Llama al constructor con dos par\u00e1metros\n        System.out.println(\"Constructor con un par\u00e1metro llamado\");\n    }\n\n    // Constructor 3: Constructor con dos par\u00e1metros\n    public PersonaChain(String nombre, int edad) {\n        this.nombre = nombre;\n        this.edad = edad;\n        System.out.println(\"Constructor con dos par\u00e1metros llamado\");\n    }\n\n    // M\u00e9todo para mostrar los detalles de la persona\n    public void mostrarDetalles() {\n        System.out.println(\"Nombre: \" + nombre + \", Edad: \" + edad);\n    }\n\n    public static void main(String[] args) {\n        // Crear un objeto usando el constructor sin par\u00e1metros\n        PersonaChain persona1 = new PersonaChain();\n        persona1.mostrarDetalles(); // Output: Nombre por defecto, Edad: 0\n\n        // Crear un objeto usando el constructor con un par\u00e1metro\n        PersonaChain persona2 = new PersonaChain(\"Juan\");\n        persona2.mostrarDetalles(); // Output: Nombre: Juan, Edad: 0\n\n        // Crear un objeto usando el constructor con dos par\u00e1metros\n        PersonaChain persona3 = new PersonaChain(\"Carlos\", 25);\n        persona3.mostrarDetalles(); // Output: Nombre: Carlos, Edad: 25\n    }\n}\n</code></pre>"},{"location":"Bloque1_POO/02_codigos3.3/#estado-de-los-objetos","title":"Estado de los objetos","text":"<pre><code>public class PersonaEstado {\n    private String nombre; // Atributo que define parte del estado\n    private int edad;      // Atributo que define parte del estado\n\n    // Constructor para inicializar el estado del objeto\n    public PersonaEstado(String nombre, int edad) {\n        this.nombre = nombre;\n        this.edad = edad;\n    }\n\n    // M\u00e9todo que modifica el estado del objeto\n    public void cumplirA\u00f1os() {\n        this.edad++; // Cambia el estado al incrementar la edad\n    }\n\n    // M\u00e9todo para mostrar el estado actual del objeto\n    public void mostrarEstado() {\n        System.out.println(\"Nombre: \" + nombre + \", Edad: \" + edad);\n    }\n\n    public static void main(String[] args) {\n        PersonaEstado persona = new PersonaEstado(\"Juan\", 25); // Estado inicial\n        persona.mostrarEstado(); // Output: Nombre: Juan, Edad: 25\n\n        persona.cumplirA\u00f1os(); // Cambia el estado\n        persona.mostrarEstado(); // Output: Nombre: Juan, Edad: 26\n    }\n}\n\n</code></pre> <pre><code>import java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\n\n// Clase que representa un Producto\nclass Producto {\n    private String nombre;\n    private double precio;\n    private int cantidad;\n\n    public Producto(String nombre, double precio, int cantidad) {\n        this.nombre = nombre;\n        this.precio = precio;\n        this.cantidad = cantidad;\n    }\n\n    public String getNombre() {\n        return nombre;\n    }\n\n    public double getPrecio() {\n        return precio;\n    }\n\n    public int getCantidad() {\n        return cantidad;\n    }\n\n    public double calcularTotal() {\n        return precio * cantidad;\n    }\n\n    @Override\n    public String toString() {\n        return nombre + \" - Cantidad: \" + cantidad + \", Precio Unitario: $\" + precio + \", Total: $\" + calcularTotal();\n    }\n}\n\n// Clase que representa un Cliente\nclass Cliente {\n    private String nombre;\n    private String email;\n\n    public Cliente(String nombre, String email) {\n        this.nombre = nombre;\n        this.email = email;\n    }\n\n    public String getNombre() {\n        return nombre;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    @Override\n    public String toString() {\n        return \"Cliente: \" + nombre + \" (Email: \" + email + \")\";\n    }\n}\n\n// Clase que representa un Pedido de Compra\nclass Pedido {\n    private Cliente cliente;\n    private List&lt;Producto&gt; productos;\n    private Date fechaPedido;\n    private String estado; // Ejemplos de estado: \"Pendiente\", \"Enviando\", \"Entregado\"\n\n    public Pedido(Cliente cliente) {\n        this.cliente = cliente;\n        this.productos = new ArrayList&lt;&gt;();\n        this.fechaPedido = new Date();\n        this.estado = \"Pendiente\";\n    }\n\n    // M\u00e9todo para agregar un producto al pedido\n    public void agregarProducto(Producto producto) {\n        productos.add(producto);\n    }\n\n    // M\u00e9todo para calcular el total del pedido\n    public double calcularTotalPedido() {\n        double total = 0;\n        for (Producto producto : productos) {\n            total += producto.calcularTotal();\n        }\n        return total;\n    }\n\n    // M\u00e9todo para mostrar el estado completo del pedido\n    public void mostrarEstado() {\n        System.out.println(\"---- Estado del Pedido ----\");\n        System.out.println(cliente); // Llama al m\u00e9todo toString() de Cliente\n        System.out.println(\"Fecha del Pedido: \" + fechaPedido);\n        System.out.println(\"Estado del Pedido: \" + estado);\n        System.out.println(\"Productos en el pedido:\");\n        for (Producto producto : productos) {\n            System.out.println(\"  \" + producto); // Llama al m\u00e9todo toString() de Producto\n        }\n        System.out.println(\"Total del Pedido: $\" + calcularTotalPedido());\n        System.out.println(\"----------------------------\");\n    }\n\n    // M\u00e9todo para actualizar el estado del pedido\n    public void actualizarEstado(String nuevoEstado) {\n        this.estado = nuevoEstado;\n    }\n}\n\n// Clase principal para probar el estado de un objeto complejo\npublic class SistemaPedidos {\n    public static void main(String[] args) {\n        // Crear un cliente\n        Cliente cliente = new Cliente(\"Juan P\u00e9rez\", \"juan.perez@example.com\");\n\n        // Crear un pedido para el cliente\n        Pedido pedido = new Pedido(cliente);\n\n        // Agregar productos al pedido\n        pedido.agregarProducto(new Producto(\"Laptop\", 1200.00, 1));\n        pedido.agregarProducto(new Producto(\"Mouse\", 25.50, 2));\n        pedido.agregarProducto(new Producto(\"Teclado\", 45.99, 1));\n\n        // Mostrar el estado completo del pedido\n        pedido.mostrarEstado();\n\n        // Actualizar el estado del pedido y mostrarlo de nuevo\n        pedido.actualizarEstado(\"Enviando\");\n        System.out.println(\"\\nEstado del pedido actualizado:\");\n        pedido.mostrarEstado();\n    }\n}\n\n</code></pre>"},{"location":"Bloque1_POO/02_codigos3.3/#inicializar-objetos-con-sin-constructores","title":"Inicializar objetos con-sin constructores","text":"<pre><code>// VehiculoSinConstructor.java\npublic class VehiculoSinConstructor {\n    // Atributos del veh\u00edculo\n    String marca;\n    String modelo;\n    int a\u00f1o;\n    double precio;\n\n    // M\u00e9todo para mostrar los detalles del veh\u00edculo\n    public void mostrarDetalles() {\n        System.out.println(\"Marca: \" + marca);\n        System.out.println(\"Modelo: \" + modelo);\n        System.out.println(\"A\u00f1o: \" + a\u00f1o);\n        System.out.println(\"Precio: $\" + precio);\n    }\n\n    public static void main(String[] args) {\n        // Creaci\u00f3n e inicializaci\u00f3n del objeto sin un constructor\n        VehiculoSinConstructor vehiculo = new VehiculoSinConstructor();\n\n        // Inicializaci\u00f3n manual de los atributos\n        vehiculo.marca = \"Toyota\";\n        vehiculo.modelo = \"Corolla\";\n        vehiculo.a\u00f1o = 2020;\n        vehiculo.precio = 18000;\n\n        // Mostrar los detalles del veh\u00edculo\n        vehiculo.mostrarDetalles();\n    }\n}\n</code></pre> <pre><code>// VehiculoConConstructor.java\npublic class VehiculoConConstructor {\n    // Atributos del veh\u00edculo\n    private String marca;\n    private String modelo;\n    private int a\u00f1o;\n    private double precio;\n\n    // Constructor personalizado para inicializar los atributos\n    public VehiculoConConstructor(String marca, String modelo, int a\u00f1o, double precio) {\n        this.marca = marca;\n        this.modelo = modelo;\n        this.a\u00f1o = a\u00f1o;\n        this.precio = precio;\n    }\n\n    // M\u00e9todo para mostrar los detalles del veh\u00edculo\n    public void mostrarDetalles() {\n        System.out.println(\"Marca: \" + marca);\n        System.out.println(\"Modelo: \" + modelo);\n        System.out.println(\"A\u00f1o: \" + a\u00f1o);\n        System.out.println(\"Precio: $\" + precio);\n    }\n\n    public static void main(String[] args) {\n        // Creaci\u00f3n e inicializaci\u00f3n del objeto utilizando el constructor personalizado\n        VehiculoConConstructor vehiculo = new VehiculoConConstructor(\"Honda\", \"Civic\", 2021, 25000);\n\n        // Mostrar los detalles del veh\u00edculo\n        vehiculo.mostrarDetalles();\n    }\n}\n</code></pre> <pre><code>// LibroSinConstructor.java\npublic class LibroSinConstructor {\n    // Atributos del libro\n    String titulo;\n    String autor;\n    int paginas;\n    double precio;\n\n    // M\u00e9todo para mostrar los detalles del libro\n    public void mostrarDetalles() {\n        System.out.println(\"T\u00edtulo: \" + titulo);\n        System.out.println(\"Autor: \" + autor);\n        System.out.println(\"P\u00e1ginas: \" + paginas);\n        System.out.println(\"Precio: $\" + precio);\n    }\n\n    public static void main(String[] args) {\n        // Creaci\u00f3n del objeto utilizando el constructor por defecto\n        LibroSinConstructor libro = new LibroSinConstructor();\n\n        // Inicializaci\u00f3n manual de los atributos\n        libro.titulo = \"Cien A\u00f1os de Soledad\";\n        libro.autor = \"Gabriel Garc\u00eda M\u00e1rquez\";\n        libro.paginas = 417;\n        libro.precio = 19.99;\n\n        // Mostrar los detalles del libro\n        libro.mostrarDetalles();\n    }\n}\n</code></pre> <pre><code>// LibroConConstructor.java\npublic class LibroConConstructor {\n    // Atributos del libro\n    private String titulo;\n    private String autor;\n    private int paginas;\n    private double precio;\n\n    // Constructor personalizado para inicializar los atributos\n    public LibroConConstructor(String titulo, String autor, int paginas, double precio) {\n        this.titulo = titulo;\n        this.autor = autor;\n        this.paginas = paginas;\n        this.precio = precio;\n    }\n\n    // M\u00e9todo para mostrar los detalles del libro\n    public void mostrarDetalles() {\n        System.out.println(\"T\u00edtulo: \" + titulo);\n        System.out.println(\"Autor: \" + autor);\n        System.out.println(\"P\u00e1ginas: \" + paginas);\n        System.out.println(\"Precio: $\" + precio);\n    }\n\n    public static void main(String[] args) {\n        // Creaci\u00f3n e inicializaci\u00f3n del objeto utilizando el constructor personalizado\n        LibroConConstructor libro = new LibroConConstructor(\"El Quijote\", \"Miguel de Cervantes\", 500, 25.99);\n\n        // Mostrar los detalles del libro\n        libro.mostrarDetalles();\n    }\n}\n</code></pre>"},{"location":"Bloque1_POO/02_codigos3/","title":"Modularidad, Herencia y Reusabilidad","text":""},{"location":"Bloque1_POO/02_codigos3/#definiciones-y-ejemplos-ilustrativos","title":"Definiciones y ejemplos ilustrativos","text":""},{"location":"Bloque1_POO/02_codigos3/#conceptos-fundamentales-de-la-programacion-orientada-a-objetos","title":"Conceptos fundamentales de la programaci\u00f3n orientada a objetos","text":"<p>Interfaz vs clase</p>"},{"location":"Bloque1_POO/02_codigos3/#modificadores-de-acceso","title":"Modificadores de acceso","text":"<p>En Java los modificadores de acceso determinan la visibilidad de clases, m\u00e9todos y atributos:</p> <ul> <li>public: accesible desde cualquier clase, sin importar el paquete.  </li> <li>protected: accesible desde el mismo paquete y tambi\u00e9n desde subclases, incluso si est\u00e1n en paquetes diferentes.  </li> <li>package-private (sin especificar modificador): accesible solo dentro del mismo paquete.  </li> <li>private: accesible \u00fanicamente dentro de la misma clase.  </li> </ul> <p>El uso adecuado de estos modificadores favorece la encapsulaci\u00f3n, permitiendo controlar qu\u00e9 partes de una clase se exponen y cu\u00e1les permanecen ocultas.</p>"},{"location":"Bloque1_POO/02_codigos3/#sobrecarga","title":"Sobrecarga","text":"<p>En Java, la sobrecarga de m\u00e9todos (method overloading) ocurre cuando dentro de una misma clase existen varios m\u00e9todos con el mismo nombre, pero que se diferencian en el n\u00famero o tipo de par\u00e1metros que reciben. Esto permite reutilizar el nombre del m\u00e9todo para realizar operaciones similares adaptadas a distintos contextos, mejorando la legibilidad y reduciendo la duplicaci\u00f3n de c\u00f3digo. La selecci\u00f3n de qu\u00e9 m\u00e9todo ejecutar no se hace en tiempo de ejecuci\u00f3n, sino en tiempo de compilaci\u00f3n, en funci\u00f3n de la lista de par\u00e1metros usada en la llamada. Gracias a la sobrecarga, es posible crear clases m\u00e1s flexibles y expresivas, como por ejemplo tener varios m\u00e9todos <code>calcularArea()</code> que acepten cuadrados, c\u00edrculos o tri\u00e1ngulos, sin necesidad de inventar nombres distintos para cada uno.</p> <p>En Java, la sobrecarga de m\u00e9todos sigue estas reglas principales:</p> <ul> <li>Los m\u00e9todos deben tener el mismo nombre, pero diferenciarse en el n\u00famero o tipo de par\u00e1metros.  </li> <li>La sobrecarga se decide en tiempo de compilaci\u00f3n (no en ejecuci\u00f3n).  </li> <li>El tipo de retorno puede ser distinto, pero no basta para diferenciar m\u00e9todos por s\u00ed solo.  </li> <li>Los modificadores de acceso (<code>public</code>, <code>private</code>, etc.) pueden variar entre m\u00e9todos sobrecargados.  </li> <li>Los par\u00e1metros pueden diferir en cantidad (<code>metodo(int)</code> vs <code>metodo(int, int)</code>) o en tipo (<code>metodo(int)</code> vs <code>metodo(double)</code>).  </li> <li>Se permite combinar tipos de par\u00e1metros para cubrir distintos escenarios de uso.  </li> <li>La sobrecarga hace que el c\u00f3digo sea m\u00e1s legible y reutilizable, evitando nombres diferentes para operaciones similares.  </li> </ul> <p>Ejemplo cl\u00e1sico: tener varios m\u00e9todos <code>calcularArea()</code> para distintas figuras (c\u00edrculo, cuadrado, tri\u00e1ngulo) en una misma clase.</p> <p></p> <p>Sobrecarga de m\u00e9todos</p>"},{"location":"Bloque1_POO/02_codigos3/#this","title":"This","text":"<p>En Java, la palabra clave <code>this</code> se utiliza para referirse al objeto actual dentro de una clase. Es \u00fatil para diferenciar atributos de variables locales con el mismo nombre o para invocar otros m\u00e9todos del propio objeto. Adem\u00e1s, puede emplearse en la t\u00e9cnica de constructor chaining, usando <code>this(...)</code> dentro de un constructor para llamar a otro constructor de la misma clase. Esto evita duplicar c\u00f3digo y centraliza la inicializaci\u00f3n de atributos. Por ejemplo, se puede tener un constructor principal con todos los par\u00e1metros y otros constructores m\u00e1s simples que deleguen en \u00e9l mediante <code>this(...)</code>, facilitando la creaci\u00f3n de objetos con diferentes niveles de detalle.</p> <p>En Java, la palabra clave <code>this</code> tiene varios usos importantes:</p>"},{"location":"Bloque1_POO/02_codigos3/#uso-de-this-en-java","title":"Uso de <code>this</code> en Java","text":"<p>En Java, la palabra clave <code>this</code> tiene varios usos importantes:</p> <ul> <li> <p>Referirse al objeto actual: permite acceder a los atributos y m\u00e9todos de la propia instancia. <code>java   this.nombre = nombre; // diferencia entre atributo y par\u00e1metro local</code></p> </li> <li> <p>Invocar otros m\u00e9todos de la misma clase: <code>java   this.calcularEdad();</code></p> </li> <li> <p>Pasar el objeto actual como argumento a otro m\u00e9todo o constructor: <code>java   otraClase.procesar(this);</code></p> </li> <li> <p>Constructor chaining (<code>this(...)</code>): dentro de un constructor, <code>this(...)</code> invoca a otro constructor de la misma clase. <code>java   public Persona(String nombre) {       this(nombre, 0); // llama al constructor con dos par\u00e1metros   }</code></p> </li> </ul> <p>Esto evita duplicaci\u00f3n de c\u00f3digo, centraliza la inicializaci\u00f3n y hace m\u00e1s flexible la creaci\u00f3n de objetos.</p> <p>This</p>"},{"location":"Bloque1_POO/02_codigos3/#estado-de-los-objetos","title":"Estado de los objetos","text":"<p>En programaci\u00f3n orientada a objetos, el estado de un objeto est\u00e1 definido por los valores que toman sus atributos en un momento dado. Dichos atributos describen las caracter\u00edsticas o propiedades del objeto y pueden cambiar a lo largo de la ejecuci\u00f3n del programa mediante m\u00e9todos que los modifican. As\u00ed, dos objetos de la misma clase pueden compartir el mismo comportamiento (m\u00e9todos) pero diferir en su estado si sus atributos almacenan valores distintos. Entender y gestionar el estado es esencial para modelar entidades del mundo real, ya que refleja su situaci\u00f3n actual dentro del sistema, como por ejemplo un pedido en curso o los datos personales de una persona.</p> <p>En Java (y en la programaci\u00f3n orientada a objetos en general), el estado de un objeto se entiende como los valores actuales de sus atributos. Algunas ideas clave:</p> <ul> <li>El estado se define por las propiedades (atributos) de un objeto en un momento concreto.  </li> <li> <p>Ejemplo: una <code>Persona</code> con <code>nombre=\"Ana\"</code> y <code>edad=25</code> tiene un estado distinto de otra <code>Persona</code> con <code>nombre=\"Ana\"</code> y <code>edad=30</code>.  </p> </li> <li> <p>El estado puede cambiar a lo largo de la ejecuci\u00f3n mediante m\u00e9todos que actualizan los atributos.  </p> </li> <li> <p>Ejemplo: al invocar <code>persona.cumplirAnios()</code>, el atributo <code>edad</code> aumenta y el estado se modifica.  </p> </li> <li> <p>Objetos de la misma clase pueden compartir el mismo comportamiento (m\u00e9todos) pero tener estados diferentes.  </p> </li> <li> <p>Ejemplo: dos instancias de <code>SistemaPedidos</code>, una con <code>estado=\"pendiente\"</code> y otra con <code>estado=\"enviado\"</code>.  </p> </li> <li> <p>Gestionar correctamente el estado permite reflejar el ciclo de vida de los objetos y modelar entidades del mundo real.  </p> </li> <li>Ejemplo: un pedido pasa por distintos estados (<code>pendiente</code>, <code>en preparaci\u00f3n</code>, <code>enviado</code>, <code>entregado</code>). </li> </ul> <p>Estado de los objetos</p>"},{"location":"Bloque1_POO/02_codigos3/#inicializar-objetos-consin-constructor","title":"Inicializar objetos con/sin constructor","text":"<p>En Java, la inicializaci\u00f3n de objetos puede hacerse tanto con como sin constructores definidos expl\u00edcitamente:</p> <ul> <li>Sin constructores definidos:   Si no se especifica ning\u00fan constructor en la clase, el compilador a\u00f1ade por defecto un constructor vac\u00edo (sin par\u00e1metros). Esto permite crear objetos, pero sus atributos deber\u00e1n asignarse despu\u00e9s de la creaci\u00f3n mediante setters o asignaciones directas.  </li> <li> <p>Ejemplo: <code>java     LibroSinConstructor libro = new LibroSinConstructor();     libro.titulo = \"Don Quijote\";     libro.autor = \"Cervantes\";</code></p> </li> <li> <p>Con constructores definidos:   Permiten inicializar los atributos de un objeto en el momento de su creaci\u00f3n, evitando tener que asignar valores despu\u00e9s. Esto asegura que el objeto se construya desde el principio con un estado v\u00e1lido y completo.  </p> </li> <li>Ejemplo: <code>java     LibroConConstructor libro = new LibroConConstructor(\"Don Quijote\", \"Cervantes\");</code></li> </ul> <p>En resumen, usar constructores favorece la encapsulaci\u00f3n, garantiza la correcta inicializaci\u00f3n del objeto y mejora la legibilidad del c\u00f3digo, mientras que no usarlos da m\u00e1s flexibilidad, pero exige pasos adicionales para asegurar que el objeto no quede en un estado incompleto.</p> <p>Inicializar objetos con-sin constructores</p>"},{"location":"Bloque1_POO/02_codigos4.4/","title":"Modularidad, Herencia y Reusabilidad","text":""},{"location":"Bloque1_POO/02_codigos4.4/#definiciones-y-ejemplos-ilustrativos","title":"Definiciones y ejemplos ilustrativos","text":""},{"location":"Bloque1_POO/02_codigos4.4/#atributos-de-clase","title":"Atributos de clase","text":"<pre><code>public class Contador {\n    private static int numInstancias = 0; // Atributo de clase\n\n    public Contador() {\n        numInstancias++; // Incrementar contador en cada nueva instancia\n    }\n\n    // M\u00e9todo de clase para obtener el n\u00famero de instancias creadas\n    public static int getNumInstancias() {\n        return numInstancias;\n    }\n\n    public static void main(String[] args) {\n        new Contador(); // Primera instancia\n        new Contador(); // Segunda instancia\n\n        System.out.println(\"N\u00famero de instancias creadas: \" + Contador.getNumInstancias());\n        // Output: N\u00famero de instancias creadas: 2\n    }\n}\n</code></pre>"},{"location":"Bloque1_POO/02_codigos4.4/#metodos-de-clase","title":"M\u00e9todos de clase","text":"<pre><code>public class Calculadora {\n    // M\u00e9todo de clase para calcular el cuadrado de un n\u00famero\n    // No es necesario acceder ni modificar los atributos de una instancia espec\u00edfica\n    // No es necesario crear un objeto\n    public static int calcularCuadrado(int numero) {\n        return numero * numero;\n    }\n\n    public static void main(String[] args) {\n        int resultado = Calculadora.calcularCuadrado(5);\n        System.out.println(\"El cuadrado de 5 es: \" + resultado);\n        // Output: El cuadrado de 5 es: 25\n    }\n}\n</code></pre>"},{"location":"Bloque1_POO/02_codigos4.4/#constantes","title":"Constantes","text":"<pre><code>public class Constantes {\n    public static final double PI = 3.141592653589793;\n\n    public static void main(String[] args) {\n        System.out.println(\"Valor de PI: \" + Constantes.PI);\n    }\n}\n</code></pre>"},{"location":"Bloque1_POO/02_codigos4.4/#singleton","title":"Singleton","text":"<pre><code>// Singleton1.java\n// Ejemplo de Singleton listo para ejecutarse en un \u00fanico fichero con \"Run\" de VS Code.\n\npublic class Singleton1 {\n\n    // Instancia \u00fanica (volatile para doble comprobaci\u00f3n segura en multihilo)\n    private static volatile Singleton1 instancia;\n\n    // Constructor privado: evita instanciaci\u00f3n externa\n    private Singleton1() {\n        System.out.println(\"Inicializando configuraci\u00f3n...\");\n    }\n\n    // Punto de acceso global con double-checked locking (seguro desde Java 5+)\n    public static Singleton1 getInstance() {\n        if (instancia == null) {\n            synchronized (Singleton1.class) {\n                if (instancia == null) {\n                    instancia = new Singleton1();\n                }\n            }\n        }\n        return instancia;\n    }\n\n    public void mostrarMensaje() {\n        System.out.println(\"\u00a1Hola desde el Singleton!\");\n    }\n\n    // M\u00e9todo main en el MISMO fichero/clase para ejecutarlo directamente\n    public static void main(String[] args) {\n        Singleton1 c1 = Singleton1.getInstance();\n        Singleton1 c2 = Singleton1.getInstance();\n\n        c1.mostrarMensaje();\n\n        // Verificaci\u00f3n: ambas referencias apuntan al mismo objeto\n        System.out.println(\"\u00bfEs la misma instancia? \" + (c1 == c2));\n    }\n}\n\n</code></pre> <pre><code>public class Singleton2 {\n    private static Singleton2 instanciaUnica;\n\n    // Constructor privado para evitar la creaci\u00f3n de nuevas instancias\n    private Singleton2() {}\n\n    // M\u00e9todo de clase para obtener la instancia \u00fanica\n    public static Singleton2 obtenerInstancia() {\n        if (instanciaUnica == null) {\n            instanciaUnica = new Singleton2();\n        }\n        return instanciaUnica;\n    }\n\n    public void mostrarMensaje() {\n        System.out.println(\"Esta es la \u00fanica instancia de Singleton.\");\n    }\n\n    public static void main(String[] args) {\n        Singleton2 instancia = Singleton2.obtenerInstancia();\n        instancia.mostrarMensaje();\n    }\n}\n\n</code></pre>"},{"location":"Bloque1_POO/02_codigos4/","title":"Modularidad, Herencia y Reusabilidad","text":""},{"location":"Bloque1_POO/02_codigos4/#definiciones-y-ejemplos-ilustrativos","title":"Definiciones y ejemplos ilustrativos","text":""},{"location":"Bloque1_POO/02_codigos4/#conceptos-fundamentales-de-la-programacion-orientada-a-objetos","title":"Conceptos fundamentales de la programaci\u00f3n orientada a objetos","text":""},{"location":"Bloque1_POO/02_codigos4/#atributos-y-metodos-de-clase","title":"Atributos y m\u00e9todos de clase.","text":"<p>En Java, los atributos y m\u00e9todos de clase son aquellos declarados con la palabra clave static. Los atributos de clase representan valores compartidos por todas las instancias de la clase (por ejemplo, un contador de objetos creados), mientras que los m\u00e9todos de clase son funciones que se pueden invocar sin necesidad de crear un objeto (por ejemplo, Math.sqrt()). Se deben usar cuando la informaci\u00f3n o el comportamiento no dependen de un objeto concreto, sino de la clase en general, facilitando as\u00ed recursos comunes, utilidades o constantes accesibles globalmente.</p> \ud83d\udca1 Atributos de clase  <p> Se usan atributos de clase (static) cuando la informaci\u00f3n debe ser compartida entre todas las instancias o cuando el dato no pertenece a una instancia espec\u00edfica.</p> <p>Atributos de clase</p> \ud83d\udca1 M\u00e9todos de clase  <p> Se usan m\u00e9todos de clase (static) cuando la funcionalidad no depende del estado de una instancia y puede ejecutarse sin necesidad de crear un objeto.</p> <p>M\u00e9todos de clase</p>"},{"location":"Bloque1_POO/02_codigos4/#constantes","title":"Constantes","text":"<p>En Java, las constantes son variables cuyo valor no puede modificarse una vez asignado. Se definen con los modificadores static final, lo que significa que pertenecen a la clase (y no a instancias espec\u00edficas) y que su valor es inmutable.  </p> \ud83d\udca1 Constantes  <p> Por convenci\u00f3n, los nombres de las constantes se escriben en may\u00fasculas y con guiones bajos para separar palabras, como PI, MAX_VALUE o DEFAULT_TIMEOUT.</p> <p> Se utilizan para representar valores fijos y universales en el programa, mejorando la legibilidad y evitando errores asociados a la duplicaci\u00f3n de n\u00fameros m\u00e1gicos o cadenas repetidas en el c\u00f3digo.</p> <p>Constantes</p>"},{"location":"Bloque1_POO/02_codigos4/#patron-singleton","title":"Patr\u00f3n Singleton","text":"<p>El patr\u00f3n Singleton es un patr\u00f3n de dise\u00f1o creacional que garantiza que solo exista una \u00fanica instancia de una clase en todo el sistema y que, adem\u00e1s, sea f\u00e1cilmente accesible desde cualquier parte del programa. En Java, se implementa declarando el constructor como privado (para evitar que se creen instancias desde fuera) y proporcionando un m\u00e9todo p\u00fablico y est\u00e1tico que devuelve siempre la misma instancia (por ejemplo, getInstance()). Se suele usar cuando es necesario un \u00fanico punto de acceso a un recurso compartido, como un gestor de configuraci\u00f3n, un logger, una conexi\u00f3n a base de datos o un manejador de hilos.</p> <p>Singleton</p>"},{"location":"Bloque1_POO/02_interfazvsclase/","title":"Interfaz vs clase","text":"<pre><code>// -------------\n// 1) Interfaz\n// -------------\ninterface RecetaSalsa {\n    String getNombre();\n    void preparar();\n}\n\n// --------------------------------------\n// 2) Clases que implementan la interfaz\n// --------------------------------------\nclass SalsaTomate implements RecetaSalsa {\n    @Override\n    public String getNombre() {\n        return \"Salsa de Tomate\";\n    }\n\n    @Override\n    public void preparar() {\n        System.out.println(\"Preparando salsa de tomate con tomates, aceite y sal.\");\n    }\n}\n\nclass SalsaPesto implements RecetaSalsa {\n    @Override\n    public String getNombre() {\n        return \"Salsa Pesto\";\n    }\n\n    @Override\n    public void preparar() {\n        System.out.println(\"Preparando salsa pesto con albahaca, pi\u00f1ones y parmesano.\");\n    }\n}\n\n// ----------------------------\n// 3) Clase base con herencia\n// ----------------------------\nclass SalsaBase {\n    protected String nombre;\n    protected String[] ingredientes;\n\n    public SalsaBase(String nombre, String[] ingredientes) {\n        this.nombre = nombre;\n        this.ingredientes = ingredientes;\n    }\n\n    public void mostrarIngredientes() {\n        System.out.print(nombre + \" lleva: \");\n        for (int i = 0; i &lt; ingredientes.length; i++) {\n            System.out.print(ingredientes[i]);\n            if (i &lt; ingredientes.length - 1) System.out.print(\", \");\n        }\n        System.out.println(\".\");\n    }\n}\n\n// -----------------------------------\n// 4) Clases que heredan de SalsaBase\n// -----------------------------------\nclass SalsaCarbonara extends SalsaBase {\n    public SalsaCarbonara() {\n        //Usamos super para invocar al constructor de la clase base\n        super(\"Salsa Carbonara\", new String[]{\"nata\", \"huevo\", \"queso\", \"panceta\"});\n    }\n}\n\nclass SalsaBolonesa extends SalsaBase {\n    public SalsaBolonesa() {\n        super(\"Salsa Bolonesa\", new String[]{\"carne\", \"tomate\", \"cebolla\", \"zanahoria\"});\n    }\n}\n\n// -------------------\n// 5) Clase principal\n// -------------------\npublic class SalsasDemo {\n    public static void main(String[] args) {\n        // Uso de la interfaz\n        RecetaSalsa r1 = new SalsaTomate();\n        RecetaSalsa r2 = new SalsaPesto();\n\n        System.out.println(\"=== Usando la interfaz RecetaSalsa ===\");\n        r1.preparar();\n        r2.preparar();\n\n        // Uso de la clase base\n        SalsaBase s1 = new SalsaCarbonara();\n        SalsaBase s2 = new SalsaBolonesa();\n\n        System.out.println(\"\\n=== Usando la clase base SalsaBase ===\");\n        s1.mostrarIngredientes();\n        s2.mostrarIngredientes();\n    }\n}\n\n</code></pre> \ud83d\udca1 Diferencias  <p>M\u00e9todos sobrescritos (en herencia o implementaci\u00f3n) \u2192 siempre runtime (dynamic dispatch).</p> <p>M\u00e9todos est\u00e1ticos, privados o finales \u2192 resueltos en compilaci\u00f3n / no-polim\u00f3rficos.</p> <p>Diferencia real: extends usa invokevirtual, implements usa invokeinterface.</p> \ud83d\udca1 extends <p>Solo puedes extender de UNA sola clase (Java no permite herencia m\u00faltiple de clases).</p> <p>Heredas atributos y m\u00e9todos de la superclase.</p> <p>Puedes sobrescribir (override) m\u00e9todos para dar un comportamiento espec\u00edfico.</p> <p>Puedes a\u00f1adir nuevos atributos o m\u00e9todos.</p> <p>extends significa: soy un tipo m\u00e1s espec\u00edfico de esa clase.</p> \ud83d\udca1 implements <p>Una interfaz define un contrato (qu\u00e9 m\u00e9todos debe tener la clase), pero no la implementaci\u00f3n.</p> <p>Una clase puede implementar varias interfaces \u2192 es la forma de tener herencia m\u00faltiple en Java.</p> <p>Obliga a la clase a implementar todos los m\u00e9todos declarados en la interfaz (salvo que la clase sea abstracta).</p> <p>Puedes a\u00f1adir nuevos atributos o m\u00e9todos.</p> <p>implements significa: cumplo el contrato de esta interfaz.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/","title":"Modularidad, Herencia y Reusabilidad","text":""},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#introduccion","title":"Introducci\u00f3n","text":"<p>En el desarrollo de software, conceptos como modularidad, herencia y reusabilidad son esenciales para crear programas m\u00e1s claros, mantenibles y escalables. Estos principios permiten organizar el c\u00f3digo, reducir la duplicaci\u00f3n y facilitar la evoluci\u00f3n de los proyectos.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#modularidad","title":"Modularidad","text":"<p>La modularidad consiste en dividir un programa en componentes o m\u00f3dulos independientes, de manera que cada uno tenga una responsabilidad clara.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#caracteristicas","title":"Caracter\u00edsticas","text":"<ul> <li>Un m\u00f3dulo puede desarrollarse, probarse y mantenerse de forma aislada.</li> <li>Facilita localizar y corregir errores.</li> <li>Permite ampliar la funcionalidad sin afectar a todo el sistema.</li> </ul>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#herencia","title":"Herencia","text":"<p>La herencia permite definir nuevas clases basadas en otras ya existentes, reutilizando atributos y m\u00e9todos y a\u00f1adiendo o especializando funcionalidades.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#conceptos-clave","title":"Conceptos clave","text":"<ul> <li>Superclase (clase base): clase original de la que heredan otras.</li> <li>Subclase (clase derivada): clase que extiende la funcionalidad de la superclase.</li> </ul>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#polimorfismo-y-clases-abstractas","title":"Polimorfismo y Clases Abstractas","text":"<p>El polimorfismo permite que una misma referencia pueda apuntar a objetos de diferentes clases, ejecutando el m\u00e9todo correspondiente seg\u00fan el tipo del objeto real.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#interfaces","title":"Interfaces","text":"<p>Una interfaz define un conjunto de m\u00e9todos sin implementaci\u00f3n. Las clases que la implementan son responsables de definir su funcionamiento.</p> <p>Las interfaces permiten simular la herencia m\u00faltiple y promueven la flexibilidad del dise\u00f1o.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#reusabilidad","title":"Reusabilidad","text":"<p>La reusabilidad consiste en emplear c\u00f3digo existente en diferentes contextos o proyectos, evitando duplicaciones. Se refiere a la capacidad de utilizar las mismas piezas de c\u00f3digo en diferentes partes del programa o en diferentes proyectos.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#beneficios","title":"Beneficios","text":"<ul> <li>Reducci\u00f3n de errores y duplicaciones.</li> <li>Mayor rapidez en el desarrollo.</li> <li>C\u00f3digo m\u00e1s consistente y probado.</li> </ul>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#conclusion","title":"Conclusi\u00f3n","text":"<ul> <li>La modularidad favorece el orden y la claridad.  </li> <li>La herencia y el polimorfismo permiten extender y generalizar comportamientos.  </li> <li>La reusabilidad reduce costes y facilita el mantenimiento.  </li> <li>Las interfaces aportan flexibilidad para dise\u00f1ar sistemas m\u00e1s escalables.</li> </ul> <p>Estos principios son fundamentales en la Programaci\u00f3n Orientada a Objetos (POO) y constituyen la base de un software robusto y adaptable.</p> <p>Ejemplos pr\u00e1cticos 1</p> <p>Ejemplos pr\u00e1cticos 2</p> <p>Ejemplos pr\u00e1cticos 3</p> <p>Ejemplos pr\u00e1cticos 4</p>"},{"location":"Bloque1_POO/03_codigos1/","title":"Genericidad y contenedores   -- s5-d1","text":""},{"location":"Bloque1_POO/03_codigos1/#definiciones-y-ejemplos-ilustrativos","title":"Definiciones y ejemplos ilustrativos","text":""},{"location":"Bloque1_POO/03_codigos1/#conceptos-fundamentales-sobre-genericidad-y-contenedores","title":"Conceptos fundamentales sobre genericidad y contenedores","text":""},{"location":"Bloque1_POO/03_codigos2/","title":"Genericidad y contenedores   -- s5-d2","text":""},{"location":"Bloque1_POO/03_codigos2/#definiciones-y-ejemplos-ilustrativos","title":"Definiciones y ejemplos ilustrativos","text":""},{"location":"Bloque1_POO/03_codigos2/#conceptos-fundamentales-sobre-genericidad-y-contenedores","title":"Conceptos fundamentales sobre genericidad y contenedores","text":""},{"location":"Bloque1_POO/03_codigos3/","title":"Genericidad y contenedores   -- s6-d1","text":""},{"location":"Bloque1_POO/03_codigos3/#definiciones-y-ejemplos-ilustrativos","title":"Definiciones y ejemplos ilustrativos","text":""},{"location":"Bloque1_POO/03_codigos3/#conceptos-fundamentales-sobre-genericidad-y-contenedores","title":"Conceptos fundamentales sobre genericidad y contenedores","text":""},{"location":"Bloque1_POO/03_codigos4/","title":"Genericidad y contenedores   -- s6-d2","text":""},{"location":"Bloque1_POO/03_codigos4/#definiciones-y-ejemplos-ilustrativos","title":"Definiciones y ejemplos ilustrativos","text":""},{"location":"Bloque1_POO/03_codigos4/#conceptos-fundamentales-sobre-genericidad-y-contenedores","title":"Conceptos fundamentales sobre genericidad y contenedores","text":""},{"location":"Bloque1_POO/03_genericidad_contenedores/","title":"Genericidad; contenedores como ejemplo de aplicaci\u00f3n","text":"<p>Contenido en construcci\u00f3n</p> <p>Ejemplos pr\u00e1cticos 1</p> <p>Ejemplos pr\u00e1cticos 2</p> <p>Ejemplos pr\u00e1cticos 3</p> <p>Ejemplos pr\u00e1cticos 4</p>"},{"location":"Bloque2_Eventos_GUI/01_codigos1/","title":"Eventos y clases anidadas  -- s7d1","text":""},{"location":"Bloque2_Eventos_GUI/01_codigos1/#definiciones-y-ejemplos-ilustrativos","title":"Definiciones y ejemplos ilustrativos","text":""},{"location":"Bloque2_Eventos_GUI/01_codigos1/#eventos","title":"Eventos","text":""},{"location":"Bloque2_Eventos_GUI/01_codigos2/","title":"Eventos y clases anidadas   -- s7d2","text":""},{"location":"Bloque2_Eventos_GUI/01_codigos2/#definiciones-y-ejemplos-ilustrativos","title":"Definiciones y ejemplos ilustrativos","text":""},{"location":"Bloque2_Eventos_GUI/01_codigos2/#clases-anidadas","title":"Clases anidadas","text":""},{"location":"Bloque2_Eventos_GUI/01_eventos_clases_anidadas/","title":"Introducci\u00f3n, gestores de eventos y clases anidadas","text":"<p>Contenido en construcci\u00f3n</p> <p>Ejemplos pr\u00e1cticos 1</p> <p>Ejemplos pr\u00e1cticos 2</p>"},{"location":"Bloque2_Eventos_GUI/02_interfaz_grafica/","title":"Interfaz gr\u00e1fica de usuarios","text":"<p>Contenido en construcci\u00f3n</p>"},{"location":"Bloque2_Eventos_GUI/03_componentes_layouts_navegacion/","title":"Componentes, layouts y navegaci\u00f3n","text":"<p>Contenido en construcci\u00f3n</p>"},{"location":"Bloque3_Concurrente_Distribuida/01_concurrencia_sincronizacion/","title":"Introducci\u00f3n a la concurrencia y sincronizaci\u00f3n","text":"<p>Contenido en construcci\u00f3n</p>"},{"location":"Bloque3_Concurrente_Distribuida/02_comunicacion_paralelismo/","title":"Comunicaci\u00f3n entre hilos y paralelismo","text":"<p>Contenido en construcci\u00f3n</p>"},{"location":"Bloque3_Concurrente_Distribuida/03_programacion_distribuida/","title":"Introducci\u00f3n a la programaci\u00f3n distribuida","text":"<p>Contenido en construcci\u00f3n</p>"}]}