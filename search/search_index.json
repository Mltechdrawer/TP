{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tecnolog\u00edas de Programaci\u00f3nBienvenido a Tecnolog\u00edas de Programaci\u00f3n","text":""},{"location":"#tecnologias-de-programacion_1","title":"\ud83d\udcf1 Tecnolog\u00edas de programaci\u00f3n","text":"<p>Tecnolog\u00edas de Programaci\u00f3n es una asignatura obligatoria del 2.\u00ba curso del Grado en Ingenier\u00eda Inform\u00e1tica (1.er semestre, 6 ECTS). Su objetivo es dotar al alumnado de una formaci\u00f3n avanzada en t\u00e9cnicas y paradigmas de programaci\u00f3n que consolidan y ampl\u00edan los conocimientos adquiridos en Fundamentos de Programaci\u00f3n I y II.</p> <p>La asignatura combina teor\u00eda, ejercicios pr\u00e1cticos y actividades de laboratorio. Se fomenta la aplicaci\u00f3n de los conceptos en el dise\u00f1o y desarrollo de programas, as\u00ed como la reflexi\u00f3n cr\u00edtica sobre las soluciones propuestas. El aprendizaje progresivo a lo largo de los tres bloques permite al estudiante adquirir competencias clave para desenvolverse en entornos profesionales donde se requieren aplicaciones modulares, interactivas y con capacidad de ejecuci\u00f3n en paralelo o distribuida.</p> <p>El curso se apoya en un enfoque pr\u00e1ctico con trabajos individuales y en equipo, reforzando la capacidad de aplicar conceptos te\u00f3ricos a problemas reales de programaci\u00f3n. Esta asignatura constituye una base s\u00f3lida para asignaturas posteriores relacionadas con la ingenier\u00eda del software, los sistemas distribuidos y la inteligencia artificial.</p> <p>Profesorado:</p> <ul> <li> <p>David Freire Obreg\u00f3n. Profesor de pr\u00e1cticas. Coordinador  </p> </li> <li> <p>Ignacio Jos\u00e9 L\u00f3pez Rodr\u00edguez.</p> </li> <li> <p>Mar\u00eda Dolores Afonso Su\u00e1rez. </p> </li> </ul> <p></p> <p> </p>"},{"location":"contenidos/","title":"Contenidos","text":"<p>Tecnolog\u00edas de Programaci\u00f3n (TP) Los bloques est\u00e1n dise\u00f1ados para guiar al estudiante desde los fundamentos avanzados de POO hasta los paradigmas de programaci\u00f3n concurrente y distribuida. El objetivo es consolidar las bases de un programador profesional capaz de crear aplicaciones robustas, modulares y eficientes.</p> <p>BLOQUE 1. Conceptos avanzados de Programaci\u00f3n Orientada a Objetos revisa y ampl\u00eda los fundamentos de POO, profundizando en modularidad, herencia y reutilizaci\u00f3n de c\u00f3digo. Se abordan tambi\u00e9n la genericidad y los contenedores como ejemplos de aplicaci\u00f3n, proporcionando una visi\u00f3n madura del dise\u00f1o orientado a objetos.</p> <p>BLOQUE 2. Fundamentos de la Programaci\u00f3n Guiada por Eventos e Interfaz Gr\u00e1fica introduce el paradigma basado en eventos y el dise\u00f1o de interfaces. Se trabaja con gestores de eventos, clases anidadas, componentes y layouts para construir aplicaciones interactivas y usables.</p> <p>BLOQUE 3. Programaci\u00f3n Concurrente y Distribuida explora los principios de la concurrencia (sincronizaci\u00f3n, comunicaci\u00f3n entre hilos, paralelismo) y una introducci\u00f3n a la programaci\u00f3n distribuida, competencias clave para sistemas modernos y escalables.</p>"},{"location":"Bloque1_POO/01Java_vs_Python/","title":"Tema 1 \u00b7 Java vs Python","text":"<p>Este tema presenta una comparaci\u00f3n entre dos de los lenguajes de programaci\u00f3n m\u00e1s influyentes y utilizados en la actualidad: Java y Python. Ambos tienen fortalezas y limitaciones, y su elecci\u00f3n depende en gran medida del tipo de aplicaci\u00f3n que se desee desarrollar.</p>"},{"location":"Bloque1_POO/01Java_vs_Python/#sintaxis","title":"Sintaxis","text":"<ul> <li>Java: Su sintaxis es m\u00e1s estricta, requiere punto y coma al final de cada sentencia y la declaraci\u00f3n expl\u00edcita de tipos. Esto fuerza al programador a ser m\u00e1s detallista y riguroso desde el principio.</li> <li>Python: Su sintaxis es mucho m\u00e1s simple y legible, no necesita punto y coma ni declaraci\u00f3n previa de tipos. Esto facilita la escritura de programas cortos y prototipos r\u00e1pidos.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#tipado","title":"Tipado","text":"<ul> <li>Java: Est\u00e1ticamente tipado. Los tipos de las variables son fijos y se conocen en tiempo de compilaci\u00f3n. Esto puede reducir errores en ejecuci\u00f3n y mejorar la eficiencia.</li> <li>Python: Din\u00e1micamente tipado. El tipo de las variables puede cambiar durante la ejecuci\u00f3n. Esto proporciona mayor flexibilidad pero puede provocar errores en tiempo de ejecuci\u00f3n si no se controla bien.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#velocidad-de-ejecucion","title":"Velocidad de ejecuci\u00f3n","text":"<ul> <li>Java: Generalmente m\u00e1s r\u00e1pido porque el c\u00f3digo se compila a bytecode y se ejecuta en la JVM (Java Virtual Machine), lo que optimiza el rendimiento.</li> <li>Python: M\u00e1s lento porque se interpreta l\u00ednea por l\u00ednea. Aunque existen int\u00e9rpretes optimizados, en aplicaciones de gran escala puede ser menos eficiente.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#compilacion-vs-interpretacion","title":"Compilaci\u00f3n vs Interpretaci\u00f3n","text":"<ul> <li>Java: Es un lenguaje compilado a bytecode, que despu\u00e9s se ejecuta en la JVM. Esto permite portabilidad entre sistemas y cierto equilibrio entre rendimiento y flexibilidad.</li> <li>Python: Lenguaje interpretado, ejecutado l\u00ednea por l\u00ednea. Esto facilita la depuraci\u00f3n y flexibilidad, pero penaliza la velocidad.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#uso-de-memoria-y-gestion","title":"Uso de memoria y gesti\u00f3n","text":"<ul> <li>Java: Utiliza m\u00e1s memoria, pero su gesti\u00f3n se realiza mediante un recolector de basura robusto que maneja autom\u00e1ticamente la memoria no utilizada.</li> <li>Python: Su consumo de memoria suele ser menor, aunque tambi\u00e9n implementa mecanismos de recolecci\u00f3n de basura.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#paradigma-de-programacion","title":"Paradigma de programaci\u00f3n","text":"<ul> <li>Java: Lenguaje orientado a objetos puro. Todo debe formar parte de una clase. Aunque soporta elementos funcionales (como lambdas), su enfoque central es OOP.</li> <li>Python: Soporta m\u00faltiples paradigmas: orientaci\u00f3n a objetos, programaci\u00f3n funcional y programaci\u00f3n procedimental. Es m\u00e1s flexible y adaptable.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#bibliotecas-y-ecosistema","title":"Bibliotecas y ecosistema","text":"<ul> <li>Java: Ecosistema muy s\u00f3lido, especialmente en aplicaciones empresariales, m\u00f3viles (Android) y web de gran escala.</li> <li>Python: Ecosistema con gran popularidad en ciencia de datos, inteligencia artificial y aprendizaje autom\u00e1tico. Destaca por bibliotecas como NumPy, Pandas o TensorFlow.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#portabilidad","title":"Portabilidad","text":"<ul> <li>Java: Altamente portable gracias a la JVM. El lema \u201cwrite once, run anywhere\u201d refleja esta fortaleza.</li> <li>Python: Tambi\u00e9n portable, pero en ocasiones depende de bibliotecas externas que pueden no estar disponibles en todas las plataformas.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#aplicaciones-comunes","title":"Aplicaciones comunes","text":"<ul> <li>Java: Usado en aplicaciones empresariales, m\u00f3viles (Android) y sistemas web de gran rendimiento y escala.</li> <li>Python: Predomina en ciencia de datos, inteligencia artificial, automatizaci\u00f3n de tareas y desarrollo r\u00e1pido de prototipos.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#comunidad-y-aprendizaje","title":"Comunidad y aprendizaje","text":"<ul> <li>Java: Considerado m\u00e1s dif\u00edcil de aprender al inicio por la complejidad de su sintaxis y la necesidad de definir estructuras m\u00e1s r\u00edgidas.</li> <li>Python: Lenguaje valorado como uno de los m\u00e1s accesibles para principiantes. Su sintaxis clara y directa lo convierten en una excelente opci\u00f3n para iniciarse en la programaci\u00f3n.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#resumen","title":"Resumen","text":"<ul> <li>Java: Ideal para aplicaciones grandes, multiplataforma y de alto rendimiento. Aporta robustez y seguridad.</li> <li>Python: Flexible, sencillo de aprender y con un enorme protagonismo en \u00e1reas emergentes como la IA y la ciencia de datos.</li> </ul>"},{"location":"Bloque1_POO/01_repaso_poo/","title":"Tema \u00b7 Repaso de Programaci\u00f3n Orientada a Objetos","text":"<p>La Programaci\u00f3n Orientada a Objetos (POO) es un paradigma de programaci\u00f3n que organiza el software en torno a entidades llamadas objetos, los cuales agrupan datos y comportamientos relacionados. Este enfoque resulta fundamental en la ingenier\u00eda del software moderna y sirve como base para muchos lenguajes de programaci\u00f3n actuales, como Java, C++ o Python.</p>"},{"location":"Bloque1_POO/01_repaso_poo/#1-principios-basicos-de-la-poo","title":"1. Principios b\u00e1sicos de la POO","text":""},{"location":"Bloque1_POO/01_repaso_poo/#abstraccion","title":"Abstracci\u00f3n","text":"<p>La abstracci\u00f3n consiste en identificar las caracter\u00edsticas esenciales de una entidad del mundo real y representarlas en un modelo computacional. Ejemplo: una clase <code>Coche</code> que abstrae atributos como <code>color</code> y <code>velocidad</code>, y m\u00e9todos como <code>acelerar()</code> o <code>frenar()</code>. \ud83d\udc49 Ejecutar en Binder</p>"},{"location":"Bloque1_POO/01_repaso_poo/#encapsulacion","title":"Encapsulaci\u00f3n","text":"<p>La encapsulaci\u00f3n protege el acceso directo a los datos internos de un objeto, control\u00e1ndolo mediante m\u00e9todos definidos. Esto mejora la seguridad y reduce la dependencia entre m\u00f3dulos. Ejemplo: atributos privados con m\u00e9todos getters y setters.</p>"},{"location":"Bloque1_POO/01_repaso_poo/#herencia","title":"Herencia","text":"<p>La herencia permite que una clase (subclase) herede atributos y m\u00e9todos de otra (superclase). Facilita la reutilizaci\u00f3n de c\u00f3digo y la creaci\u00f3n de jerarqu\u00edas l\u00f3gicas. Ejemplo: <code>Vehiculo</code> como superclase, y <code>Coche</code> y <code>Moto</code> como subclases.</p>"},{"location":"Bloque1_POO/01_repaso_poo/#polimorfismo","title":"Polimorfismo","text":"<p>El polimorfismo permite que un mismo m\u00e9todo tenga comportamientos distintos seg\u00fan el contexto o la clase que lo implemente. Ejemplo: el m\u00e9todo <code>mover()</code> puede estar implementado de forma distinta en <code>Coche</code>, <code>Avion</code> o <code>Barco</code>.</p>"},{"location":"Bloque1_POO/01_repaso_poo/#2-objetos-y-clases","title":"2. Objetos y clases","text":"<ul> <li>Clase: Es la plantilla que define las propiedades (atributos) y comportamientos (m\u00e9todos).  </li> <li>Objeto: Es una instancia concreta de una clase, que posee valores espec\u00edficos para sus atributos.  </li> </ul> <p>Ejemplo en pseudoc\u00f3digo:</p> <pre><code>class Persona {\n    String nombre;\n    int edad;\n\n    void saludar() {\n        System.out.println(\"Hola, me llamo \" + nombre);\n    }\n}\n\n// Creaci\u00f3n de un objeto\nPersona p1 = new Persona();\np1.nombre = \"Ana\";\np1.edad = 25;\np1.saludar();\n</code></pre>"},{"location":"Bloque1_POO/01_repaso_poo/#3-ventajas-de-la-poo","title":"3. Ventajas de la POO","text":"<ul> <li>Modularidad: el c\u00f3digo se organiza en componentes independientes.  </li> <li>Reutilizaci\u00f3n: se puede extender y adaptar c\u00f3digo existente sin reescribirlo.  </li> <li>Mantenibilidad: facilita la lectura, depuraci\u00f3n y evoluci\u00f3n del software.  </li> <li>Escalabilidad: permite modelar sistemas complejos con jerarqu\u00edas de clases y objetos.</li> </ul>"},{"location":"Bloque1_POO/01_repaso_poo/#4-poo-en-la-practica","title":"4. POO en la pr\u00e1ctica","text":"<p>En la actualidad, la POO se integra con otros paradigmas. Lenguajes como Java siguen una orientaci\u00f3n a objetos estricta, mientras que Python o C# permiten combinarla con enfoques funcionales y procedimentales. El repaso de estos conceptos es crucial para afrontar los siguientes temas del bloque, donde se profundizar\u00e1 en aspectos avanzados como modularidad, herencia compleja, genericidad y el uso de contenedores.</p>"},{"location":"Bloque1_POO/01_repaso_poo/#5-conclusion","title":"5. Conclusi\u00f3n","text":"<p>La Programaci\u00f3n Orientada a Objetos constituye una base s\u00f3lida para el desarrollo de software moderno. Sus principios permiten construir sistemas m\u00e1s claros, mantenibles y robustos, y son fundamentales para abordar los contenidos m\u00e1s avanzados de la asignatura.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/","title":"Conceptos avanzados de modularidad, herencia y reusabilidad","text":"<p>Contenido en construcci\u00f3n</p>"},{"location":"Bloque1_POO/03_genericidad_contenedores/","title":"Genericidad; contenedores como ejemplo de aplicaci\u00f3n","text":"<p>Contenido en construcci\u00f3n</p>"},{"location":"Bloque2_Eventos_GUI/01_eventos_clases_anidadas/","title":"Introducci\u00f3n, gestores de eventos y clases anidadas","text":"<p>Contenido en construcci\u00f3n</p>"},{"location":"Bloque2_Eventos_GUI/02_interfaz_grafica/","title":"Interfaz gr\u00e1fica de usuarios","text":"<p>Contenido en construcci\u00f3n</p>"},{"location":"Bloque2_Eventos_GUI/03_componentes_layouts_navegacion/","title":"Componentes, layouts y navegaci\u00f3n","text":"<p>Contenido en construcci\u00f3n</p>"},{"location":"Bloque3_Concurrente_Distribuida/01_concurrencia_sincronizacion/","title":"Introducci\u00f3n a la concurrencia y sincronizaci\u00f3n","text":"<p>Contenido en construcci\u00f3n</p>"},{"location":"Bloque3_Concurrente_Distribuida/02_comunicacion_paralelismo/","title":"Comunicaci\u00f3n entre hilos y paralelismo","text":"<p>Contenido en construcci\u00f3n</p>"},{"location":"Bloque3_Concurrente_Distribuida/03_programacion_distribuida/","title":"Introducci\u00f3n a la programaci\u00f3n distribuida","text":"<p>Contenido en construcci\u00f3n</p>"}]}