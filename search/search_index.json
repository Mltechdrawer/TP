{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tecnolog\u00edas de Programaci\u00f3nBienvenido a Tecnolog\u00edas de Programaci\u00f3n","text":""},{"location":"#tecnologias-de-programacion_1","title":"\ud83d\udcf1 Tecnolog\u00edas de programaci\u00f3n","text":"<p>Tecnolog\u00edas de Programaci\u00f3n es una asignatura obligatoria del 2.\u00ba curso del Grado en Ingenier\u00eda Inform\u00e1tica (1.er semestre, 6 ECTS). Su objetivo es dotar al alumnado de una formaci\u00f3n avanzada en t\u00e9cnicas y paradigmas de programaci\u00f3n que consolidan y ampl\u00edan los conocimientos adquiridos en Fundamentos de Programaci\u00f3n I y II.</p> <p>La asignatura combina teor\u00eda, ejercicios pr\u00e1cticos y actividades de laboratorio. Se fomenta la aplicaci\u00f3n de los conceptos en el dise\u00f1o y desarrollo de programas, as\u00ed como la reflexi\u00f3n cr\u00edtica sobre las soluciones propuestas. El aprendizaje progresivo a lo largo de los tres bloques permite al estudiante adquirir competencias clave para desenvolverse en entornos profesionales donde se requieren aplicaciones modulares, interactivas y con capacidad de ejecuci\u00f3n en paralelo o distribuida.</p> <p>El curso se apoya en un enfoque pr\u00e1ctico con trabajos individuales y en equipo, reforzando la capacidad de aplicar conceptos te\u00f3ricos a problemas reales de programaci\u00f3n. Esta asignatura constituye una base s\u00f3lida para asignaturas posteriores relacionadas con la ingenier\u00eda del software, los sistemas distribuidos y la inteligencia artificial.</p> <p>Profesorado:</p> <ul> <li> <p>David Freire Obreg\u00f3n. Profesor de pr\u00e1cticas. Coordinador  </p> </li> <li> <p>Ignacio Jos\u00e9 L\u00f3pez Rodr\u00edguez.</p> </li> <li> <p>Mar\u00eda Dolores Afonso Su\u00e1rez. </p> </li> </ul> <p></p> <p> </p> <p>\u00a9 2025 Mar\u00eda Dolores Afonso Su\u00e1rez. Este material se distribuye bajo licencia Creative Commons Atribuci\u00f3n 4.0 Internacional (CC BY 4.0).</p>"},{"location":"contenidos/","title":"Contenidos","text":"<p>Tecnolog\u00edas de Programaci\u00f3n (TP) Los bloques est\u00e1n dise\u00f1ados para guiar al estudiante desde los fundamentos avanzados de POO hasta los paradigmas de programaci\u00f3n concurrente y distribuida. El objetivo es consolidar las bases de un programador profesional capaz de crear aplicaciones robustas, modulares y eficientes.</p> <p>BLOQUE 1. Conceptos avanzados de Programaci\u00f3n Orientada a Objetos revisa y ampl\u00eda los fundamentos de POO, profundizando en modularidad, herencia y reutilizaci\u00f3n de c\u00f3digo. Se abordan tambi\u00e9n la genericidad y los contenedores como ejemplos de aplicaci\u00f3n, proporcionando una visi\u00f3n madura del dise\u00f1o orientado a objetos.</p> <p>BLOQUE 2. Fundamentos de la Programaci\u00f3n Guiada por Eventos e Interfaz Gr\u00e1fica introduce el paradigma basado en eventos y el dise\u00f1o de interfaces. Se trabaja con gestores de eventos, clases anidadas, componentes y layouts para construir aplicaciones interactivas y usables.</p> <p>BLOQUE 3. Programaci\u00f3n Concurrente y Distribuida explora los principios de la concurrencia (sincronizaci\u00f3n, comunicaci\u00f3n entre hilos, paralelismo) y una introducci\u00f3n a la programaci\u00f3n distribuida, competencias clave para sistemas modernos y escalables.</p>"},{"location":"Bloque1_POO/01Java_vs_Python/","title":"Java vs Python","text":"<p>Este tema presenta una comparaci\u00f3n entre dos de los lenguajes de programaci\u00f3n m\u00e1s influyentes y utilizados en la actualidad: Java y Python. Ambos tienen fortalezas y limitaciones, y su elecci\u00f3n depende en gran medida del tipo de aplicaci\u00f3n que se desee desarrollar.</p>"},{"location":"Bloque1_POO/01Java_vs_Python/#sintaxis","title":"Sintaxis","text":"<ul> <li>Java: Su sintaxis es m\u00e1s estricta, requiere punto y coma al final de cada sentencia y la declaraci\u00f3n expl\u00edcita de tipos. Esto fuerza al programador a ser m\u00e1s detallista y riguroso desde el principio.</li> <li>Python: Su sintaxis es mucho m\u00e1s simple y legible, no necesita punto y coma ni declaraci\u00f3n previa de tipos. Esto facilita la escritura de programas cortos y prototipos r\u00e1pidos.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#tipado","title":"Tipado","text":"<ul> <li>Java: Est\u00e1ticamente tipado. Los tipos de las variables son fijos y se conocen en tiempo de compilaci\u00f3n. Esto puede reducir errores en ejecuci\u00f3n y mejorar la eficiencia.</li> <li>Python: Din\u00e1micamente tipado. El tipo de las variables puede cambiar durante la ejecuci\u00f3n. Esto proporciona mayor flexibilidad pero puede provocar errores en tiempo de ejecuci\u00f3n si no se controla bien.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#velocidad-de-ejecucion","title":"Velocidad de ejecuci\u00f3n","text":"<ul> <li>Java: Generalmente m\u00e1s r\u00e1pido porque el c\u00f3digo se compila a bytecode y se ejecuta en la JVM (Java Virtual Machine), lo que optimiza el rendimiento.</li> <li>Python: M\u00e1s lento porque se interpreta l\u00ednea por l\u00ednea. Aunque existen int\u00e9rpretes optimizados, en aplicaciones de gran escala puede ser menos eficiente.</li> </ul> <p>Velocidad de ejecuci\u00f3n</p>"},{"location":"Bloque1_POO/01Java_vs_Python/#compilacion-vs-interpretacion","title":"Compilaci\u00f3n vs Interpretaci\u00f3n","text":"<ul> <li>Java: Es un lenguaje compilado a bytecode, que despu\u00e9s se ejecuta en la JVM. Esto permite portabilidad entre sistemas y cierto equilibrio entre rendimiento y flexibilidad.</li> <li>Python: Lenguaje interpretado, ejecutado l\u00ednea por l\u00ednea. Esto facilita la depuraci\u00f3n y flexibilidad, pero penaliza la velocidad.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#uso-de-memoria-y-gestion","title":"Uso de memoria y gesti\u00f3n","text":"<ul> <li>Java: Utiliza m\u00e1s memoria, pero su gesti\u00f3n se realiza mediante un recolector de basura robusto que maneja autom\u00e1ticamente la memoria no utilizada.</li> <li>Python: Su consumo de memoria suele ser menor, aunque tambi\u00e9n implementa mecanismos de recolecci\u00f3n de basura.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#paradigma-de-programacion","title":"Paradigma de programaci\u00f3n","text":"<ul> <li>Java: Lenguaje orientado a objetos puro. Todo debe formar parte de una clase. Aunque soporta elementos funcionales (como lambdas), su enfoque central es OOP.</li> <li>Python: Soporta m\u00faltiples paradigmas: orientaci\u00f3n a objetos, programaci\u00f3n funcional y programaci\u00f3n procedimental. Es m\u00e1s flexible y adaptable.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#bibliotecas-y-ecosistema","title":"Bibliotecas y ecosistema","text":"<ul> <li>Java: Ecosistema muy s\u00f3lido, especialmente en aplicaciones empresariales, m\u00f3viles (Android) y web de gran escala.</li> <li>Python: Ecosistema con gran popularidad en ciencia de datos, inteligencia artificial y aprendizaje autom\u00e1tico. Destaca por bibliotecas como NumPy, Pandas o TensorFlow.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#portabilidad","title":"Portabilidad","text":"<ul> <li>Java: Altamente portable gracias a la JVM. El lema \u201cwrite once, run anywhere\u201d refleja esta fortaleza.</li> <li>Python: Tambi\u00e9n portable, pero en ocasiones depende de bibliotecas externas que pueden no estar disponibles en todas las plataformas.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#aplicaciones-comunes","title":"Aplicaciones comunes","text":"<ul> <li>Java: Usado en aplicaciones empresariales, m\u00f3viles (Android) y sistemas web de gran rendimiento y escala.</li> <li>Python: Predomina en ciencia de datos, inteligencia artificial, automatizaci\u00f3n de tareas y desarrollo r\u00e1pido de prototipos.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#comunidad-y-aprendizaje","title":"Comunidad y aprendizaje","text":"<ul> <li>Java: Considerado m\u00e1s dif\u00edcil de aprender al inicio por la complejidad de su sintaxis y la necesidad de definir estructuras m\u00e1s r\u00edgidas.</li> <li>Python: Lenguaje valorado como uno de los m\u00e1s accesibles para principiantes. Su sintaxis clara y directa lo convierten en una excelente opci\u00f3n para iniciarse en la programaci\u00f3n.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#resumen","title":"Resumen","text":"<ul> <li>Java: Ideal para aplicaciones grandes, multiplataforma y de alto rendimiento. Aporta robustez y seguridad.</li> <li>Python: Flexible, sencillo de aprender y con un enorme protagonismo en \u00e1reas emergentes como la IA y la ciencia de datos.</li> </ul>"},{"location":"Bloque1_POO/01_codigos/","title":"Tema \u00b7 Repaso de Programaci\u00f3n Orientada a Objetos","text":"<p>Ejemplos de c\u00f3digo </p>"},{"location":"Bloque1_POO/01_codigos/#velocidad-de-ejecucion","title":"Velocidad de ejecuci\u00f3n","text":""},{"location":"Bloque1_POO/01_codigos/#java","title":"Java","text":"<pre><code>public class VelocidadJava {\n    public static void main(String[] args) {\n        long startTime = System.nanoTime();\n\n        int suma = 0;\n        for (int i = 0; i &lt; 1000000; i++) {\n            suma += i;\n        }\n\n        long endTime = System.nanoTime();\n        System.out.println(\"Tiempo de ejecuci\u00f3n en Java: \" + (endTime - startTime) + \" nanosegundos.\");\n    }\n}\n// Java. Valores aproximados a: 3927653 nanosegundos (unos 4 milisegundos)\n</code></pre> <pre><code>import time\n\nstart_time = time.time()\n\nsuma = 0\nfor i in range(1000000):\n    suma += i\n\nend_time = time.time()\nprint(\"Tiempo de ejecuci\u00f3n en Python:\", (end_time - start_time), \"segundos\")\n\n// Python. Valores aproximados a: 0.13556790351867676 segundos (unos 135 milisegundos)\n</code></pre>"},{"location":"Bloque1_POO/01_codigos/#abstraccion","title":"Abstracci\u00f3n","text":"<pre><code>// Clase abstracta que define el comportamiento de un Vehiculo\nabstract class Vehiculo {\n    // M\u00e9todo abstracto: las subclases deben implementar c\u00f3mo encender el veh\u00edculo\n    public abstract void encender();\n\n    // M\u00e9todo abstracto: las subclases deben implementar c\u00f3mo apagar el veh\u00edculo\n    public abstract void apagar();\n\n    // M\u00e9todo com\u00fan que puede ser usado por todas las subclases\n    public void mostrarTipo() {\n        System.out.println(\"Este es un veh\u00edculo.\");\n    }\n}\n\n// Clase concreta que extiende de la clase abstracta Vehiculo\nclass Coche extends Vehiculo {\n    // Implementaci\u00f3n del m\u00e9todo encender\n    public void encender() {\n        System.out.println(\"El coche est\u00e1 encendido.\");\n    }\n\n    // Implementaci\u00f3n del m\u00e9todo apagar\n    public void apagar() {\n        System.out.println(\"El coche est\u00e1 apagado.\");\n    }\n}\n\n// Clase principal que usa la abstracci\u00f3n\npublic class Main {  \n    public static void main(String[] args) {\n        // Creamos un objeto de tipo Coche\n        Coche miCoche = new Coche();\n\n        // Usamos los m\u00e9todos abstractos implementados\n        miCoche.encender();\n        miCoche.mostrarTipo();\n        miCoche.apagar();\n\n        // Intentar crear un objeto de la clase abstracta (esto va a generar un error de compilaci\u00f3n)\n        Vehiculo miVehiculo = new Vehiculo();  // &lt;-- Esto genera un error\n    }\n}\n</code></pre>"},{"location":"Bloque1_POO/01_codigos/#encapsulamiento","title":"Encapsulamiento","text":"<pre><code>class Circulo {\n    // Al ser private solo los m\u00e9todos de esta clase pueden acceder a ellos\n    private String color;\n    private int radio;\n    private int x, y;\n\n    // El constructor permite crear objetos c\u00edrculo con valores iniciales para sus atributos \n    public Circulo(String color, int radio, int x, int y) {\n        this.color = color;\n        this.radio = radio;\n        this.x = x;\n        this.y = y;\n    }\n    // M\u00e9todos que pueden alterar  los atributos de forma controlada\n        public void cambiarTamano(int nuevoRadio) {\n        this.radio = nuevoRadio;\n    }\n\n    public void cambiarPosicion(int nuevaX, int nuevaY) {\n        this.x = nuevaX;\n        this.y = nuevaY;\n    }\n    // Encapsula la representaci\u00f3n del objeto\n    public void mostrar() {\n        System.out.println(\"C\u00edrculo de color \" + color + \", radio \" + radio +\n                           \", en la posici\u00f3n (\" + x + \", \" + y + \")\");\n    }\n}\n// Clase principal. Ejemplo de uso de encapsulamiento.\npublic class Main {\n    public static void main(String[] args) {\n        Circulo circulo1 = new Circulo(\"Rojo\", 50, 100, 100);\n        Circulo circulo2 = new Circulo(\"Verde\", 30, 200, 150);\n        Circulo circulo3 = new Circulo(\"Azul\", 70, 300, 250);\n\n        circulo1.mostrar();\n        circulo2.mostrar();\n        circulo3.mostrar();\n        // Solo llama a los m\u00e9todos p\u00fablicos, no le interesa como se realizan\n        circulo1.cambiarTamano(80);\n        circulo1.cambiarPosicion(150, 200);\n\n        circulo1.mostrar();\n    }\n}\n\n</code></pre>"},{"location":"Bloque1_POO/01_codigos/#herencia","title":"Herencia","text":"<pre><code>class Animal {\n    private final String nombre;\n    Animal(String nombre) { this.nombre = nombre; }\n    public void sonar() { System.out.println(nombre + \": hace un sonido gen\u00e9rico\"); }\n    public String getNombre() { return nombre; }\n}\n\nclass Perro extends Animal {\n    Perro(String nombre) { super(nombre); }\n    // Anotaci\u00f3n de un m\u00e9todo, que indica que se sobreescribe\n    @Override public void sonar() { System.out.println(getNombre() + \": \u00a1guau!\"); }\n    public void traerPelota() { System.out.println(getNombre() + \" trae la pelota\"); }\n}\n\npublic class Main { // \u2190 Aseg\u00farate de que el archivo se llame Main.java\n    public static void main(String[] args) {\n        Animal a = new Animal(\"Animal\");\n        Animal p = new Perro(\"Toby\");\n        a.sonar();\n        p.sonar();\n        if (p instanceof Perro) ((Perro) p).traerPelota();\n    }\n}\n</code></pre>"},{"location":"Bloque1_POO/01_codigos/#polimorfismo","title":"Polimorfismo","text":"<pre><code>// Superclase/abstracci\u00f3n\nabstract class Figura {\n    private final String nombre;\n    Figura(String nombre) { this.nombre = nombre; }\n\n    public String getNombre() { return nombre; }\n\n    // M\u00e9todo polim\u00f3rfico: cada subclase lo implementa a su manera\n    public abstract double area();\n\n    // Comportamiento com\u00fan que tambi\u00e9n puede sobrescribirse\n    public void dibujar() {\n        System.out.println(\"Dibujando \" + nombre + \" gen\u00e9rico\");\n    }\n}\n\n// Subclase 1: Circulo\nclass Circulo extends Figura {\n    private final double radio;\n    //Especializa la figura para un c\u00edrculo\n    Circulo(double radio) {\n        super(\"c\u00edrculo\");\n        this.radio = radio;\n    }\n    @Override public double area() { return Math.PI * radio * radio; }\n    @Override public void dibujar() { System.out.println(\"Dibujando un c\u00edrculo\"); }\n}\n\n// Subclase 2: Rect\u00e1ngulo\nclass Rectangulo extends Figura {\n    private final double ancho, alto;\n    // Especializa la figura para un rect\u00e1ngulo\n    Rectangulo(double ancho, double alto) {\n        super(\"rect\u00e1ngulo\");\n        this.ancho = ancho; this.alto = alto;\n    }\n    @Override public double area() { return ancho * alto; }\n    // Usa el dibujar() heredado si no lo sobrescribes\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        // Polimorfismo: misma referencia (Figura), distintos objetos concretos\n        Figura[] figuras = { new Circulo(2.0), new Rectangulo(3.0, 4.0) };\n\n        for (Figura f : figuras) {\n            f.dibujar();                              // despacho din\u00e1mico\n            System.out.printf(\"\u00c1rea de %s: %.2f%n\", \n                              f.getNombre(), f.area()); // llama al override adecuado\n        }\n\n        // Otra muestra de polimorfismo en un m\u00e9todo que recibe la superclase\n\n        procesar(new Circulo(5.0));       // usa procesar(Figura f)\n        procesar(new Rectangulo(2.0, 6.0)); // usa procesar(Figura f)\n        procesar(new Circulo(3.0), \"extra\"); // usa procesar(Circulo c, String msg)\n    }\n    // Polimorfismo din\u00e1mico (sobrescritura)\n    static void procesar(Figura f) {\n        // procesar se resuelve en tiempo de compilaci\u00f3n\n        System.out.println(\"Procesando \" + f.getClass().getSimpleName()\n                           + \" con \u00e1rea \" + f.area());\n                           //f.area se resuelve en tiempo de ejecuci\u00f3n\n    }\n    // Sobrecarga espec\u00edfica para Circulo\n    static void procesar(Circulo c) {\n        System.out.println(\"Procesando espec\u00edficamente un c\u00edrculo con radio \"\n                           + c.area());\n    }\n\n    // Otra sobrecarga con par\u00e1metros adicionales\n    // Esta es una sobrecarga est\u00e1tica, se decide en tiempo de compilaci\u00f3n porque los par\u00e1metros coinciden exactamente\n    static void procesar(Circulo c, String msg) {\n        System.out.println(\"Procesando c\u00edrculo con mensaje: \" + msg \n                           + \" y \u00e1rea \" + c.area());\n    }\n}\n</code></pre>  Overrride vs Overload  <p> Override (area(), dibujar()): </p> <p> - Misma firma que en la superclase. </p> <p> - Decide en tiempo de ejecuci\u00f3n qu\u00e9 versi\u00f3n usar. </p> <p> Overload (procesar(Figura), procesar(Circulo), procesar(Circulo,String)): </p> <p> - Mismo nombre, distinta lista de par\u00e1metros. </p> <p> - Decide en tiempo de compilaci\u00f3n qu\u00e9 versi\u00f3n usar. </p>"},{"location":"Bloque1_POO/01_codigos/#clases-y-objetos","title":"Clases y objetos","text":"<pre><code>class Persona {\n    String nombre;\n    int edad;\n\n    void saludar() {\n        System.out.println(\"Hola, me llamo \" + nombre);\n    }\n}\n\n// Creaci\u00f3n de un objeto\nPersona p1 = new Persona();\np1.nombre = \"Ana\";\np1.edad = 25;\np1.saludar();\n</code></pre>"},{"location":"Bloque1_POO/01_repaso_poo/","title":"Tema \u00b7 Repaso de Programaci\u00f3n Orientada a Objetos","text":"<p>La Programaci\u00f3n Orientada a Objetos (POO) es un paradigma de programaci\u00f3n que organiza el software en torno a entidades llamadas objetos, los cuales agrupan datos y comportamientos relacionados. Este enfoque resulta fundamental en la ingenier\u00eda del software moderna y sirve como base para muchos lenguajes de programaci\u00f3n actuales, como Java, C++ o Python.</p>"},{"location":"Bloque1_POO/01_repaso_poo/#1-principios-basicos-de-la-poo","title":"1. Principios b\u00e1sicos de la POO","text":""},{"location":"Bloque1_POO/01_repaso_poo/#abstraccion","title":"Abstracci\u00f3n","text":"<p>La abstracci\u00f3n consiste en identificar las caracter\u00edsticas esenciales de una entidad del mundo real y representarlas en un modelo computacional.  </p> <p>Ejemplo Abstracci\u00f3n</p>"},{"location":"Bloque1_POO/01_repaso_poo/#encapsulacion","title":"Encapsulaci\u00f3n","text":"<p>La encapsulaci\u00f3n protege el acceso directo a los datos internos de un objeto, control\u00e1ndolo mediante m\u00e9todos definidos. Esto mejora la seguridad y reduce la dependencia entre m\u00f3dulos.  </p> <p>Ejemplo Encapsulamiento</p>"},{"location":"Bloque1_POO/01_repaso_poo/#herencia","title":"Herencia","text":"<p>La herencia permite que una clase (subclase) herede atributos y m\u00e9todos de otra (superclase). Facilita la reutilizaci\u00f3n de c\u00f3digo y la creaci\u00f3n de jerarqu\u00edas l\u00f3gicas.  </p> <p>Ejemplo Herencia</p>"},{"location":"Bloque1_POO/01_repaso_poo/#polimorfismo","title":"Polimorfismo","text":"<p>El polimorfismo permite que un mismo m\u00e9todo tenga comportamientos distintos seg\u00fan el contexto o la clase que lo implemente.  </p> <p>Ejemplo Polimorfismo</p>"},{"location":"Bloque1_POO/01_repaso_poo/#2-objetos-y-clases","title":"2. Objetos y clases","text":"<ul> <li>Clase: Es la plantilla que define las propiedades (atributos) y comportamientos (m\u00e9todos).  </li> <li>Objeto: Es una instancia concreta de una clase, que posee valores espec\u00edficos para sus atributos.  </li> </ul> <p>Ejemplo Clase y objeto</p>"},{"location":"Bloque1_POO/01_repaso_poo/#3-ventajas-de-la-poo","title":"3. Ventajas de la POO","text":"<ul> <li>Modularidad: el c\u00f3digo se organiza en componentes independientes.  </li> <li>Reutilizaci\u00f3n: se puede extender y adaptar c\u00f3digo existente sin reescribirlo.  </li> <li>Mantenibilidad: facilita la lectura, depuraci\u00f3n y evoluci\u00f3n del software.  </li> <li>Escalabilidad: permite modelar sistemas complejos con jerarqu\u00edas de clases y objetos.</li> </ul>"},{"location":"Bloque1_POO/01_repaso_poo/#4-poo-en-la-practica","title":"4. POO en la pr\u00e1ctica","text":"<p>En la actualidad, la POO se integra con otros paradigmas. Lenguajes como Java siguen una orientaci\u00f3n a objetos estricta, mientras que Python o C# permiten combinarla con enfoques funcionales y procedimentales. El repaso de estos conceptos es crucial para afrontar los siguientes temas del bloque, donde se profundizar\u00e1 en aspectos avanzados como modularidad, herencia compleja, genericidad y el uso de contenedores.</p>"},{"location":"Bloque1_POO/01_repaso_poo/#5-conclusion","title":"5. Conclusi\u00f3n","text":"<p>La Programaci\u00f3n Orientada a Objetos constituye una base s\u00f3lida para el desarrollo de software moderno. Sus principios permiten construir sistemas m\u00e1s claros, mantenibles y robustos, y son fundamentales para abordar los contenidos m\u00e1s avanzados de la asignatura.</p> <p>Java vs Python</p>"},{"location":"Bloque1_POO/02_codigos1/","title":"Modularidad, Herencia y Reusabilidad","text":""},{"location":"Bloque1_POO/02_codigos1/#definiciones-y-ejemplos-ilustrativos","title":"Definiciones y ejemplos ilustrativos","text":""},{"location":"Bloque1_POO/02_codigos1/#tipos-primitivos-paso-por-valor","title":"Tipos primitivos - paso por valor","text":"<pre><code>public class PasoPorValorPrimitivo {\n    public static void main(String[] args) {\n        int numero = 10;\n        cambiarValor(numero);\n        System.out.println(\"Valor despu\u00e9s de llamar al m\u00e9todo: \" + numero); // Imprime 10\n    }\n\n    public static void cambiarValor(int valor) {\n        valor = 20; // Esta modificaci\u00f3n no afecta a 'numero' en el m\u00e9todo main\n    }\n}\n// En los tipos de datos primitivos se pasa una copia del valor.\n</code></pre> \ud83d\udca1 Paso de par\u00e1metros <p>En los tipos de datos primitivos se pasa una copia del valor. </p>"},{"location":"Bloque1_POO/02_codigos1/#objetos-paso-por-referencia","title":"Objetos - paso por referencia","text":"<pre><code>public class PasoPorValorReferencia {\n    public static void main(String[] args) {\n        MiObjeto objeto = new MiObjeto();\n        objeto.valor = 10;\n\n        modificarObjeto(objeto);\n        System.out.println(\"Valor despu\u00e9s de llamar al m\u00e9todo: \" + objeto.valor); // Imprime 20\n    }\n\n    public static void modificarObjeto(MiObjeto obj) {\n        obj.valor = 20; // Modifica el valor del objeto original\n    }\n}\n\nclass MiObjeto {\n    int valor;\n}\n\n</code></pre> \ud83d\udca1 Paso de par\u00e1metros <p>En los objtos se pasa una copia de la referncia, por lo que ambos apuntan al mismo objeto.  Esto permite modificar el objeto original a trav\u00e9s de la referencia. </p>"},{"location":"Bloque1_POO/02_codigos1/#paso-por-referencia-ejemplo","title":"Paso por referencia. Ejemplo.","text":"<pre><code>public class ReferenciaEjemplo {\n    public static void main(String[] args) {\n        // Creamos un objeto de la clase String\n        String mensaje = \"Hola, mundo\";\n\n        // Creamos otra referencia que apunta al mismo objeto\n        String otraReferencia = mensaje;\n\n        // Mostramos el contenido de ambas referencias\n        System.out.println(\"Mensaje original: \" + mensaje);\n        System.out.println(\"Otra referencia: \" + otraReferencia);\n\n        // Modificamos la referencia 'mensaje'\n        mensaje = \"Nuevo mensaje\";\n\n        // Mostramos el contenido despu\u00e9s de la modificaci\u00f3n\n        System.out.println(\"Mensaje despu\u00e9s de modificar: \" + mensaje);\n        System.out.println(\"Contenido de otra referencia: \" + otraReferencia);\n    }\n}\n</code></pre>"},{"location":"Bloque1_POO/02_codigos1/#calculadora-secuencial","title":"Calculadora secuencial","text":"<pre><code>import java.util.Scanner;\n\npublic class CalculadoraSecuencial {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        // Solicitar el primer n\u00famero\n        System.out.println(\"Ingrese el primer n\u00famero:\");\n        double num1 = scanner.nextDouble();\n\n        // Solicitar el segundo n\u00famero\n        System.out.println(\"Ingrese el segundo n\u00famero:\");\n        double num2 = scanner.nextDouble();\n\n        // Solicitar la operaci\u00f3n a realizar\n        System.out.println(\"Ingrese la operaci\u00f3n (+, -, *, /):\");\n        char operacion = scanner.next().charAt(0);\n\n        // Variable para almacenar el resultado\n        double resultado = 0;\n\n        // Realizar la operaci\u00f3n\n        switch (operacion) {\n            case '+':\n                resultado = num1 + num2;\n                break;\n            case '-':\n                resultado = num1 - num2;\n                break;\n            case '*':\n                resultado = num1 * num2;\n                break;\n            case '/':\n                if (num2 != 0) {\n                    resultado = num1 / num2;\n                } else {\n                    System.out.println(\"Error: Divisi\u00f3n por cero no permitida.\");\n                    return;\n                }\n                break;\n            default:\n                System.out.println(\"Operaci\u00f3n no v\u00e1lida.\");\n                return;\n        }\n\n        // Mostrar el resultado\n        System.out.println(\"El resultado es: \" + resultado);\n    }\n}\n</code></pre>"},{"location":"Bloque1_POO/02_codigos1/#calculadora-orientada-a-objetos","title":"Calculadora orientada a objetos","text":"<pre><code>import java.util.Scanner;\n\n// Clase Calculadora con los m\u00e9todos para cada operaci\u00f3n\nclass Calculadora {\n    // M\u00e9todo para sumar\n    public double sumar(double a, double b) {\n        return a + b;\n    }\n\n    // M\u00e9todo para restar\n    public double restar(double a, double b) {\n        return a - b;\n    }\n\n    // M\u00e9todo para multiplicar\n    public double multiplicar(double a, double b) {\n        return a * b;\n    }\n\n    // M\u00e9todo para dividir\n    public double dividir(double a, double b) {\n        if (b == 0) {\n            System.out.println(\"Error: Divisi\u00f3n por cero no permitida.\");\n            return 0; // O lanzar una excepci\u00f3n dependiendo del caso\n        }\n        return a / b;\n    }\n}\n\npublic class CalculadoraOrientadaObjetos {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        Calculadora calculadora = new Calculadora();\n\n        // Solicitar el primer n\u00famero\n        System.out.println(\"Ingrese el primer n\u00famero:\");\n        double num1 = scanner.nextDouble();\n\n        // Solicitar el segundo n\u00famero\n        System.out.println(\"Ingrese el segundo n\u00famero:\");\n        double num2 = scanner.nextDouble();\n\n        // Solicitar la operaci\u00f3n a realizar\n        System.out.println(\"Ingrese la operaci\u00f3n (+, -, *, /):\");\n        char operacion = scanner.next().charAt(0);\n\n        // Variable para almacenar el resultado\n        double resultado = 0;\n\n        // Realizar la operaci\u00f3n mediante los m\u00e9todos de la clase Calculadora\n        switch (operacion) {\n            case '+':\n                resultado = calculadora.sumar(num1, num2);\n                break;\n            case '-':\n                resultado = calculadora.restar(num1, num2);\n                break;\n            case '*':\n                resultado = calculadora.multiplicar(num1, num2);\n                break;\n            case '/':\n                resultado = calculadora.dividir(num1, num2);\n                break;\n            default:\n                System.out.println(\"Operaci\u00f3n no v\u00e1lida.\");\n                return;\n        }\n\n        // Mostrar el resultado\n        System.out.println(\"El resultado es: \" + resultado);\n    }\n}\n\n</code></pre> \ud83d\udca1 Detalles <p>La clase Calculadora encapsula toda la l\u00f3gica de las operaciones matem\u00e1ticas. Esto significa que la funcionalidad est\u00e1 agrupada en un \u00fanico lugar y separada de otras partes del programa (como la entrada y salida de datos en el main). </p> <p>Ventaja Si un m\u00f3dulo (la clase Calculadora) tiene un fallo o necesita ser mejorado, es f\u00e1cil modificarlo sin afectar a otras partes del c\u00f3digo. Esto facilita la localizaci\u00f3n de errores y la evoluci\u00f3n del software.</p>"},{"location":"Bloque1_POO/02_codigos1/#calculadora-orientada-a-objetos-potencia","title":"Calculadora orientada a objetos - potencia","text":"<pre><code>// Aprovechamos la modularidad incluyendo el m\u00e9todo potencia en la clase calculadora\n// de esta forma se pueden agregar nuevas funcionalidades sin alterar significativamente\n// la estructura del programa.\n\nimport java.util.Scanner;\n\n// Clase Calculadora con los m\u00e9todos para cada operaci\u00f3n\nclass Calculadora {\n    // M\u00e9todo para sumar\n    public double sumar(double a, double b) {\n        return a + b;\n    }\n\n    // M\u00e9todo para restar\n    public double restar(double a, double b) {\n        return a - b;\n    }\n\n    // M\u00e9todo para multiplicar\n    public double multiplicar(double a, double b) {\n        return a * b;\n    }\n\n    // M\u00e9todo para dividir\n    public double dividir(double a, double b) {\n        if (b == 0) {\n            System.out.println(\"Error: Divisi\u00f3n por cero no permitida.\");\n            return 0; // O lanzar una excepci\u00f3n dependiendo del caso\n        }\n        return a / b;\n    }\n\n    // Nuevo m\u00e9todo para calcular la potencia\n    public double potencia(double base, double exponente) {\n        return Math.pow(base, exponente);\n    }\n}\n\npublic class CalculadoraOrientadaObjetosPotencia {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        Calculadora calculadora = new Calculadora();\n\n        // Solicitar el primer n\u00famero\n        System.out.println(\"Ingrese el primer n\u00famero:\");\n        double num1 = scanner.nextDouble();\n\n        // Solicitar el segundo n\u00famero\n        System.out.println(\"Ingrese el segundo n\u00famero:\");\n        double num2 = scanner.nextDouble();\n\n        // Solicitar la operaci\u00f3n a realizar\n        System.out.println(\"Ingrese la operaci\u00f3n (+, -, *, /, ^):\");\n        char operacion = scanner.next().charAt(0);\n\n        // Variable para almacenar el resultado\n        double resultado = 0;\n\n        // Realizar la operaci\u00f3n mediante los m\u00e9todos de la clase Calculadora\n        switch (operacion) {\n            case '+':\n                resultado = calculadora.sumar(num1, num2);\n                break;\n            case '-':\n                resultado = calculadora.restar(num1, num2);\n                break;\n            case '*':\n                resultado = calculadora.multiplicar(num1, num2);\n                break;\n            case '/':\n                resultado = calculadora.dividir(num1, num2);\n                break;\n            case '^':  // Nueva operaci\u00f3n para calcular la potencia\n                resultado = calculadora.potencia(num1, num2);\n                break;\n            default:\n                System.out.println(\"Operaci\u00f3n no v\u00e1lida.\");\n                return;\n        }\n\n        // Mostrar el resultado\n        System.out.println(\"El resultado es: \" + resultado);\n    }\n}\n\n</code></pre> \ud83d\udca1 Detalles <p>La clase Calculadora puede ser utilizada en otros programas. Si en al\u00fan otro sistema es necesario realizar operaciones m\u00e1tem\u00e1ticas, se podr\u00eda integrar f\u00e1cilmente la clase sin necesidad de reescribir la l\u00f3gica. </p> <p>Ventajas: </p> <p>- Reutilizaci\u00f3n. Evita la duplicaci\u00f3n de c\u00f3digo, lo que mejora la eficiencia y reduce la posibilidad de errores.</p> <p>- Mantenimiento. Si el c\u00f3digo crece o cambia, se puede realizar sin modificar el flujo principal de la aplicaci\u00f3n. Adem\u00e1s, cualquier correcci\u00f3n que se deba hacer se puede realizar directamente en la clase Calculadora sin tocar otras partes del c\u00f3digo. El c\u00f3digo estar\u00e1 mejor organizado.</p> <p>- Flexibilidad. Se puede extender la clase Calculadora sin modificarla directamente, utilizando herencia o composici\u00f3n. Se podr\u00eda crear una nueva clase, como CalculadoraAvanzada, que extienda la funcionalidad de la calculadora b\u00e1sica, y siga reutilizando el c\u00f3digo existente.</p> <p>- Encapsulamiento. La l\u00f3gica de cada operaci\u00f3n (suma, resta, multiplicaci\u00f3n y divisi\u00f3n) est\u00e1 contenida dentro de m\u00e9todos privados a la clase Calculadora. Esto significa que el main no necesita saber c\u00f3mo se implementa cada operaci\u00f3n; solo llama a los m\u00e9todos correspondientes. Al ocultar los detalles internos, el c\u00f3digo que interact\u00faa con la clase Calculadora (como el c\u00f3digo del main) es m\u00e1s simple y menos propenso a errores. Adem\u00e1s, si cambia la implementaci\u00f3n interna (por ejemplo, optimizando el c\u00e1lculo de la multiplicaci\u00f3n), el resto del programa no se ve afectado.</p> <p>- Escalabilidad. La capacidad para adaptarse al crecimiento, tanto en tama\u00f1o como en complejidad. : La estructura orientada a objetos es naturalmente m\u00e1s escalable. A medida que el programa crezca (por ejemplo, a\u00f1adiendo nuevas funciones o integraciones), se pueden mantener las operaciones matem\u00e1ticas en la clase Calculadora o derivarlas a subclases especializadas sin tener que reestructurar el flujo general del programa.</p>"},{"location":"Bloque1_POO/02_codigos1/#calculadora-orientada-a-objetos-potencia-interfaz","title":"Calculadora orientada a objetos - potencia - interfaz","text":"<pre><code>import java.util.Scanner;\n\n// Interfaz Operacion que define un m\u00e9todo para ejecutar cualquier operaci\u00f3n\ninterface Operacion {\n    double ejecutar(double a, double b);\n}\n\n// Clase para sumar\nclass Suma implements Operacion {\n    @Override\n    public double ejecutar(double a, double b) {\n        return a + b;\n    }\n}\n\n// Clase para restar\nclass Resta implements Operacion {\n    @Override\n    public double ejecutar(double a, double b) {\n        return a - b;\n    }\n}\n\n// Clase para multiplicar\nclass Multiplicacion implements Operacion {\n    @Override\n    public double ejecutar(double a, double b) {\n        return a * b;\n    }\n}\n\n// Clase para dividir\nclass Division implements Operacion {\n    @Override\n    public double ejecutar(double a, double b) {\n        if (b == 0) {\n            System.out.println(\"Error: Divisi\u00f3n por cero no permitida.\");\n            return 0;\n        }\n        return a / b;\n    }\n}\n\n// Clase para potencia\nclass Potencia implements Operacion {\n    @Override\n    public double ejecutar(double base, double exponente) {\n        return Math.pow(base, exponente);\n    }\n}\n\n// Clase Calculadora que usa la interfaz Operacion\nclass Calculadora {\n    public double operar(Operacion operacion, double a, double b) {\n        return operacion.ejecutar(a, b);\n    }\n}\n\npublic class CalculadoraOrientadaObjetosPotenciaInterfaz {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        Calculadora calculadora = new Calculadora();\n\n        // Solicitar el primer n\u00famero\n        System.out.println(\"Ingrese el primer n\u00famero:\");\n        double num1 = scanner.nextDouble();\n\n        // Solicitar el segundo n\u00famero\n        System.out.println(\"Ingrese el segundo n\u00famero:\");\n        double num2 = scanner.nextDouble();\n\n        // Solicitar la operaci\u00f3n a realizar\n        System.out.println(\"Ingrese la operaci\u00f3n (+, -, *, /, ^):\");\n        char operacion = scanner.next().charAt(0);\n\n        // Variable para almacenar el resultado\n        double resultado = 0;\n\n        // Definir la operaci\u00f3n basada en la entrada\n        Operacion op = null;\n        switch (operacion) {\n            case '+':\n                op = new Suma();\n                break;\n            case '-':\n                op = new Resta();\n                break;\n            case '*':\n                op = new Multiplicacion();\n                break;\n            case '/':\n                op = new Division();\n                break;\n            case '^':\n                op = new Potencia();\n                break;\n            default:\n                System.out.println(\"Operaci\u00f3n no v\u00e1lida.\");\n                return;\n        }\n\n        // Realizar la operaci\u00f3n mediante la interfaz Operacion\n        if (op != null) {\n            resultado = calculadora.operar(op, num1, num2);\n        }\n\n        // Mostrar el resultado\n        System.out.println(\"El resultado es: \" + resultado);\n    }\n}\n</code></pre>"},{"location":"Bloque1_POO/02_codigos1/#diagrama-de-modulos","title":"Diagrama de m\u00f3dulos","text":""},{"location":"Bloque1_POO/02_codigos1/#relacion-real","title":"Relaci\u00f3n real","text":"<ul> <li>La clase Calculadora es una clase independiente que contiene los m\u00e9todos para realizar las operaciones b\u00e1sicas (suma, resta, multiplicaci\u00f3n y divisi\u00f3n).  </li> <li>La clase CalculadoraOrientadaObjetos es simplemente la clase principal donde se solicita la entrada del usuario y se utiliza un objeto de la clase Calculadora para realizar las operaciones.  </li> </ul>"},{"location":"Bloque1_POO/02_codigos1/#interaccion","title":"Interacci\u00f3n","text":"<p>La clase CalculadoraOrientadaObjetos crea una instancia de Calculadora y llama a sus m\u00e9todos. Es un ejemplo de composici\u00f3n (usar un objeto dentro de otro) y no de herencia.  </p>"},{"location":"Bloque1_POO/02_codigos1/#diferencias-clave","title":"Diferencias clave","text":"<ul> <li>Herencia: Una clase hija hereda los m\u00e9todos y propiedades de la clase padre, y puede sobreescribir o extender la funcionalidad de la clase padre.  </li> <li>Composici\u00f3n: Una clase contiene una instancia de otra clase y utiliza sus m\u00e9todos, pero no hereda de ella.  </li> </ul> <p>En este caso, la clase principal (CalculadoraOrientadaObjetos) utiliza la clase Calculadora, pero no es una subclase de ella.  </p> \ud83d\udca1 extends <p>Solo puedes extender de UNA sola clase (Java no permite herencia m\u00faltiple de clases).</p> <p>Heredas atributos y m\u00e9todos de la superclase.</p> <p>Puedes sobrescribir (override) m\u00e9todos para dar un comportamiento espec\u00edfico.</p> <p>Puedes a\u00f1adir nuevos atributos o m\u00e9todos.</p> <p>extends significa: soy un tipo m\u00e1s espec\u00edfico de esa clase.</p> \ud83d\udca1 implements <p>Una interfaz define un contrato (qu\u00e9 m\u00e9todos debe tener la clase), pero no la implementaci\u00f3n.</p> <p>Una clase puede implementar varias interfaces \u2192 es la forma de tener herencia m\u00faltiple en Java.</p> <p>Obliga a la clase a implementar todos los m\u00e9todos declarados en la interfaz (salvo que la clase sea abstracta).</p> <p>Puedes a\u00f1adir nuevos atributos o m\u00e9todos.</p> <p>implements significa: cumplo el contrato de esta interfaz.</p>"},{"location":"Bloque1_POO/02_codigos1/#conclusion","title":"Conclusi\u00f3n","text":"<p>Esto significa que la relaci\u00f3n entre ambas clases es de uso o colaboraci\u00f3n, y no de herencia.  </p>"},{"location":"Bloque1_POO/02_codigos2/","title":"Modularidad, Herencia y Reusabilidad","text":""},{"location":"Bloque1_POO/02_codigos2/#definiciones-y-ejemplos-ilustrativos","title":"Definiciones y ejemplos ilustrativos","text":""},{"location":"Bloque1_POO/02_codigos2/#metodos-constructores-accesores-transformadores-y-productores","title":"M\u00e9todos: constructores, accesores, transformadores y productores","text":"<pre><code>public class Persona {\n    // Atributos privados de la clase\n    private String nombre;\n    private int edad;\n    private double altura;\n\n    // *** Constructor: Se utiliza para inicializar los atributos de la clase cuando se crea un objeto\n    public Persona(String nombre, int edad, double altura) {\n        this.nombre = nombre;\n        this.edad = edad;\n        this.altura = altura;\n    }\n\n    // *** M\u00e9todo Accesor (getter): Permite acceder al valor del atributo 'nombre'\n    public String getNombre() {\n        return nombre;\n    }\n\n    // *** M\u00e9todo Accesor (getter): Permite acceder al valor del atributo 'edad'\n    public int getEdad() {\n        return edad;\n    }\n\n    // *** M\u00e9todo Accesor (getter): Permite acceder al valor del atributo 'altura'\n    public double getAltura() {\n        return altura;\n    }\n\n    // *** M\u00e9todo Transformador (setter): Permite modificar el valor del atributo 'nombre'\n    public void setNombre(String nombre) {\n        this.nombre = nombre;\n    }\n\n    // *** M\u00e9todo Transformador (setter): Permite modificar el valor del atributo 'edad'\n    public void setEdad(int edad) {\n        this.edad = edad;\n    }\n\n    // *** M\u00e9todo Transformador (setter): Permite modificar el valor del atributo 'altura'\n    public void setAltura(double altura) {\n        this.altura = altura;\n    }\n\n    // *** M\u00e9todo Productor: Crea y devuelve una cadena con la informaci\u00f3n de la persona\n    public String informacionCompleta() {\n        return \"Nombre: \" + nombre + \", Edad: \" + edad + \" a\u00f1os, Altura: \" + altura + \" m\";\n    }\n\n    // *** M\u00e9todo Productor: Calcula el a\u00f1o de nacimiento de la persona basado en su edad\n    public int calcularAnioNacimiento() {\n        int anioActual = java.util.Calendar.getInstance().get(java.util.Calendar.YEAR);\n        return anioActual - edad;\n    }\n\n    // M\u00e9todo principal para probar la clase Persona\n    public static void main(String[] args) {\n        // Creaci\u00f3n de un objeto de la clase Persona usando el constructor\n        Persona persona = new Persona(\"Juan\", 25, 1.75);\n\n        // Uso de los m\u00e9todos accesores\n        System.out.println(\"Nombre: \" + persona.getNombre());\n        System.out.println(\"Edad: \" + persona.getEdad());\n        System.out.println(\"Altura: \" + persona.getAltura());\n\n        // Uso de los m\u00e9todos transformadores\n        persona.setNombre(\"Carlos\");\n        persona.setEdad(30);\n        persona.setAltura(1.80);\n\n        // Mostrar la informaci\u00f3n completa usando el m\u00e9todo productor\n        System.out.println(\"Informaci\u00f3n actualizada: \" + persona.informacionCompleta());\n\n        // Uso de otro m\u00e9todo productor\n        System.out.println(\"A\u00f1o de nacimiento: \" + persona.calcularAnioNacimiento());\n    }\n}\n</code></pre> \ud83d\udca1 Caracter\u00edsticas <p>Los atributos (nombre, edad, altura) son privados (-).</p> <p>Todos los m\u00e9todos son p\u00fablicos (+).</p> <p>Esto es un caso cl\u00e1sico de encapsulaci\u00f3n fuerte:</p> <p>Los datos se ocultan (private).</p> <p>Se accede a ellos solo a trav\u00e9s de getters y setters.</p> <p>El usuario de la clase no puede manipular directamente los atributos.</p>"},{"location":"Bloque1_POO/02_codigos2/#metodos-constructores-accesores-transformadores-y-productores_1","title":"M\u00e9todos: constructores, accesores, transformadores y productores","text":"<pre><code>public class PersonaNiveles {\n    // Atributos de la clase con diferentes modificadores de acceso\n    private String nombre;   // Solo accesible desde dentro de la clase Persona\n    protected int edad;      // Accesible desde la clase Persona y sus subclases (en el mismo paquete o diferentes paquetes)\n    public double altura;    // Accesible desde cualquier clase\n\n    // *** Constructor p\u00fablico: Se utiliza para inicializar los atributos de la clase cuando se crea un objeto\n    public PersonaNiveles(String nombre, int edad, double altura) {\n        this.nombre = nombre;\n        this.edad = edad;\n        this.altura = altura;\n    }\n\n    // *** M\u00e9todo Accesor (getter) p\u00fablico: Permite acceder al valor del atributo 'nombre'\n    public String getNombre() {\n        return nombre;\n    }\n\n    // *** M\u00e9todo Accesor (getter) protegido: Permite acceder al valor del atributo 'edad'\n    protected int getEdad() {\n        return edad;\n    }\n\n    // *** M\u00e9todo Accesor (getter) p\u00fablico: Permite acceder al valor del atributo 'altura'\n    public double getAltura() {\n        return altura;\n    }\n\n    // *** M\u00e9todo Transformador (setter) p\u00fablico: Permite modificar el valor del atributo 'nombre'\n    public void setNombre(String nombre) {\n        this.nombre = nombre;\n    }\n\n    // *** M\u00e9todo Transformador (setter) protegido: Permite modificar el valor del atributo 'edad'\n    protected void setEdad(int edad) {\n        this.edad = edad;\n    }\n\n    // *** M\u00e9todo Transformador (setter) p\u00fablico: Permite modificar el valor del atributo 'altura'\n    public void setAltura(double altura) {\n        this.altura = altura;\n    }\n\n    // *** M\u00e9todo Productor p\u00fablico: Crea y devuelve una cadena con la informaci\u00f3n de la persona\n    public String informacionCompleta() {\n        return \"Nombre: \" + nombre + \", Edad: \" + edad + \" a\u00f1os, Altura: \" + altura + \" m\";\n    }\n\n    // *** M\u00e9todo Productor protegido: Calcula el a\u00f1o de nacimiento de la persona basado en su edad\n    protected int calcularAnioNacimiento() {\n        int anioActual = java.util.Calendar.getInstance().get(java.util.Calendar.YEAR);\n        return anioActual - edad;\n    }\n\n    // M\u00e9todo principal para probar la clase PersonaNiveles\n    public static void main(String[] args) {\n        // Creaci\u00f3n de un objeto de la clase PersonaNiveles usando el constructor\n        PersonaNiveles persona = new PersonaNiveles(\"Juan\", 25, 1.75);\n\n        // Uso de los m\u00e9todos accesores\n        System.out.println(\"Nombre: \" + persona.getNombre());\n        System.out.println(\"Edad: \" + persona.getEdad());\n        System.out.println(\"Altura: \" + persona.getAltura());\n\n        // Uso de los m\u00e9todos transformadores\n        persona.setNombre(\"Carlos\");\n        persona.setEdad(30);\n        persona.setAltura(1.80);\n\n        // Mostrar la informaci\u00f3n completa usando el m\u00e9todo productor\n        // Genera una cadena completa con la informaci\u00f3n de la persona\n\n        System.out.println(\"Informaci\u00f3n actualizada: \" + persona.informacionCompleta());\n\n        // Uso de otro m\u00e9todo productor\n        // Calcula y devuelve el a\u00f1o de nacimiento basado en la edad\n        System.out.println(\"A\u00f1o de nacimiento: \" + persona.calcularAnioNacimiento());\n    }\n}\n\n// Nota:\n// Aunque el atributo nombre es private, su valor \n//se puede mostrar porque el m\u00e9todo getNombre() es public y \n//proporciona un medio autorizado y controlado para acceder a \n//ese valor desde fuera de la clase.\n//El uso de atributos private junto con m\u00e9todos public (getters \n//y setters) es un principio fundamental de encapsulaci\u00f3n en la \n//programaci\u00f3n orientada a objetos.\n</code></pre> \ud83d\udca1 Caracter\u00edsticas <p>nombre es privado (-) \u2192 solo accesible desde dentro de la clase.</p> <p>edad es protegido (#) \u2192 accesible desde la clase y las subclases..</p> <p>altura es p\u00fablico (+) \u2192 accesible desde cualquier parte del programa.</p> <p>Lo mismo ocurre con algunos m\u00e9todos:</p> <p>getEdad(), setEdad() y calcularAnioNacimiento() son protegidos.</p> <p>Los dem\u00e1s (getNombre(), getAltura(), etc.) son p\u00fablicos.</p>"},{"location":"Bloque1_POO/02_codigos2/#gestion-de-operaciones","title":"Gesti\u00f3n de operaciones","text":"<pre><code>import java.util.Scanner;\n\n// Clase Cilindro para gestionar las operaciones con el cilindro\nclass Cilindro {\n    private double altura;\n    private double radio;\n\n    // M\u00e9todo para inicializar los valores de altura y radio\n    public void inicializar(double altura, double radio) {\n        this.altura = altura;\n        this.radio = radio;\n    }\n\n    // M\u00e9todo para calcular el volumen del cilindro\n    public double calculaVolumen() {\n        return Math.PI * Math.pow(radio, 2) * altura;\n    }\n}\n\n// Clase principal UsaCilindro\npublic class UsaCilindro {\n    public static void main(String[] args) {\n        double alt, rad;\n\n        // Creaci\u00f3n del objeto Scanner para la entrada de datos\n        Scanner teclado = new Scanner(System.in);\n\n        // Solicitar la altura del cilindro\n        System.out.print(\"Introduce la altura: \");\n        alt = teclado.nextDouble();\n\n        // Solicitar el radio del cilindro\n        System.out.print(\"Introduce el radio: \");\n        rad = teclado.nextDouble();\n\n        // Crear un objeto de la clase Cilindro\n        Cilindro c = new Cilindro();\n        c.inicializar(alt, rad);\n\n        // Calcular y mostrar el volumen del cilindro\n        System.out.println(\"El volumen del cilindro es: \" + c.calculaVolumen());\n\n        // Cerrar el objeto Scanner\n        teclado.close();\n    }\n}\n</code></pre>"},{"location":"Bloque1_POO/02_codigos3.3/","title":"Modularidad, Herencia y Reusabilidad","text":""},{"location":"Bloque1_POO/02_codigos3.3/#definiciones-y-ejemplos-ilustrativos","title":"Definiciones y ejemplos ilustrativos","text":""},{"location":"Bloque1_POO/02_codigos3.3/#sobrecarga-de-metodos","title":"Sobrecarga de m\u00e9todos","text":"<pre><code>//Sin sobrecarga\nimport java.util.Scanner;\n\npublic class SinSobrecarga {\n    // M\u00e9todo para mostrar informaci\u00f3n con solo el nombre\n    public void mostrarDatosNombre(String nombre) {\n        System.out.println(\"Nombre: \" + nombre);\n    }\n\n    // M\u00e9todo para mostrar informaci\u00f3n con nombre y edad\n    public void mostrarDatosNombreYEdad(String nombre, int edad) {\n        System.out.println(\"Nombre: \" + nombre + \", Edad: \" + edad);\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        SinSobrecarga ejemplo = new SinSobrecarga();\n\n        System.out.print(\"Introduce tu nombre: \");\n        String nombre = scanner.nextLine();\n\n        System.out.print(\"Introduce tu edad (o deja en blanco si no quieres ingresar la edad): \");\n        String edadInput = scanner.nextLine();\n\n        if (!edadInput.isEmpty()) {\n            int edad = Integer.parseInt(edadInput);\n            ejemplo.mostrarDatosNombreYEdad(nombre, edad);\n        } else {\n            ejemplo.mostrarDatosNombre(nombre);\n        }\n    }\n}\n</code></pre> <pre><code>//Con sobrecarga\nimport java.util.Scanner;\n\npublic class ConSobrecarga {\n    // M\u00e9todo sobrecargado para mostrar solo el nombre\n    public void mostrarDatos(String nombre) {\n        System.out.println(\"Nombre: \" + nombre);\n    }\n\n    // M\u00e9todo sobrecargado para mostrar el nombre y la edad\n    public void mostrarDatos(String nombre, int edad) {\n        System.out.println(\"Nombre: \" + nombre + \", Edad: \" + edad);\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        ConSobrecarga ejemplo = new ConSobrecarga();\n\n        System.out.print(\"Introduce tu nombre: \");\n        String nombre = scanner.nextLine();\n\n        System.out.print(\"Introduce tu edad (o deja en blanco si no quieres ingresar la edad): \");\n        String edadInput = scanner.nextLine();\n\n        if (!edadInput.isEmpty()) {\n            int edad = Integer.parseInt(edadInput);\n            ejemplo.mostrarDatos(nombre, edad); // Llama al m\u00e9todo con dos par\u00e1metros\n        } else {\n            ejemplo.mostrarDatos(nombre); // Llama al m\u00e9todo con un par\u00e1metro\n        }\n    }\n}\n\n</code></pre> <pre><code>//Sin sobrecarga\npublic class CalculoAreaSinSobrecarga {\n\n    // M\u00e9todo para calcular el \u00e1rea de un tri\u00e1ngulo\n    public double calcularAreaTriangulo(double base, double altura) {\n        return (base * altura) / 2;\n    }\n\n    // M\u00e9todo para calcular el \u00e1rea de un rect\u00e1ngulo\n    public double calcularAreaRectangulo(double longitud, double ancho) {\n        return longitud * ancho;\n    }\n\n    // M\u00e9todo para calcular el \u00e1rea de un \u00f3valo\n    public double calcularAreaOvalo(double ejeMayor, double ejeMenor) {\n        return Math.PI * (ejeMayor / 2) * (ejeMenor / 2);\n    }\n\n    // M\u00e9todo para calcular el \u00e1rea de un pent\u00e1gono regular\n    public double calcularAreaPentagono(double lado, double apotema) {\n        return (5 * lado * apotema) / 2;\n    }\n\n    public static void main(String[] args) {\n        CalculoAreaSinSobrecarga calculo = new CalculoAreaSinSobrecarga();\n\n        // Calcular el \u00e1rea de un tri\u00e1ngulo\n        double areaTriangulo = calculo.calcularAreaTriangulo(5, 10);\n        System.out.println(\"\u00c1rea del tri\u00e1ngulo: \" + areaTriangulo);\n\n        // Calcular el \u00e1rea de un rect\u00e1ngulo\n        double areaRectangulo = calculo.calcularAreaRectangulo(8, 4);\n        System.out.println(\"\u00c1rea del rect\u00e1ngulo: \" + areaRectangulo);\n\n        // Calcular el \u00e1rea de un \u00f3valo\n        double areaOvalo = calculo.calcularAreaOvalo(10, 6);\n        System.out.println(\"\u00c1rea del \u00f3valo: \" + areaOvalo);\n\n        // Calcular el \u00e1rea de un pent\u00e1gono\n        double areaPentagono = calculo.calcularAreaPentagono(6, 4);\n        System.out.println(\"\u00c1rea del pent\u00e1gono: \" + areaPentagono);\n    }\n}\n\n</code></pre> <pre><code>//Con sobrecarga\npublic class CalculoAreaSobrecarga {\n\n    //  javac -encoding UTF-8 CalculoAreaSobrecarga.java\n\n    // M\u00e9todo para calcular el \u00e1rea de un tri\u00e1ngulo\n    public double calcularArea(double basetriangulo, double altura) {\n        return (basetriangulo * altura) / 2;\n    }\n\n    // M\u00e9todo para calcular el \u00e1rea de un rect\u00e1ngulo\n    public double calcularArea(double longitud, double ancho) {\n           return longitud * ancho;\n        }\n\n    // M\u00e9todo para calcular el \u00e1rea de un \u00f3valo\n    public double calcularArea(double ejeMayor, double ejeMenor, boolean esOvalo) {\n        if (esOvalo) {\n            return Math.PI * (ejeMayor / 2) * (ejeMenor / 2);\n        }\n        return 0;\n    }\n\n    // M\u00e9todo para calcular el \u00e1rea de un pent\u00e1gono regular\n    public double calcularArea(double lado, int numeroLados, double apotema) {\n        if (numeroLados == 5) {\n            return (5 * lado * apotema) / 2;\n        }\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        CalculoAreaSobrecarga calculo = new CalculoAreaSobrecarga();\n\n        // Calcular el \u00e1rea de un tri\u00e1ngulo\n        double areaTriangulo = calculo.calcularArea(5, 10);\n        System.out.println(\"Area del tri\u00e1ngulo: \" + areaTriangulo);\n\n        // Calcular el \u00e1rea de un rect\u00e1ngulo\n        double areaRectangulo = calculo.calcularArea(8, 4);\n        System.out.println(\"Area del rect\u00e1ngulo: \" + areaRectangulo);\n\n        // Calcular el \u00e1rea de un \u00f3valo\n        double areaOvalo = calculo.calcularArea(10, 6, true);\n        System.out.println(\"Area del \u00f3valo: \" + areaOvalo);\n\n        // Calcular el \u00e1rea de un pent\u00e1gono\n        double areaPentagono = calculo.calcularArea(6, 5, 4);\n        System.out.println(\"Area del pent\u00e1gono: \" + areaPentagono);\n    }\n}\n\n</code></pre> <pre><code>public class SistemaDeCerraduras {\n\n    // M\u00e9todo para abrir una cerradura con una llave est\u00e1ndar\n    public void abrir(String llave) {\n        if (llave.equals(\"llaveEstandar\")) {\n            System.out.println(\"La cerradura se ha abierto con la llave est\u00e1ndar.\");\n        } else {\n            System.out.println(\"Llave incorrecta. No se puede abrir la cerradura.\");\n        }\n    }\n\n    // M\u00e9todo sobrecargado para abrir una cerradura con una tarjeta magn\u00e9tica\n    public void abrir(int codigoTarjeta) {\n        if (codigoTarjeta == 1234) {\n            System.out.println(\"La cerradura se ha abierto con la tarjeta magn\u00e9tica.\");\n        } else {\n            System.out.println(\"C\u00f3digo de tarjeta incorrecto. No se puede abrir la cerradura.\");\n        }\n    }\n\n    // M\u00e9todo sobrecargado para abrir una cerradura con la llave maestra\n    public void abrir(boolean esLlaveMaestra) {\n        if (esLlaveMaestra) {\n            System.out.println(\"La cerradura se ha abierto con la llave maestra.\");\n        } else {\n            System.out.println(\"No tienes acceso con esta llave.\");\n        }\n    }\n\n    public static void main(String[] args) {\n        SistemaDeCerraduras cerradura = new SistemaDeCerraduras();\n\n        // Abrir la cerradura con una llave est\u00e1ndar\n        cerradura.abrir(\"llaveEstandar\"); // La cerradura se ha abierto con la llave est\u00e1ndar.\n\n        // Abrir la cerradura con una tarjeta magn\u00e9tica\n        cerradura.abrir(1234); // La cerradura se ha abierto con la tarjeta magn\u00e9tica.\n\n        // Abrir la cerradura con la llave maestra\n        cerradura.abrir(true); // La cerradura se ha abierto con la llave maestra.\n    }\n}\n\n</code></pre> <pre><code>import java.util.Scanner;\n\npublic class SistemaDeCerradurasElije {\n\n    // M\u00e9todo para abrir una cerradura con una llave est\u00e1ndar\n    public void abrir(String llave) {\n        if (llave.equals(\"llaveEstandar\")) {\n            System.out.println(\"La cerradura se ha abierto con la llave est\u00e1ndar.\");\n        } else {\n            System.out.println(\"Llave incorrecta. No se puede abrir la cerradura.\");\n        }\n    }\n\n    // M\u00e9todo sobrecargado para abrir una cerradura con una tarjeta magn\u00e9tica\n    public void abrir(int codigoTarjeta) {\n        if (codigoTarjeta == 1234) {\n            System.out.println(\"La cerradura se ha abierto con la tarjeta magn\u00e9tica.\");\n        } else {\n            System.out.println(\"C\u00f3digo de tarjeta incorrecto. No se puede abrir la cerradura.\");\n        }\n    }\n\n    // M\u00e9todo sobrecargado para abrir una cerradura con la llave maestra\n    public void abrir(boolean esLlaveMaestra) {\n        if (esLlaveMaestra) {\n            System.out.println(\"La cerradura se ha abierto con la llave maestra.\");\n        } else {\n            System.out.println(\"No tienes acceso con esta llave.\");\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        SistemaDeCerradurasElije cerradura = new SistemaDeCerradurasElije();\n\n        // Pedir al usuario que seleccione el tipo de cerradura a abrir\n        System.out.println(\"Seleccione el tipo de cerradura que desea abrir:\");\n        System.out.println(\"1. Cerradura con llave est\u00e1ndar\");\n        System.out.println(\"2. Cerradura con tarjeta magn\u00e9tica\");\n        System.out.println(\"3. Cerradura con llave maestra\");\n\n        int opcion = scanner.nextInt();\n        scanner.nextLine(); // Limpiar el buffer\n\n        switch (opcion) {\n            case 1:\n                System.out.print(\"Ingrese la llave est\u00e1ndar: \");\n                String llave = scanner.nextLine();\n                cerradura.abrir(llave);\n                break;\n\n            case 2:\n                System.out.print(\"Ingrese el c\u00f3digo de la tarjeta magn\u00e9tica: \");\n                int codigoTarjeta = scanner.nextInt();\n                cerradura.abrir(codigoTarjeta);\n                break;\n\n            case 3:\n                System.out.print(\"\u00bfTiene la llave maestra? (true/false): \");\n                boolean esLlaveMaestra = scanner.nextBoolean();\n                cerradura.abrir(esLlaveMaestra);\n                break;\n\n            default:\n                System.out.println(\"Opci\u00f3n no v\u00e1lida. Por favor, seleccione una opci\u00f3n correcta.\");\n                break;\n        }\n\n        scanner.close();\n    }\n}\n\n</code></pre>"},{"location":"Bloque1_POO/02_codigos3.3/#this","title":"This","text":"<pre><code>// Clase principal Persona\npublic class Persona {\n    private String nombre;\n    private int edad;\n\n    // 1. Diferenciar entre variables de instancia y par\u00e1metros del m\u00e9todo o constructor\n    // Se usa this.nombre para diferenciar entre la variable de instancia nombre y el par\u00e1metro \n    //del constructor con el mismo nombre.\n\n    public Persona(String nombre) {\n        this.nombre = nombre; // 'this.nombre' se refiere a la variable de instancia\n    }\n\n    // Constructor adicional para el encadenamiento de constructores\n    public Persona(String nombre, int edad) {\n        this.nombre = nombre;\n        this.edad = edad;\n    }\n\n    // M\u00e9todo para mostrar los datos de la persona\n    public void mostrar() {\n        System.out.println(\"Nombre: \" + nombre + \", Edad: \" + edad);\n    }\n\n    // 2. Llamar a otros constructores de la misma clase (Constructor Chaining)\n    // Se usa this(\"Nombre por defecto\", 0) en el constructor Persona() para llamar \n    // al constructor que toma dos par\u00e1metros, evitando duplicar c\u00f3digo.\n\n    public Persona() {\n        this(\"Nombre por defecto\", 0); // Llama al constructor que toma dos par\u00e1metros\n    }\n\n    // 3. Pasar el objeto actual como argumento a otro m\u00e9todo o constructor\n    // El m\u00e9todo mostrarUtilidades() utiliza this para pasar la referencia \n    // del objeto actual al m\u00e9todo imprimir de la clase Utilidades.\n\n    public void mostrarUtilidades() {\n        Utilidades.imprimir(this); // Pasar el objeto actual al m\u00e9todo 'imprimir'\n    }\n\n    // 4. Devolver la referencia actual de un m\u00e9todo (Method Chaining)\n    // Los m\u00e9todos setNombre y setEdad devuelven this, lo que permite encadenar las \n    //llamadas de m\u00e9todos en una sola l\u00ednea (persona1.setNombre(\"Carlos\").setEdad(25);).\n\n    public Persona setNombre(String nombre) {\n        this.nombre = nombre;\n        return this; // Devuelve la referencia actual para encadenar\n    }\n\n    public Persona setEdad(int edad) {\n        this.edad = edad;\n        return this; // Devuelve la referencia actual para encadenar\n    }\n\n    // Getters para acceder a las variables privadas\n    public String getNombre() {\n        return nombre;\n    }\n\n    public int getEdad() {\n        return edad;\n    }\n\n    public static void main(String[] args) {\n        // 1. Diferenciar entre variables de instancia y par\u00e1metros\n        Persona persona1 = new Persona(\"Juan\");\n        persona1.mostrar(); // Output: Nombre: Juan, Edad: 0\n\n        // 2. Llamar a otros constructores de la misma clase (Constructor Chaining)\n        Persona persona2 = new Persona();\n        persona2.mostrar(); // Output: Nombre: Nombre por defecto, Edad: 0\n\n        // 3. Pasar el objeto actual como argumento a otro m\u00e9todo o constructor\n        persona1.mostrarUtilidades(); // Output: Utilidades - Nombre: Juan, Edad: 0\n\n        // 4. Devolver la referencia actual de un m\u00e9todo (Method Chaining)\n        persona1.setNombre(\"Carlos\").setEdad(25); // Encadenamiento de m\u00e9todos\n        persona1.mostrar(); // Output: Nombre: Carlos, Edad: 25\n    }\n}\n\n// Clase auxiliar para el ejemplo 3\nclass Utilidades {\n    public static void imprimir(Persona persona) {\n        // Utilizamos los getters para acceder a los atributos privados\n        System.out.println(\"Utilidades - Nombre: \" + persona.getNombre() + \", Edad: \" + persona.getEdad());\n    }\n}\n</code></pre> <pre><code>public class PersonaChain {\n    private String nombre;\n    private int edad;\n\n    // Constructor 1: Constructor sin par\u00e1metros\n    public PersonaChain() {\n        this(\"Nombre por defecto\", 0); // Llama al constructor con dos par\u00e1metros\n        System.out.println(\"Constructor sin par\u00e1metros llamado\");\n    }\n\n    // Constructor 2: Constructor con un par\u00e1metro\n    public PersonaChain(String nombre) {\n        this(nombre, 0); // Llama al constructor con dos par\u00e1metros\n        System.out.println(\"Constructor con un par\u00e1metro llamado\");\n    }\n\n    // Constructor 3: Constructor con dos par\u00e1metros\n    public PersonaChain(String nombre, int edad) {\n        this.nombre = nombre;\n        this.edad = edad;\n        System.out.println(\"Constructor con dos par\u00e1metros llamado\");\n    }\n\n    // M\u00e9todo para mostrar los detalles de la persona\n    public void mostrarDetalles() {\n        System.out.println(\"Nombre: \" + nombre + \", Edad: \" + edad);\n    }\n\n    public static void main(String[] args) {\n        // Crear un objeto usando el constructor sin par\u00e1metros\n        PersonaChain persona1 = new PersonaChain();\n        persona1.mostrarDetalles(); // Output: Nombre por defecto, Edad: 0\n\n        // Crear un objeto usando el constructor con un par\u00e1metro\n        PersonaChain persona2 = new PersonaChain(\"Juan\");\n        persona2.mostrarDetalles(); // Output: Nombre: Juan, Edad: 0\n\n        // Crear un objeto usando el constructor con dos par\u00e1metros\n        PersonaChain persona3 = new PersonaChain(\"Carlos\", 25);\n        persona3.mostrarDetalles(); // Output: Nombre: Carlos, Edad: 25\n    }\n}\n</code></pre>"},{"location":"Bloque1_POO/02_codigos3.3/#estado-de-los-objetos","title":"Estado de los objetos","text":"<pre><code>public class PersonaEstado {\n    private String nombre; // Atributo que define parte del estado\n    private int edad;      // Atributo que define parte del estado\n\n    // Constructor para inicializar el estado del objeto\n    public PersonaEstado(String nombre, int edad) {\n        this.nombre = nombre;\n        this.edad = edad;\n    }\n\n    // M\u00e9todo que modifica el estado del objeto\n    public void cumplirA\u00f1os() {\n        this.edad++; // Cambia el estado al incrementar la edad\n    }\n\n    // M\u00e9todo para mostrar el estado actual del objeto\n    public void mostrarEstado() {\n        System.out.println(\"Nombre: \" + nombre + \", Edad: \" + edad);\n    }\n\n    public static void main(String[] args) {\n        PersonaEstado persona = new PersonaEstado(\"Juan\", 25); // Estado inicial\n        persona.mostrarEstado(); // Output: Nombre: Juan, Edad: 25\n\n        persona.cumplirA\u00f1os(); // Cambia el estado\n        persona.mostrarEstado(); // Output: Nombre: Juan, Edad: 26\n    }\n}\n\n</code></pre> <pre><code>import java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\n\n// Clase que representa un Producto\nclass Producto {\n    private String nombre;\n    private double precio;\n    private int cantidad;\n\n    public Producto(String nombre, double precio, int cantidad) {\n        this.nombre = nombre;\n        this.precio = precio;\n        this.cantidad = cantidad;\n    }\n\n    public String getNombre() {\n        return nombre;\n    }\n\n    public double getPrecio() {\n        return precio;\n    }\n\n    public int getCantidad() {\n        return cantidad;\n    }\n\n    public double calcularTotal() {\n        return precio * cantidad;\n    }\n\n    @Override\n    public String toString() {\n        return nombre + \" - Cantidad: \" + cantidad + \", Precio Unitario: $\" + precio + \", Total: $\" + calcularTotal();\n    }\n}\n\n// Clase que representa un Cliente\nclass Cliente {\n    private String nombre;\n    private String email;\n\n    public Cliente(String nombre, String email) {\n        this.nombre = nombre;\n        this.email = email;\n    }\n\n    public String getNombre() {\n        return nombre;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    @Override\n    public String toString() {\n        return \"Cliente: \" + nombre + \" (Email: \" + email + \")\";\n    }\n}\n\n// Clase que representa un Pedido de Compra\nclass Pedido {\n    private Cliente cliente;\n    private List&lt;Producto&gt; productos;\n    private Date fechaPedido;\n    private String estado; // Ejemplos de estado: \"Pendiente\", \"Enviando\", \"Entregado\"\n\n    public Pedido(Cliente cliente) {\n        this.cliente = cliente;\n        this.productos = new ArrayList&lt;&gt;();\n        this.fechaPedido = new Date();\n        this.estado = \"Pendiente\";\n    }\n\n    // M\u00e9todo para agregar un producto al pedido\n    public void agregarProducto(Producto producto) {\n        productos.add(producto);\n    }\n\n    // M\u00e9todo para calcular el total del pedido\n    public double calcularTotalPedido() {\n        double total = 0;\n        for (Producto producto : productos) {\n            total += producto.calcularTotal();\n        }\n        return total;\n    }\n\n    // M\u00e9todo para mostrar el estado completo del pedido\n    public void mostrarEstado() {\n        System.out.println(\"---- Estado del Pedido ----\");\n        System.out.println(cliente); // Llama al m\u00e9todo toString() de Cliente\n        System.out.println(\"Fecha del Pedido: \" + fechaPedido);\n        System.out.println(\"Estado del Pedido: \" + estado);\n        System.out.println(\"Productos en el pedido:\");\n        for (Producto producto : productos) {\n            System.out.println(\"  \" + producto); // Llama al m\u00e9todo toString() de Producto\n        }\n        System.out.println(\"Total del Pedido: $\" + calcularTotalPedido());\n        System.out.println(\"----------------------------\");\n    }\n\n    // M\u00e9todo para actualizar el estado del pedido\n    public void actualizarEstado(String nuevoEstado) {\n        this.estado = nuevoEstado;\n    }\n}\n\n// Clase principal para probar el estado de un objeto complejo\npublic class SistemaPedidos {\n    public static void main(String[] args) {\n        // Crear un cliente\n        Cliente cliente = new Cliente(\"Juan P\u00e9rez\", \"juan.perez@example.com\");\n\n        // Crear un pedido para el cliente\n        Pedido pedido = new Pedido(cliente);\n\n        // Agregar productos al pedido\n        pedido.agregarProducto(new Producto(\"Laptop\", 1200.00, 1));\n        pedido.agregarProducto(new Producto(\"Mouse\", 25.50, 2));\n        pedido.agregarProducto(new Producto(\"Teclado\", 45.99, 1));\n\n        // Mostrar el estado completo del pedido\n        pedido.mostrarEstado();\n\n        // Actualizar el estado del pedido y mostrarlo de nuevo\n        pedido.actualizarEstado(\"Enviando\");\n        System.out.println(\"\\nEstado del pedido actualizado:\");\n        pedido.mostrarEstado();\n    }\n}\n\n</code></pre>"},{"location":"Bloque1_POO/02_codigos3.3/#inicializar-objetos-con-sin-constructores","title":"Inicializar objetos con-sin constructores","text":"<pre><code>// VehiculoSinConstructor.java\npublic class VehiculoSinConstructor {\n    // Atributos del veh\u00edculo\n    String marca;\n    String modelo;\n    int a\u00f1o;\n    double precio;\n\n    // M\u00e9todo para mostrar los detalles del veh\u00edculo\n    public void mostrarDetalles() {\n        System.out.println(\"Marca: \" + marca);\n        System.out.println(\"Modelo: \" + modelo);\n        System.out.println(\"A\u00f1o: \" + a\u00f1o);\n        System.out.println(\"Precio: $\" + precio);\n    }\n\n    public static void main(String[] args) {\n        // Creaci\u00f3n e inicializaci\u00f3n del objeto sin un constructor\n        VehiculoSinConstructor vehiculo = new VehiculoSinConstructor();\n\n        // Inicializaci\u00f3n manual de los atributos\n        vehiculo.marca = \"Toyota\";\n        vehiculo.modelo = \"Corolla\";\n        vehiculo.a\u00f1o = 2020;\n        vehiculo.precio = 18000;\n\n        // Mostrar los detalles del veh\u00edculo\n        vehiculo.mostrarDetalles();\n    }\n}\n</code></pre> <pre><code>// VehiculoConConstructor.java\npublic class VehiculoConConstructor {\n    // Atributos del veh\u00edculo\n    private String marca;\n    private String modelo;\n    private int a\u00f1o;\n    private double precio;\n\n    // Constructor personalizado para inicializar los atributos\n    public VehiculoConConstructor(String marca, String modelo, int a\u00f1o, double precio) {\n        this.marca = marca;\n        this.modelo = modelo;\n        this.a\u00f1o = a\u00f1o;\n        this.precio = precio;\n    }\n\n    // M\u00e9todo para mostrar los detalles del veh\u00edculo\n    public void mostrarDetalles() {\n        System.out.println(\"Marca: \" + marca);\n        System.out.println(\"Modelo: \" + modelo);\n        System.out.println(\"A\u00f1o: \" + a\u00f1o);\n        System.out.println(\"Precio: $\" + precio);\n    }\n\n    public static void main(String[] args) {\n        // Creaci\u00f3n e inicializaci\u00f3n del objeto utilizando el constructor personalizado\n        VehiculoConConstructor vehiculo = new VehiculoConConstructor(\"Honda\", \"Civic\", 2021, 25000);\n\n        // Mostrar los detalles del veh\u00edculo\n        vehiculo.mostrarDetalles();\n    }\n}\n</code></pre> <pre><code>// LibroSinConstructor.java\npublic class LibroSinConstructor {\n    // Atributos del libro\n    String titulo;\n    String autor;\n    int paginas;\n    double precio;\n\n    // M\u00e9todo para mostrar los detalles del libro\n    public void mostrarDetalles() {\n        System.out.println(\"T\u00edtulo: \" + titulo);\n        System.out.println(\"Autor: \" + autor);\n        System.out.println(\"P\u00e1ginas: \" + paginas);\n        System.out.println(\"Precio: $\" + precio);\n    }\n\n    public static void main(String[] args) {\n        // Creaci\u00f3n del objeto utilizando el constructor por defecto\n        LibroSinConstructor libro = new LibroSinConstructor();\n\n        // Inicializaci\u00f3n manual de los atributos\n        libro.titulo = \"Cien A\u00f1os de Soledad\";\n        libro.autor = \"Gabriel Garc\u00eda M\u00e1rquez\";\n        libro.paginas = 417;\n        libro.precio = 19.99;\n\n        // Mostrar los detalles del libro\n        libro.mostrarDetalles();\n    }\n}\n</code></pre> <pre><code>// LibroConConstructor.java\npublic class LibroConConstructor {\n    // Atributos del libro\n    private String titulo;\n    private String autor;\n    private int paginas;\n    private double precio;\n\n    // Constructor personalizado para inicializar los atributos\n    public LibroConConstructor(String titulo, String autor, int paginas, double precio) {\n        this.titulo = titulo;\n        this.autor = autor;\n        this.paginas = paginas;\n        this.precio = precio;\n    }\n\n    // M\u00e9todo para mostrar los detalles del libro\n    public void mostrarDetalles() {\n        System.out.println(\"T\u00edtulo: \" + titulo);\n        System.out.println(\"Autor: \" + autor);\n        System.out.println(\"P\u00e1ginas: \" + paginas);\n        System.out.println(\"Precio: $\" + precio);\n    }\n\n    public static void main(String[] args) {\n        // Creaci\u00f3n e inicializaci\u00f3n del objeto utilizando el constructor personalizado\n        LibroConConstructor libro = new LibroConConstructor(\"El Quijote\", \"Miguel de Cervantes\", 500, 25.99);\n\n        // Mostrar los detalles del libro\n        libro.mostrarDetalles();\n    }\n}\n</code></pre>"},{"location":"Bloque1_POO/02_codigos3/","title":"Modularidad, Herencia y Reusabilidad","text":""},{"location":"Bloque1_POO/02_codigos3/#definiciones-y-ejemplos-ilustrativos","title":"Definiciones y ejemplos ilustrativos","text":""},{"location":"Bloque1_POO/02_codigos3/#conceptos-fundamentales-de-la-programacion-orientada-a-objetos","title":"Conceptos fundamentales de la programaci\u00f3n orientada a objetos","text":"<p>Interfaz vs clase</p>"},{"location":"Bloque1_POO/02_codigos3/#modificadores-de-acceso","title":"Modificadores de acceso","text":"<p>En Java los modificadores de acceso determinan la visibilidad de clases, m\u00e9todos y atributos:</p> <ul> <li>public: accesible desde cualquier clase, sin importar el paquete.  </li> <li>protected: accesible desde el mismo paquete y tambi\u00e9n desde subclases, incluso si est\u00e1n en paquetes diferentes.  </li> <li>package-private (sin especificar modificador): accesible solo dentro del mismo paquete.  </li> <li>private: accesible \u00fanicamente dentro de la misma clase.  </li> </ul> <p>El uso adecuado de estos modificadores favorece la encapsulaci\u00f3n, permitiendo controlar qu\u00e9 partes de una clase se exponen y cu\u00e1les permanecen ocultas.</p>"},{"location":"Bloque1_POO/02_codigos3/#sobrecarga","title":"Sobrecarga","text":"<p>En Java, la sobrecarga de m\u00e9todos (method overloading) ocurre cuando dentro de una misma clase existen varios m\u00e9todos con el mismo nombre, pero que se diferencian en el n\u00famero o tipo de par\u00e1metros que reciben. Esto permite reutilizar el nombre del m\u00e9todo para realizar operaciones similares adaptadas a distintos contextos, mejorando la legibilidad y reduciendo la duplicaci\u00f3n de c\u00f3digo. La selecci\u00f3n de qu\u00e9 m\u00e9todo ejecutar no se hace en tiempo de ejecuci\u00f3n, sino en tiempo de compilaci\u00f3n, en funci\u00f3n de la lista de par\u00e1metros usada en la llamada. Gracias a la sobrecarga, es posible crear clases m\u00e1s flexibles y expresivas, como por ejemplo tener varios m\u00e9todos <code>calcularArea()</code> que acepten cuadrados, c\u00edrculos o tri\u00e1ngulos, sin necesidad de inventar nombres distintos para cada uno.</p> <p>En Java, la sobrecarga de m\u00e9todos sigue estas reglas principales:</p> <ul> <li>Los m\u00e9todos deben tener el mismo nombre, pero diferenciarse en el n\u00famero o tipo de par\u00e1metros.  </li> <li>La sobrecarga se decide en tiempo de compilaci\u00f3n (no en ejecuci\u00f3n).  </li> <li>El tipo de retorno puede ser distinto, pero no basta para diferenciar m\u00e9todos por s\u00ed solo.  </li> <li>Los modificadores de acceso (<code>public</code>, <code>private</code>, etc.) pueden variar entre m\u00e9todos sobrecargados.  </li> <li>Los par\u00e1metros pueden diferir en cantidad (<code>metodo(int)</code> vs <code>metodo(int, int)</code>) o en tipo (<code>metodo(int)</code> vs <code>metodo(double)</code>).  </li> <li>Se permite combinar tipos de par\u00e1metros para cubrir distintos escenarios de uso.  </li> <li>La sobrecarga hace que el c\u00f3digo sea m\u00e1s legible y reutilizable, evitando nombres diferentes para operaciones similares.  </li> </ul> <p>Ejemplo cl\u00e1sico: tener varios m\u00e9todos <code>calcularArea()</code> para distintas figuras (c\u00edrculo, cuadrado, tri\u00e1ngulo) en una misma clase.</p> <p></p> <p>Sobrecarga de m\u00e9todos</p>"},{"location":"Bloque1_POO/02_codigos3/#this","title":"This","text":"<p>En Java, la palabra clave <code>this</code> se utiliza para referirse al objeto actual dentro de una clase. Es \u00fatil para diferenciar atributos de variables locales con el mismo nombre o para invocar otros m\u00e9todos del propio objeto. Adem\u00e1s, puede emplearse en la t\u00e9cnica de constructor chaining, usando <code>this(...)</code> dentro de un constructor para llamar a otro constructor de la misma clase. Esto evita duplicar c\u00f3digo y centraliza la inicializaci\u00f3n de atributos. Por ejemplo, se puede tener un constructor principal con todos los par\u00e1metros y otros constructores m\u00e1s simples que deleguen en \u00e9l mediante <code>this(...)</code>, facilitando la creaci\u00f3n de objetos con diferentes niveles de detalle.</p> <p>En Java, la palabra clave <code>this</code> tiene varios usos importantes:</p>"},{"location":"Bloque1_POO/02_codigos3/#uso-de-this-en-java","title":"Uso de <code>this</code> en Java","text":"<p>En Java, la palabra clave <code>this</code> tiene varios usos importantes:</p> <ul> <li> <p>Referirse al objeto actual: permite acceder a los atributos y m\u00e9todos de la propia instancia. <code>java   this.nombre = nombre; // diferencia entre atributo y par\u00e1metro local</code></p> </li> <li> <p>Invocar otros m\u00e9todos de la misma clase: <code>java   this.calcularEdad();</code></p> </li> <li> <p>Pasar el objeto actual como argumento a otro m\u00e9todo o constructor: <code>java   otraClase.procesar(this);</code></p> </li> <li> <p>Constructor chaining (<code>this(...)</code>): dentro de un constructor, <code>this(...)</code> invoca a otro constructor de la misma clase. <code>java   public Persona(String nombre) {       this(nombre, 0); // llama al constructor con dos par\u00e1metros   }</code></p> </li> </ul> <p>Esto evita duplicaci\u00f3n de c\u00f3digo, centraliza la inicializaci\u00f3n y hace m\u00e1s flexible la creaci\u00f3n de objetos.</p> <p>This</p>"},{"location":"Bloque1_POO/02_codigos3/#estado-de-los-objetos","title":"Estado de los objetos","text":"<p>En programaci\u00f3n orientada a objetos, el estado de un objeto est\u00e1 definido por los valores que toman sus atributos en un momento dado. Dichos atributos describen las caracter\u00edsticas o propiedades del objeto y pueden cambiar a lo largo de la ejecuci\u00f3n del programa mediante m\u00e9todos que los modifican. As\u00ed, dos objetos de la misma clase pueden compartir el mismo comportamiento (m\u00e9todos) pero diferir en su estado si sus atributos almacenan valores distintos. Entender y gestionar el estado es esencial para modelar entidades del mundo real, ya que refleja su situaci\u00f3n actual dentro del sistema, como por ejemplo un pedido en curso o los datos personales de una persona.</p> <p>En Java (y en la programaci\u00f3n orientada a objetos en general), el estado de un objeto se entiende como los valores actuales de sus atributos. Algunas ideas clave:</p> <ul> <li>El estado se define por las propiedades (atributos) de un objeto en un momento concreto.  </li> <li> <p>Ejemplo: una <code>Persona</code> con <code>nombre=\"Ana\"</code> y <code>edad=25</code> tiene un estado distinto de otra <code>Persona</code> con <code>nombre=\"Ana\"</code> y <code>edad=30</code>.  </p> </li> <li> <p>El estado puede cambiar a lo largo de la ejecuci\u00f3n mediante m\u00e9todos que actualizan los atributos.  </p> </li> <li> <p>Ejemplo: al invocar <code>persona.cumplirAnios()</code>, el atributo <code>edad</code> aumenta y el estado se modifica.  </p> </li> <li> <p>Objetos de la misma clase pueden compartir el mismo comportamiento (m\u00e9todos) pero tener estados diferentes.  </p> </li> <li> <p>Ejemplo: dos instancias de <code>SistemaPedidos</code>, una con <code>estado=\"pendiente\"</code> y otra con <code>estado=\"enviado\"</code>.  </p> </li> <li> <p>Gestionar correctamente el estado permite reflejar el ciclo de vida de los objetos y modelar entidades del mundo real.  </p> </li> <li>Ejemplo: un pedido pasa por distintos estados (<code>pendiente</code>, <code>en preparaci\u00f3n</code>, <code>enviado</code>, <code>entregado</code>). </li> </ul> <p>Estado de los objetos</p>"},{"location":"Bloque1_POO/02_codigos3/#inicializar-objetos-consin-constructor","title":"Inicializar objetos con/sin constructor","text":"<p>En Java, la inicializaci\u00f3n de objetos puede hacerse tanto con como sin constructores definidos expl\u00edcitamente:</p> <ul> <li>Sin constructores definidos:   Si no se especifica ning\u00fan constructor en la clase, el compilador a\u00f1ade por defecto un constructor vac\u00edo (sin par\u00e1metros). Esto permite crear objetos, pero sus atributos deber\u00e1n asignarse despu\u00e9s de la creaci\u00f3n mediante setters o asignaciones directas.  </li> <li> <p>Ejemplo: <code>java     LibroSinConstructor libro = new LibroSinConstructor();     libro.titulo = \"Don Quijote\";     libro.autor = \"Cervantes\";</code></p> </li> <li> <p>Con constructores definidos:   Permiten inicializar los atributos de un objeto en el momento de su creaci\u00f3n, evitando tener que asignar valores despu\u00e9s. Esto asegura que el objeto se construya desde el principio con un estado v\u00e1lido y completo.  </p> </li> <li>Ejemplo: <code>java     LibroConConstructor libro = new LibroConConstructor(\"Don Quijote\", \"Cervantes\");</code></li> </ul> <p>En resumen, usar constructores favorece la encapsulaci\u00f3n, garantiza la correcta inicializaci\u00f3n del objeto y mejora la legibilidad del c\u00f3digo, mientras que no usarlos da m\u00e1s flexibilidad, pero exige pasos adicionales para asegurar que el objeto no quede en un estado incompleto.</p> <p>Inicializar objetos con-sin constructores</p>"},{"location":"Bloque1_POO/02_codigos4.4/","title":"Modularidad, Herencia y Reusabilidad","text":""},{"location":"Bloque1_POO/02_codigos4.4/#definiciones-y-ejemplos-ilustrativos","title":"Definiciones y ejemplos ilustrativos","text":""},{"location":"Bloque1_POO/02_codigos4.4/#atributos-de-clase","title":"Atributos de clase","text":"<pre><code>public class Contador {\n    private static int numInstancias = 0; // Atributo de clase\n\n    public Contador() {\n        numInstancias++; // Incrementar contador en cada nueva instancia\n    }\n\n    // M\u00e9todo de clase para obtener el n\u00famero de instancias creadas\n    public static int getNumInstancias() {\n        return numInstancias;\n    }\n\n    public static void main(String[] args) {\n        new Contador(); // Primera instancia\n        new Contador(); // Segunda instancia\n\n        System.out.println(\"N\u00famero de instancias creadas: \" + Contador.getNumInstancias());\n        // Output: N\u00famero de instancias creadas: 2\n    }\n}\n</code></pre>"},{"location":"Bloque1_POO/02_codigos4.4/#metodos-de-clase","title":"M\u00e9todos de clase","text":"<pre><code>public class Calculadora {\n    // M\u00e9todo de clase para calcular el cuadrado de un n\u00famero\n    // No es necesario acceder ni modificar los atributos de una instancia espec\u00edfica\n    // No es necesario crear un objeto\n    public static int calcularCuadrado(int numero) {\n        return numero * numero;\n    }\n\n    public static void main(String[] args) {\n        int resultado = Calculadora.calcularCuadrado(5);\n        System.out.println(\"El cuadrado de 5 es: \" + resultado);\n        // Output: El cuadrado de 5 es: 25\n    }\n}\n</code></pre>"},{"location":"Bloque1_POO/02_codigos4.4/#constantes","title":"Constantes","text":"<pre><code>public class Constantes {\n    public static final double PI = 3.141592653589793;\n\n    public static void main(String[] args) {\n        System.out.println(\"Valor de PI: \" + Constantes.PI);\n    }\n}\n</code></pre>"},{"location":"Bloque1_POO/02_codigos4.4/#singleton","title":"Singleton","text":"<pre><code>// Singleton1.java\n// Ejemplo de Singleton listo para ejecutarse en un \u00fanico fichero con \"Run\" de VS Code.\n\npublic class Singleton1 {\n\n    // Instancia \u00fanica (volatile para doble comprobaci\u00f3n segura en multihilo)\n    private static volatile Singleton1 instancia;\n\n    // Constructor privado: evita instanciaci\u00f3n externa\n    private Singleton1() {\n        System.out.println(\"Inicializando configuraci\u00f3n...\");\n    }\n\n    // Punto de acceso global con double-checked locking (seguro desde Java 5+)\n    public static Singleton1 getInstance() {\n        if (instancia == null) {\n            synchronized (Singleton1.class) {\n                if (instancia == null) {\n                    instancia = new Singleton1();\n                }\n            }\n        }\n        return instancia;\n    }\n\n    public void mostrarMensaje() {\n        System.out.println(\"\u00a1Hola desde el Singleton!\");\n    }\n\n    // M\u00e9todo main en el MISMO fichero/clase para ejecutarlo directamente\n    public static void main(String[] args) {\n        Singleton1 c1 = Singleton1.getInstance();\n        Singleton1 c2 = Singleton1.getInstance();\n\n        c1.mostrarMensaje();\n\n        // Verificaci\u00f3n: ambas referencias apuntan al mismo objeto\n        System.out.println(\"\u00bfEs la misma instancia? \" + (c1 == c2));\n    }\n}\n\n</code></pre> <pre><code>public class Singleton2 {\n    private static Singleton2 instanciaUnica;\n\n    // Constructor privado para evitar la creaci\u00f3n de nuevas instancias\n    private Singleton2() {}\n\n    // M\u00e9todo de clase para obtener la instancia \u00fanica\n    public static Singleton2 obtenerInstancia() {\n        if (instanciaUnica == null) {\n            instanciaUnica = new Singleton2();\n        }\n        return instanciaUnica;\n    }\n\n    public void mostrarMensaje() {\n        System.out.println(\"Esta es la \u00fanica instancia de Singleton.\");\n    }\n\n    public static void main(String[] args) {\n        Singleton2 instancia = Singleton2.obtenerInstancia();\n        instancia.mostrarMensaje();\n    }\n}\n\n</code></pre>"},{"location":"Bloque1_POO/02_codigos4/","title":"Modularidad, Herencia y Reusabilidad","text":""},{"location":"Bloque1_POO/02_codigos4/#definiciones-y-ejemplos-ilustrativos","title":"Definiciones y ejemplos ilustrativos","text":""},{"location":"Bloque1_POO/02_codigos4/#conceptos-fundamentales-de-la-programacion-orientada-a-objetos","title":"Conceptos fundamentales de la programaci\u00f3n orientada a objetos","text":""},{"location":"Bloque1_POO/02_codigos4/#atributos-y-metodos-de-clase","title":"Atributos y m\u00e9todos de clase.","text":"<p>En Java, los atributos y m\u00e9todos de clase son aquellos declarados con la palabra clave static. Los atributos de clase representan valores compartidos por todas las instancias de la clase (por ejemplo, un contador de objetos creados), mientras que los m\u00e9todos de clase son funciones que se pueden invocar sin necesidad de crear un objeto (por ejemplo, Math.sqrt()). Se deben usar cuando la informaci\u00f3n o el comportamiento no dependen de un objeto concreto, sino de la clase en general, facilitando as\u00ed recursos comunes, utilidades o constantes accesibles globalmente.</p> \ud83d\udca1 Atributos de clase  <p> Se usan atributos de clase (static) cuando la informaci\u00f3n debe ser compartida entre todas las instancias o cuando el dato no pertenece a una instancia espec\u00edfica.</p> <p>Atributos de clase</p> \ud83d\udca1 M\u00e9todos de clase  <p> Se usan m\u00e9todos de clase (static) cuando la funcionalidad no depende del estado de una instancia y puede ejecutarse sin necesidad de crear un objeto.</p> <p>M\u00e9todos de clase</p>"},{"location":"Bloque1_POO/02_codigos4/#constantes","title":"Constantes","text":"<p>En Java, las constantes son variables cuyo valor no puede modificarse una vez asignado. Se definen con los modificadores static final, lo que significa que pertenecen a la clase (y no a instancias espec\u00edficas) y que su valor es inmutable.  </p> \ud83d\udca1 Constantes  <p> Por convenci\u00f3n, los nombres de las constantes se escriben en may\u00fasculas y con guiones bajos para separar palabras, como PI, MAX_VALUE o DEFAULT_TIMEOUT.</p> <p> Se utilizan para representar valores fijos y universales en el programa, mejorando la legibilidad y evitando errores asociados a la duplicaci\u00f3n de n\u00fameros m\u00e1gicos o cadenas repetidas en el c\u00f3digo.</p> <p>Constantes</p>"},{"location":"Bloque1_POO/02_codigos4/#patron-singleton","title":"Patr\u00f3n Singleton","text":"<p>El patr\u00f3n Singleton es un patr\u00f3n de dise\u00f1o creacional que garantiza que solo exista una \u00fanica instancia de una clase en todo el sistema y que, adem\u00e1s, sea f\u00e1cilmente accesible desde cualquier parte del programa. En Java, se implementa declarando el constructor como privado (para evitar que se creen instancias desde fuera) y proporcionando un m\u00e9todo p\u00fablico y est\u00e1tico que devuelve siempre la misma instancia (por ejemplo, getInstance()). Se suele usar cuando es necesario un \u00fanico punto de acceso a un recurso compartido, como un gestor de configuraci\u00f3n, un logger, una conexi\u00f3n a base de datos o un manejador de hilos.</p> <p>Singleton</p>"},{"location":"Bloque1_POO/02_interfazvsclase/","title":"Interfaz vs clase","text":"<pre><code>// -------------\n// 1) Interfaz\n// -------------\ninterface RecetaSalsa {\n    String getNombre();\n    void preparar();\n}\n\n// --------------------------------------\n// 2) Clases que implementan la interfaz\n// --------------------------------------\nclass SalsaTomate implements RecetaSalsa {\n    @Override\n    public String getNombre() {\n        return \"Salsa de Tomate\";\n    }\n\n    @Override\n    public void preparar() {\n        System.out.println(\"Preparando salsa de tomate con tomates, aceite y sal.\");\n    }\n}\n\nclass SalsaPesto implements RecetaSalsa {\n    @Override\n    public String getNombre() {\n        return \"Salsa Pesto\";\n    }\n\n    @Override\n    public void preparar() {\n        System.out.println(\"Preparando salsa pesto con albahaca, pi\u00f1ones y parmesano.\");\n    }\n}\n\n// ----------------------------\n// 3) Clase base con herencia\n// ----------------------------\nclass SalsaBase {\n    protected String nombre;\n    protected String[] ingredientes;\n\n    public SalsaBase(String nombre, String[] ingredientes) {\n        this.nombre = nombre;\n        this.ingredientes = ingredientes;\n    }\n\n    public void mostrarIngredientes() {\n        System.out.print(nombre + \" lleva: \");\n        for (int i = 0; i &lt; ingredientes.length; i++) {\n            System.out.print(ingredientes[i]);\n            if (i &lt; ingredientes.length - 1) System.out.print(\", \");\n        }\n        System.out.println(\".\");\n    }\n}\n\n// -----------------------------------\n// 4) Clases que heredan de SalsaBase\n// -----------------------------------\nclass SalsaCarbonara extends SalsaBase {\n    public SalsaCarbonara() {\n        //Usamos super para invocar al constructor de la clase base\n        super(\"Salsa Carbonara\", new String[]{\"nata\", \"huevo\", \"queso\", \"panceta\"});\n    }\n}\n\nclass SalsaBolonesa extends SalsaBase {\n    public SalsaBolonesa() {\n        super(\"Salsa Bolonesa\", new String[]{\"carne\", \"tomate\", \"cebolla\", \"zanahoria\"});\n    }\n}\n\n// -------------------\n// 5) Clase principal\n// -------------------\npublic class SalsasDemo {\n    public static void main(String[] args) {\n        // Uso de la interfaz\n        RecetaSalsa r1 = new SalsaTomate();\n        RecetaSalsa r2 = new SalsaPesto();\n\n        System.out.println(\"=== Usando la interfaz RecetaSalsa ===\");\n        r1.preparar();\n        r2.preparar();\n\n        // Uso de la clase base\n        SalsaBase s1 = new SalsaCarbonara();\n        SalsaBase s2 = new SalsaBolonesa();\n\n        System.out.println(\"\\n=== Usando la clase base SalsaBase ===\");\n        s1.mostrarIngredientes();\n        s2.mostrarIngredientes();\n    }\n}\n\n</code></pre> \ud83d\udca1 Diferencias  <p>M\u00e9todos sobrescritos (en herencia o implementaci\u00f3n) \u2192 siempre runtime (dynamic dispatch).</p> <p>M\u00e9todos est\u00e1ticos, privados o finales \u2192 resueltos en compilaci\u00f3n / no-polim\u00f3rficos.</p> <p>Diferencia real: extends usa invokevirtual, implements usa invokeinterface.</p> \ud83d\udca1 extends <p>Solo puedes extender de UNA sola clase (Java no permite herencia m\u00faltiple de clases).</p> <p>Heredas atributos y m\u00e9todos de la superclase.</p> <p>Puedes sobrescribir (override) m\u00e9todos para dar un comportamiento espec\u00edfico.</p> <p>Puedes a\u00f1adir nuevos atributos o m\u00e9todos.</p> <p>extends significa: soy un tipo m\u00e1s espec\u00edfico de esa clase.</p> \ud83d\udca1 implements <p>Una interfaz define un contrato (qu\u00e9 m\u00e9todos debe tener la clase), pero no la implementaci\u00f3n.</p> <p>Una clase puede implementar varias interfaces \u2192 es la forma de tener herencia m\u00faltiple en Java.</p> <p>Obliga a la clase a implementar todos los m\u00e9todos declarados en la interfaz (salvo que la clase sea abstracta).</p> <p>Puedes a\u00f1adir nuevos atributos o m\u00e9todos.</p> <p>implements significa: cumplo el contrato de esta interfaz.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/","title":"Modularidad, Herencia y Reusabilidad","text":""},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#introduccion","title":"Introducci\u00f3n","text":"<p>En el desarrollo de software, conceptos como modularidad, herencia y reusabilidad son esenciales para crear programas m\u00e1s claros, mantenibles y escalables. Estos principios permiten organizar el c\u00f3digo, reducir la duplicaci\u00f3n y facilitar la evoluci\u00f3n de los proyectos.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#modularidad","title":"Modularidad","text":"<p>La modularidad consiste en dividir un programa en componentes o m\u00f3dulos independientes, de manera que cada uno tenga una responsabilidad clara.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#caracteristicas","title":"Caracter\u00edsticas","text":"<ul> <li>Un m\u00f3dulo puede desarrollarse, probarse y mantenerse de forma aislada.</li> <li>Facilita localizar y corregir errores.</li> <li>Permite ampliar la funcionalidad sin afectar a todo el sistema.</li> </ul>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#herencia","title":"Herencia","text":"<p>La herencia permite definir nuevas clases basadas en otras ya existentes, reutilizando atributos y m\u00e9todos y a\u00f1adiendo o especializando funcionalidades.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#conceptos-clave","title":"Conceptos clave","text":"<ul> <li>Superclase (clase base): clase original de la que heredan otras.</li> <li>Subclase (clase derivada): clase que extiende la funcionalidad de la superclase.</li> </ul>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#polimorfismo-y-clases-abstractas","title":"Polimorfismo y Clases Abstractas","text":"<p>El polimorfismo permite que una misma referencia pueda apuntar a objetos de diferentes clases, ejecutando el m\u00e9todo correspondiente seg\u00fan el tipo del objeto real.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#interfaces","title":"Interfaces","text":"<p>Una interfaz define un conjunto de m\u00e9todos sin implementaci\u00f3n. Las clases que la implementan son responsables de definir su funcionamiento.</p> <p>Las interfaces permiten simular la herencia m\u00faltiple y promueven la flexibilidad del dise\u00f1o.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#reusabilidad","title":"Reusabilidad","text":"<p>La reusabilidad consiste en emplear c\u00f3digo existente en diferentes contextos o proyectos, evitando duplicaciones. Se refiere a la capacidad de utilizar las mismas piezas de c\u00f3digo en diferentes partes del programa o en diferentes proyectos.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#beneficios","title":"Beneficios","text":"<ul> <li>Reducci\u00f3n de errores y duplicaciones.</li> <li>Mayor rapidez en el desarrollo.</li> <li>C\u00f3digo m\u00e1s consistente y probado.</li> </ul>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#conclusion","title":"Conclusi\u00f3n","text":"<ul> <li>La modularidad favorece el orden y la claridad.  </li> <li>La herencia y el polimorfismo permiten extender y generalizar comportamientos.  </li> <li>La reusabilidad reduce costes y facilita el mantenimiento.  </li> <li>Las interfaces aportan flexibilidad para dise\u00f1ar sistemas m\u00e1s escalables.</li> </ul> <p>Estos principios son fundamentales en la Programaci\u00f3n Orientada a Objetos (POO) y constituyen la base de un software robusto y adaptable.</p> <p>Ejemplos pr\u00e1cticos 1</p> <p>Ejemplos pr\u00e1cticos 2</p> <p>Ejemplos pr\u00e1cticos 3</p> <p>Ejemplos pr\u00e1cticos 4</p>"},{"location":"Bloque1_POO/03_codigos1/","title":"Genericidad y contenedores","text":""},{"location":"Bloque1_POO/03_codigos1/#definiciones-y-ejemplos-ilustrativos","title":"Definiciones y ejemplos ilustrativos","text":""},{"location":"Bloque1_POO/03_codigos1/#colecciones","title":"Colecciones","text":"<pre><code>import java.util.*;  // Importamos las colecciones y las interfaces necesarias\n\npublic class EjemploColecciones {\n    public static void main(String[] args) {\n        // ------------------ Uso de la Interfaz Set y SortedSet ------------------\n\n        // Set no permite elementos duplicados\n        Set&lt;String&gt; conjuntoNombres = new HashSet&lt;&gt;();\n        conjuntoNombres.add(\"Mar\u00eda\");\n        conjuntoNombres.add(\"Juan\");\n        conjuntoNombres.add(\"Ana\");\n        conjuntoNombres.add(\"Pedro\");\n\n        System.out.println(\"Conjunto de nombres (Set): \" + conjuntoNombres);\n\n        // SortedSet mantiene los elementos ordenados\n        SortedSet&lt;String&gt; conjuntoOrdenado = new TreeSet&lt;&gt;(conjuntoNombres);\n        System.out.println(\"Conjunto ordenado (SortedSet): \" + conjuntoOrdenado);\n\n        // ------------------ Uso de la Interfaz Iterator ------------------\n\n        // Iterador para recorrer el conjunto de nombres\n        Iterator&lt;String&gt; iterador = conjuntoNombres.iterator();\n        System.out.println(\"Recorriendo el conjunto con Iterator:\");\n        while (iterador.hasNext()) {\n            String nombre = iterador.next();\n            System.out.println(nombre);\n        }\n\n        // ------------------ Uso de la Interfaz Comparator ------------------\n\n        // Comparator para ordenar alfab\u00e9ticamente de forma inversa\n        Comparator&lt;String&gt; comparadorInverso = new Comparator&lt;String&gt;() {\n            @Override\n            public int compare(String o1, String o2) {\n                return o2.compareTo(o1);  // Orden inverso\n            }\n        };\n\n        // Aplicamos el comparador inverso al SortedSet\n        SortedSet&lt;String&gt; conjuntoOrdenadoInverso = new TreeSet&lt;&gt;(comparadorInverso);\n        conjuntoOrdenadoInverso.addAll(conjuntoNombres);\n        System.out.println(\"Conjunto ordenado inversamente (SortedSet con Comparator): \" + conjuntoOrdenadoInverso);\n\n        // ------------------ Uso de la Interfaz List y ListIterator ------------------\n\n        // Lista de n\u00fameros (permite duplicados y tiene un orden espec\u00edfico)\n        List&lt;Integer&gt; listaNumeros = new ArrayList&lt;&gt;();\n        listaNumeros.add(10);\n        listaNumeros.add(20);\n        listaNumeros.add(30);\n        listaNumeros.add(40);\n\n        System.out.println(\"Lista de n\u00fameros (List): \" + listaNumeros);\n\n        // Uso de ListIterator para recorrer la lista en ambas direcciones\n        ListIterator&lt;Integer&gt; listIterator = listaNumeros.listIterator();\n        System.out.println(\"Recorriendo la lista de n\u00fameros hacia adelante con ListIterator:\");\n        while (listIterator.hasNext()) {\n            System.out.println(listIterator.next());\n        }\n\n        // Recorrido hacia atr\u00e1s\n        System.out.println(\"Recorriendo la lista de n\u00fameros hacia atr\u00e1s con ListIterator:\");\n        while (listIterator.hasPrevious()) {\n            System.out.println(listIterator.previous());\n        }\n\n        // ------------------ Uso de la Interfaz Map y SortedMap ------------------\n\n        // Mapa para almacenar pares clave-valor (ID de empleado y su nombre)\n        //Map&lt;Integer, String&gt; mapaEmpleados = new HashMap&lt;&gt;();\n        // HashMap no garantiza orden de inserci\u00f3n\n        Map&lt;Integer, String&gt; mapaEmpleados = new LinkedHashMap&lt;&gt;();\n        // LinkedHashMap s\u00ed garantiza orden de inserci\u00f3n\n        mapaEmpleados.put(103, \"Juan\");\n        mapaEmpleados.put(102, \"Mar\u00eda\");\n        mapaEmpleados.put(101, \"Pedro\");\n\n        System.out.println(\"Mapa de empleados (Map):\");\n        for (Map.Entry&lt;Integer, String&gt; entrada : mapaEmpleados.entrySet()) {\n            System.out.println(\"ID: \" + entrada.getKey() + \", Nombre: \" + entrada.getValue());\n        }\n\n        // SortedMap para mantener las claves ordenadas\n        SortedMap&lt;Integer, String&gt; mapaEmpleadosOrdenado = new TreeMap&lt;&gt;(mapaEmpleados);\n        System.out.println(\"Mapa de empleados ordenado por clave (SortedMap):\");\n        for (Map.Entry&lt;Integer, String&gt; entrada : mapaEmpleadosOrdenado.entrySet()) {\n            System.out.println(\"ID: \" + entrada.getKey() + \", Nombre: \" + entrada.getValue());\n        }\n    }\n}\n</code></pre>"},{"location":"Bloque1_POO/03_codigos1/#list","title":"List","text":"<pre><code>// Una lista es una colecci\u00f3n ordenada que permite \n// elementos duplicados\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class EjemploLista {\n    public static void main(String[] args) {\n        List&lt;String&gt; lista = new ArrayList&lt;&gt;();\n        Scanner sc = new Scanner(System.in);\n\n        // A\u00f1adir elementos a la lista\n        System.out.println(\"Introduce 3 nombres:\");\n        for (int i = 0; i &lt; 3; i++) {\n            System.out.print(\"Nombre \" + (i + 1) + \": \");\n            lista.add(sc.nextLine());\n        }\n\n        // Mostrar los elementos de la lista\n        System.out.println(\"Los nombres introducidos son:\");\n        for (String nombre : lista) {\n            System.out.println(nombre);\n        }\n\n        sc.close();\n    }\n}\n\n</code></pre>"},{"location":"Bloque1_POO/03_codigos1/#set","title":"Set","text":"<pre><code>// Un conjunto es una colecci\u00f3n que no permite \n// elementos duplicados\n\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class EjemploConjunto {\n    public static void main(String[] args) {\n        Set&lt;String&gt; conjunto = new HashSet&lt;&gt;();\n        Scanner sc = new Scanner(System.in);\n\n        // A\u00f1adir elementos al conjunto\n        System.out.println(\"Introduce 3 nombres (los duplicados se ignorar\u00e1n):\");\n        for (int i = 0; i &lt; 3; i++) {\n            System.out.print(\"Nombre \" + (i + 1) + \": \");\n            conjunto.add(sc.nextLine());\n        }\n\n        // Mostrar los elementos del conjunto\n        System.out.println(\"Los nombres introducidos son:\");\n        for (String nombre : conjunto) {\n            System.out.println(nombre);\n        }\n\n        sc.close();\n    }\n}\n</code></pre>"},{"location":"Bloque1_POO/03_codigos1/#map","title":"Map","text":"<pre><code>// Un mapa es una estructura de datos que asocia \n// claves a valores\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class EjemploMapa {\n    public static void main(String[] args) {\n        Map&lt;String, Integer&gt; mapa = new HashMap&lt;&gt;();\n        Scanner sc = new Scanner(System.in);\n\n        // A\u00f1adir elementos al mapa\n        System.out.println(\"Introduce 3 nombres y sus edades:\");\n        for (int i = 0; i &lt; 3; i++) {\n            System.out.print(\"Nombre: \");\n            String nombre = sc.nextLine();\n            System.out.print(\"Edad: \");\n            int edad = sc.nextInt();\n            sc.nextLine(); // Consumir el salto de l\u00ednea\n            mapa.put(nombre, edad);\n        }\n\n        // Mostrar los elementos del mapa\n        System.out.println(\"Los nombres y sus edades son:\");\n        for (Map.Entry&lt;String, Integer&gt; entrada : mapa.entrySet()) {\n            System.out.println(entrada.getKey() + \" tiene \" + entrada.getValue() + \" a\u00f1os.\");\n        }\n\n        sc.close();\n    }\n}\n\n</code></pre>"},{"location":"Bloque1_POO/03_codigos1/#queue","title":"Queue","text":"<pre><code>// Una cola es una estructura de datos FIFO.\n\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class EjemploCola {\n    public static void main(String[] args) {\n        Queue&lt;String&gt; cola = new LinkedList&lt;&gt;();\n        Scanner sc = new Scanner(System.in);\n\n        // A\u00f1adir elementos a la cola\n        System.out.println(\"Introduce 3 nombres:\");\n        for (int i = 0; i &lt; 3; i++) {\n            System.out.print(\"Nombre \" + (i + 1) + \": \");\n            cola.offer(sc.nextLine());\n        }\n\n        // Mostrar y quitar elementos de la cola\n        System.out.println(\"Atendiendo a los nombres en la cola:\");\n        while (!cola.isEmpty()) {\n            System.out.println(\"Atendiendo a: \" + cola.poll());\n        }\n\n        sc.close();\n    }\n}\n\n</code></pre>"},{"location":"Bloque1_POO/03_codigos1/#deque","title":"Deque","text":"<pre><code>import java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class EjemploDeque {\n    public static void main(String[] args) {\n        Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();\n        Scanner sc = new Scanner(System.in);\n\n        // A\u00f1adir elementos al principio y al final del deque\n        System.out.println(\"Introduce 3 nombres para a\u00f1adir al principio:\");\n        for (int i = 0; i &lt; 3; i++) {\n            System.out.print(\"Nombre \" + (i + 1) + \": \");\n            deque.addFirst(sc.nextLine());\n        }\n\n        System.out.println(\"Introduce 3 nombres para a\u00f1adir al final:\");\n        for (int i = 0; i &lt; 3; i++) {\n            System.out.print(\"Nombre \" + (i + 1) + \": \");\n            deque.addLast(sc.nextLine());\n        }\n\n        // Mostrar y quitar elementos del deque desde ambos extremos\n        System.out.println(\"Eliminando del principio:\");\n        while (!deque.isEmpty()) {\n            System.out.println(\"Eliminado: \" + deque.pollFirst());\n        }\n\n        sc.close();\n    }\n}\n</code></pre>"},{"location":"Bloque1_POO/03_codigos2/","title":"Genericidad y contenedores   -- s5-d2","text":""},{"location":"Bloque1_POO/03_codigos2/#definiciones-y-ejemplos-ilustrativos","title":"Definiciones y ejemplos ilustrativos","text":""},{"location":"Bloque1_POO/03_codigos2/#conceptos-fundamentales-sobre-genericidad-y-contenedores","title":"Conceptos fundamentales sobre genericidad y contenedores","text":""},{"location":"Bloque1_POO/03_codigos3/","title":"Genericidad y contenedores   -- s6-d1","text":""},{"location":"Bloque1_POO/03_codigos3/#definiciones-y-ejemplos-ilustrativos","title":"Definiciones y ejemplos ilustrativos","text":""},{"location":"Bloque1_POO/03_codigos3/#conceptos-fundamentales-sobre-genericidad-y-contenedores","title":"Conceptos fundamentales sobre genericidad y contenedores","text":""},{"location":"Bloque1_POO/03_codigos4/","title":"Genericidad y contenedores   -- s6-d2","text":""},{"location":"Bloque1_POO/03_codigos4/#definiciones-y-ejemplos-ilustrativos","title":"Definiciones y ejemplos ilustrativos","text":""},{"location":"Bloque1_POO/03_codigos4/#conceptos-fundamentales-sobre-genericidad-y-contenedores","title":"Conceptos fundamentales sobre genericidad y contenedores","text":""},{"location":"Bloque1_POO/03_colecciones_ejemplosrapidos/","title":"Colecciones ejemplos r\u00e1pidos","text":""},{"location":"Bloque1_POO/03_colecciones_ejemplosrapidos/#list","title":"List","text":""},{"location":"Bloque1_POO/03_colecciones_ejemplosrapidos/#permite-elementos-duplicados-y-mantiene-el-orden-de-insercion","title":"Permite elementos duplicados y mantiene el orden de inserci\u00f3n","text":"<pre><code>\nList&lt;String&gt; nombres = new ArrayList&lt;&gt;();\nnombres.add(\"Mar\u00eda\");\nnombres.add(\"Juan\");\nnombres.add(\"Mar\u00eda\"); // permitido\n\nSystem.out.println(nombres); // [Mar\u00eda, Juan, Mar\u00eda]\n\n</code></pre>"},{"location":"Bloque1_POO/03_colecciones_ejemplosrapidos/#set","title":"Set","text":""},{"location":"Bloque1_POO/03_colecciones_ejemplosrapidos/#no-permite-duplicados","title":"No permite duplicados","text":"<pre><code>\nSet&lt;String&gt; dniSet = new HashSet&lt;&gt;();\ndniSet.add(\"123A\");\ndniSet.add(\"123A\");\ndniSet.add(\"456B\");\n\nSystem.out.println(dniSet); // [123A, 456B]\n\n</code></pre>"},{"location":"Bloque1_POO/03_colecciones_ejemplosrapidos/#sortedset","title":"SortedSet","text":"<pre><code>\nimport java.util.*;\n\nSortedSet&lt;Integer&gt; numeros = new TreeSet&lt;&gt;();\nnumeros.add(5);\nnumeros.add(1);\nnumeros.add(3);\n\nSystem.out.println(numeros); // [1, 3, 5]\n\n</code></pre>"},{"location":"Bloque1_POO/03_colecciones_ejemplosrapidos/#queue","title":"Queue","text":""},{"location":"Bloque1_POO/03_colecciones_ejemplosrapidos/#representa-una-cola-fifo-el-primero-en-entrar-es-el-primero-en-salir","title":"Representa una cola (FIFO): el primero en entrar es el primero en salir.","text":"<pre><code>\nimport java.util.*;\n\nQueue&lt;String&gt; cola = new LinkedList&lt;&gt;();\ncola.add(\"Ana\");\ncola.add(\"Luis\");\ncola.add(\"Marta\");\n\nSystem.out.println(cola.poll()); // Ana\nSystem.out.println(cola.peek()); // Luis\n\n</code></pre>"},{"location":"Bloque1_POO/03_colecciones_ejemplosrapidos/#deque","title":"Deque","text":""},{"location":"Bloque1_POO/03_colecciones_ejemplosrapidos/#no-permite-duplicados_1","title":"No permite duplicados","text":"<pre><code>\nimport java.util.*;\n\nDeque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();\ndeque.addFirst(\"inicio\");\ndeque.addLast(\"fin\");\n\nSystem.out.println(deque.removeLast());  // fin\nSystem.out.println(deque.removeFirst()); // inicio\n\n</code></pre>"},{"location":"Bloque1_POO/03_colecciones_ejemplosrapidos/#map","title":"Map","text":""},{"location":"Bloque1_POO/03_colecciones_ejemplosrapidos/#asocia-clave-valor","title":"Asocia: clave \u2192 valor","text":"<pre><code>\nMap&lt;String, Integer&gt; edades = new HashMap&lt;&gt;();\nedades.put(\"Ana\", 25);\nedades.put(\"Luis\", 30);\nedades.put(\"Ana\", 27); // sobrescribe el valor anterior\n\nSystem.out.println(edades); // {Luis=30, Ana=27}\n\n</code></pre>"},{"location":"Bloque1_POO/03_colecciones_ejemplosrapidos/#sortedmap","title":"SortedMap","text":""},{"location":"Bloque1_POO/03_colecciones_ejemplosrapidos/#asocia-clave-valor-pero-ordenado-por-clave","title":"Asocia clave \u2192 valor, pero ordenado por clave","text":"<pre><code>\nimport java.util.*;\n\nSortedMap&lt;String, Integer&gt; edades = new TreeMap&lt;&gt;();\nedades.put(\"Luis\", 30);\nedades.put(\"Ana\", 27);\nedades.put(\"Carlos\", 25);\n\nSystem.out.println(edades); // {Ana=27, Carlos=25, Luis=30}\n\n</code></pre>"},{"location":"Bloque1_POO/03_colecciones_genericidad/","title":"Colecciones y Genericidad en Java","text":""},{"location":"Bloque1_POO/03_colecciones_genericidad/#introduccion-a-las-colecciones","title":"Introducci\u00f3n a las Colecciones","text":"<p>Una colecci\u00f3n es un objeto que agrupa otros objetos (llamados elementos). Por ejemplo, una lista de estudiantes, un conjunto de DNIs o un mapa de claves y valores.</p> <p>El marco de colecciones ofrece:</p> <ul> <li>Interfaces que definen los tipos de colecciones (por ejemplo, <code>List</code>, <code>Set</code>, <code>Map</code>).  </li> <li>Clases concretas que implementan esas interfaces (<code>ArrayList</code>, <code>HashSet</code>, <code>HashMap</code>, etc.).  </li> <li>Algoritmos gen\u00e9ricos (en la clase <code>Collections</code>) para ordenar, buscar, mezclar, etc.</li> </ul>"},{"location":"Bloque1_POO/03_colecciones_genericidad/#estructura-del-java-collections-framework","title":"Estructura del Java Collections Framework","text":"<pre><code>Collection (interfaz ra\u00edz)\n\u251c\u2500\u2500 List       \u2192 Elementos ordenados, permiten duplicados\n\u2502   \u251c\u2500\u2500 ArrayList\n\u2502   \u251c\u2500\u2500 LinkedList\n\u2502   \u2514\u2500\u2500 Vector / Stack\n\u2502\n\u251c\u2500\u2500 Set        \u2192 No permite duplicados\n\u2502   \u251c\u2500\u2500 HashSet\n\u2502   \u251c\u2500\u2500 LinkedHashSet\n\u2502   \u2514\u2500\u2500 TreeSet\n\u2502\n\u2514\u2500\u2500 Queue      \u2192 Orden basada en prioridad o FIFO\n    \u251c\u2500\u2500 PriorityQueue\n    \u2514\u2500\u2500 ArrayDeque\n\nMap (interfaz separada, no hereda de Collection)\n\u251c\u2500\u2500 HashMap\n\u251c\u2500\u2500 LinkedHashMap\n\u2514\u2500\u2500 TreeMap\n</code></pre> <p>Esquema b\u00e1sico del Java Collection Framework</p> <p>Componentes del JCF</p>"},{"location":"Bloque1_POO/03_colecciones_genericidad/#genericidad-en-java","title":"Genericidad en Java","text":"<p>Los gen\u00e9ricos son un mecanismo del lenguaje que permite definir clases, interfaces y m\u00e9todos que operan sobre tipos de datos parametrizados, es decir, sin especificar el tipo concreto hasta su uso.</p> <p>Los gen\u00e9ricos proporcionan seguridad de tipos y reutilizaci\u00f3n de c\u00f3digo: se define una estructura general (por ejemplo, una lista) que puede almacenar distintos tipos de datos de forma segura.</p> <p>Ejemplo:</p> <pre><code>List&lt;String&gt; nombres = new ArrayList&lt;&gt;();\nnombres.add(\"Ana\");\n// nombres.add(3); // \u274c error en compilaci\u00f3n\nString nombre = nombres.get(0); // \u2705 sin necesidad de casting\n</code></pre>"},{"location":"Bloque1_POO/03_colecciones_genericidad/#ventajas","title":"Ventajas","text":"<ul> <li>Mayor seguridad de tipos: evita errores en tiempo de ejecuci\u00f3n.  </li> <li>Elimina conversiones con <code>Object</code>.  </li> <li>Permite reutilizar c\u00f3digo con distintos tipos.  </li> </ul>"},{"location":"Bloque1_POO/03_colecciones_genericidad/#definicion-de-una-clase-generica","title":"Definici\u00f3n de una Clase Gen\u00e9rica","text":"<pre><code>public class Caja&lt;T&gt; {\n    private T contenido;\n\n    public void setContenido(T contenido) {\n        this.contenido = contenido;\n    }\n\n    public T getContenido() {\n        return contenido;\n    }\n}\n</code></pre> <p>Uso:</p> <pre><code>Caja&lt;String&gt; caja1 = new Caja&lt;&gt;();\ncaja1.setContenido(\"Hola mundo\");\n\nCaja&lt;Integer&gt; caja2 = new Caja&lt;&gt;();\ncaja2.setContenido(42);\n</code></pre>"},{"location":"Bloque1_POO/03_colecciones_genericidad/#parametros-de-tipo-comunes","title":"Par\u00e1metros de tipo comunes","text":"S\u00edmbolo Significado <code>T</code> Tipo gen\u00e9rico (Type) <code>E</code> Elemento (Element) <code>K</code> Clave (Key) <code>V</code> Valor (Value) <code>N</code> N\u00famero (Number)"},{"location":"Bloque1_POO/03_colecciones_genericidad/#genericos-con-restricciones-bounded-types","title":"Gen\u00e9ricos con restricciones (bounded types)","text":"<p>Permiten limitar el tipo de datos que puede usarse:</p> <pre><code>public &lt;T extends Number&gt; void mostrar(T num) {\n    System.out.println(num.doubleValue());\n}\n</code></pre> <p>\u2705 Acepta: <code>Integer</code>, <code>Double</code>, <code>Float</code> \u274c No acepta: <code>String</code></p>"},{"location":"Bloque1_POO/03_colecciones_genericidad/#comodines-wildcards","title":"Comodines (wildcards)","text":"<p>Los comodines (<code>?</code>) permiten flexibilidad en el tipo gen\u00e9rico:</p> <pre><code>List&lt;? extends Number&gt; listaNumeros; // acepta List&lt;Integer&gt;, List&lt;Double&gt;, etc.\nList&lt;? super Integer&gt; listaEnteros;  // acepta List&lt;Integer&gt;, List&lt;Number&gt;, List&lt;Object&gt;\n</code></pre>"},{"location":"Bloque1_POO/03_comparadores/","title":"Comparadores","text":""},{"location":"Bloque1_POO/03_comparadores/#motivacion-y-objetivo","title":"Motivaci\u00f3n y objetivo","text":"<p>En muchos casos es necesario ordenar colecciones de objetos. Java proporciona mecanismos para establecer criterios de comparaci\u00f3n entre elementos, permitiendo definir un orden natural o varios \u00f3rdenes personalizados seg\u00fan las necesidades del programa.</p> <p>Estos mecanismos se basan en dos interfaces del paquete <code>java.lang</code> y <code>java.util</code>: <code>Comparable</code> y <code>Comparator</code>.</p>"},{"location":"Bloque1_POO/03_comparadores/#conceptos-basicos-comparable-y-comparator","title":"Conceptos b\u00e1sicos: Comparable y Comparator","text":"<p>Java ofrece dos formas principales de comparar objetos:</p> <ul> <li>Comparable: el propio objeto sabe c\u00f3mo compararse con otros del mismo tipo. Define su orden natural.</li> <li>Comparator: un objeto externo define el criterio de comparaci\u00f3n. Permite definir \u00f3rdenes alternativos sin modificar la clase original.</li> </ul> <p>Ambas interfaces se utilizan en colecciones ordenadas y en algoritmos de ordenaci\u00f3n. Su uso correcto garantiza resultados coherentes y predecibles al ordenar objetos.</p>"},{"location":"Bloque1_POO/03_comparadores/#comparable","title":"Comparable","text":"<p>La interfaz <code>Comparable&lt;T&gt;</code> pertenece al paquete <code>java.lang</code> y define un \u00fanico m\u00e9todo:</p> <pre><code>int compareTo(T o);\n</code></pre> <p>Este m\u00e9todo devuelve:</p> <ul> <li>Un valor negativo si el objeto actual es menor que el argumento.</li> <li>Cero si ambos son iguales.</li> <li>Un valor positivo si el objeto actual es mayor.</li> </ul> <p>Esta interfaz se usa cuando la propia clase define su orden natural, como ocurre en tipos integrados (<code>String</code>, <code>Integer</code>, <code>LocalDate</code>, etc.).</p> <p>Al implementar <code>Comparable</code>, se debe garantizar que la relaci\u00f3n de orden sea total y consistente con <code>equals()</code>. Es decir:</p> <ul> <li>Si <code>a.compareTo(b) == 0</code>, entonces <code>a.equals(b)</code> deber\u00eda devolver <code>true</code>.</li> <li>La comparaci\u00f3n debe ser transitiva y sim\u00e9trica.</li> <li>No debe devolver valores arbitrarios ni basarse en restas de enteros para evitar desbordamientos.</li> </ul> <p>El orden natural suele representar el sentido l\u00f3gico de la entidad (por ejemplo, orden alfab\u00e9tico para cadenas o cronol\u00f3gico para fechas).</p>"},{"location":"Bloque1_POO/03_comparadores/#comparator","title":"Comparator","text":"<p>La interfaz <code>Comparator&lt;T&gt;</code> pertenece al paquete <code>java.util</code> y se utiliza para definir criterios de comparaci\u00f3n externos a las clases que se desean ordenar. Define su m\u00e9todo principal:</p> <pre><code>int compare(T o1, T o2);\n</code></pre> <p>Al igual que en <code>Comparable</code>, este m\u00e9todo devuelve un valor negativo, cero o positivo seg\u00fan el orden relativo de los objetos comparados.</p> <p>El uso de <code>Comparator</code> permite:</p> <ul> <li>Definir varios \u00f3rdenes distintos para la misma clase.</li> <li>Ordenar objetos sin modificar su c\u00f3digo fuente.</li> <li>Reutilizar comparadores en diferentes contextos.</li> </ul> <p>Desde Java 8, <code>Comparator</code> incluye m\u00e9todos est\u00e1ticos y por defecto que facilitan su uso:</p> <ul> <li><code>Comparator.comparing(...)</code> \u2014 crea un comparador basado en una clave.</li> <li><code>thenComparing(...)</code> \u2014 permite combinar varios criterios.</li> <li><code>reversed()</code> \u2014 invierte el orden del comparador.</li> <li><code>naturalOrder()</code> y <code>reverseOrder()</code> \u2014 generan comparadores est\u00e1ndar.</li> <li><code>nullsFirst()</code> y <code>nullsLast()</code> \u2014 gestionan valores <code>null</code> de forma expl\u00edcita.</li> </ul> <p>Estos m\u00e9todos favorecen un estilo de programaci\u00f3n m\u00e1s declarativo y expresivo, especialmente al usarse con expresiones lambda.</p>"},{"location":"Bloque1_POO/03_comparadores/#uso-en-colecciones-y-algoritmos-de-ordenacion","title":"Uso en colecciones y algoritmos de ordenaci\u00f3n","text":"<p>Las colecciones ordenadas y los m\u00e9todos de utilidad de la API de Java utilizan comparadores para organizar sus elementos.</p>"},{"location":"Bloque1_POO/03_comparadores/#metodos-de-ordenacion","title":"M\u00e9todos de ordenaci\u00f3n","text":"<ul> <li><code>Collections.sort(List&lt;T&gt;)</code> \u2014 usa el orden natural (<code>Comparable</code>).</li> <li><code>Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;)</code> \u2014 usa un comparador externo.</li> <li><code>List.sort(Comparator&lt;? super T&gt;)</code> \u2014 m\u00e9todo de instancia disponible desde Java 8.</li> </ul>"},{"location":"Bloque1_POO/03_comparadores/#colecciones-ordenadas","title":"Colecciones ordenadas","text":"<p>Las estructuras de datos que mantienen un orden interno (<code>TreeSet</code>, <code>TreeMap</code>) utilizan <code>Comparable</code> o <code>Comparator</code> al crearse:</p> <ul> <li>Si no se pasa un comparador, usan el orden natural (<code>Comparable</code>).</li> <li>Si se proporciona un <code>Comparator</code>, este define el orden de los elementos.</li> </ul> <p>Esto permite crear colecciones flexibles, adaptadas a diferentes criterios de ordenaci\u00f3n.</p>"},{"location":"Bloque1_POO/03_comparadores/#buenas-practicas-y-recomendaciones","title":"Buenas pr\u00e1cticas y recomendaciones","text":"<ul> <li>Implementar Comparable cuando exista un orden natural l\u00f3gico y estable para la clase.  </li> <li>Usar Comparator cuando se requiera un orden alternativo o espec\u00edfico de un contexto.  </li> <li>Mantener la consistencia entre <code>compareTo()</code> y <code>equals()</code>.  </li> <li>Reutilizar comparadores mediante expresiones lambda o m\u00e9todos de utilidad.  </li> <li>Evitar comparar n\u00fameros mediante restas (<code>a - b</code>), usando en su lugar <code>Integer.compare(a, b)</code> o <code>Double.compare(a, b)</code>.  </li> <li>Gestionar correctamente los posibles valores <code>null</code> con <code>Comparator.nullsFirst()</code> o <code>Comparator.nullsLast()</code>.</li> </ul>"},{"location":"Bloque1_POO/03_comparadores/#casos-especiales","title":"Casos especiales","text":""},{"location":"Bloque1_POO/03_comparadores/#tratamiento-de-valores-nulos","title":"Tratamiento de valores nulos","text":"<p>Las colecciones de Java no permiten, por defecto, comparar elementos <code>null</code>. Para evitar errores, se pueden usar los m\u00e9todos <code>nullsFirst()</code> o <code>nullsLast()</code> al crear el comparador.</p>"},{"location":"Bloque1_POO/03_comparadores/#ordenacion-compuesta","title":"Ordenaci\u00f3n compuesta","text":"<p>Es habitual ordenar primero por un atributo y, en caso de empate, por otro. <code>Comparator.thenComparing()</code> permite definir este tipo de ordenaciones de forma encadenada.</p>"},{"location":"Bloque1_POO/03_comparadores/#uso-con-streams","title":"Uso con Streams","text":"<p>Los flujos (<code>Stream</code>) admiten comparadores en su m\u00e9todo <code>sorted()</code>, permitiendo ordenar colecciones de manera declarativa y flexible sin modificarlas directamente.</p>"},{"location":"Bloque1_POO/03_comparadores/#tipos-primitivos-y-envoltorios","title":"Tipos primitivos y envoltorios","text":"<p>Las clases envoltorio (<code>Integer</code>, <code>Double</code>, <code>Character</code>, etc.) implementan <code>Comparable</code> con su orden natural, por lo que se pueden usar directamente en colecciones ordenadas.</p>"},{"location":"Bloque1_POO/03_comparadores/#resumen-conceptual-iterable-iterator-comparable-y-comparator","title":"Resumen conceptual: Iterable, Iterator, Comparable y Comparator","text":"Elemento Tipo de interfaz Qu\u00e9 representa D\u00f3nde se implementa M\u00e9todo(s) principal(es) Prop\u00f3sito Ejemplo de uso <code>Iterable&lt;T&gt;</code> De capacidad / cualidad La colecci\u00f3n puede ser recorrida En las clases de colecci\u00f3n (<code>List</code>, <code>Set</code>, <code>Queue</code>, etc.) <code>iterator()</code> Producir un iterador que recorra sus elementos <code>lista.iterator()</code> devuelve un <code>Iterator</code> <code>Iterator&lt;E&gt;</code> De comportamiento funcional El objeto que realiza el recorrido sobre los elementos En clases internas de las colecciones <code>hasNext()</code>, <code>next()</code>, <code>remove()</code> Recorrer una colecci\u00f3n elemento a elemento <code>it.hasNext()</code> / <code>it.next()</code> <code>Comparable&lt;T&gt;</code> De comportamiento funcional El objeto sabe compararse consigo mismo En la propia clase del objeto <code>compareTo(T o)</code> Definir el orden natural de los objetos <code>Collections.sort(lista)</code> usa <code>compareTo()</code> <code>Comparator&lt;T&gt;</code> De comportamiento funcional externo Un objeto que compara dos instancias Fuera de la clase (otra clase o expresi\u00f3n lambda) <code>compare(T o1, T o2)</code> Definir \u00f3rdenes alternativos sin modificar la clase <code>Collections.sort(lista, comparador)</code>"},{"location":"Bloque1_POO/03_comparadores/#en-resumen-conceptual","title":"En resumen conceptual","text":"<ul> <li><code>Iterable</code> define una capacidad: la de poder ser recorrido.  </li> <li><code>Iterator</code> define un comportamiento: c\u00f3mo se realiza ese recorrido.  </li> <li><code>Comparable</code> define un comportamiento interno: c\u00f3mo un objeto se compara consigo mismo.  </li> <li><code>Comparator</code> define un comportamiento externo: c\u00f3mo comparar objetos seg\u00fan un criterio distinto.</li> </ul>"},{"location":"Bloque1_POO/03_genericidad_contenedores/","title":"Genericidad y Contenedores","text":""},{"location":"Bloque1_POO/03_genericidad_contenedores/#introduccion-a-los-contenedores","title":"Introducci\u00f3n a los contenedores","text":"<p>Los contenedores o colecciones son objetos que almacenan otros objetos. Se utilizan para:  </p> <ul> <li>Almacenar, recuperar y manipular datos.  </li> <li>Transmitir datos entre m\u00e9todos.  </li> <li>Representar grupos naturales de elementos (ejemplo: lista de contactos, conjunto de objetos gr\u00e1ficos, carpeta de correos).  </li> </ul> <p>Ejemplo cl\u00e1sico: los vectores. A partir de Java 2, la biblioteca <code>java.util</code> proporciona un marco unificado para manejar colecciones.  </p>"},{"location":"Bloque1_POO/03_genericidad_contenedores/#genericidad-en-java","title":"Genericidad en Java","text":"<p>Desde la versi\u00f3n Java 5, las clases e interfaces de contenedores son gen\u00e9ricas. Esto implica que al definir un contenedor se especifica qu\u00e9 tipo de dato almacenar\u00e1.</p> <p>Formato:  </p> <pre><code>NombreClase&lt;T&gt;\n</code></pre> <p>donde <code>T</code> representa el tipo de dato a almacenar.</p> <p>Caracter\u00edsticas: </p> <ul> <li>Solo admite clases (no tipos primitivos).    </li> <li>Evita conversiones innecesarias con <code>Object</code>.    </li> <li>Aporta seguridad de tipos en tiempo de compilaci\u00f3n.  </li> </ul> <p>Colecciones</p> <p>Ejemplos r\u00e1pidos</p>"},{"location":"Bloque1_POO/03_genericidad_contenedores/#tipos-de-contenedores","title":"Tipos de contenedores","text":""},{"location":"Bloque1_POO/03_genericidad_contenedores/#list","title":"List","text":"<p>Una List es una colecci\u00f3n ordenada que permite elementos duplicados y acceso posicional mediante \u00edndices. Implementaciones comunes: ArrayList (r\u00e1pido acceso por \u00edndice, coste alto en inserciones intermedias) y LinkedList (eficiente en inserciones/borrados, acceso m\u00e1s lento por \u00edndice).</p>  List  <p>Registro de asistencia en clase \u2192 los alumnos se almacenan en el orden en que se pasan lista, y puede haber nombres repetidos.</p> <p>Historial de navegaci\u00f3n en un navegador \u2192 se guardan URLs en orden de visita, pudiendo repetirlas.</p> <p>Lista de tareas pendientes (To-Do) \u2192 se a\u00f1aden nuevas tareas y se accede r\u00e1pido por posici\u00f3n (ej: \u201cla tercera tarea\u201d).</p> <p>List</p> <p>Operaciones List</p>"},{"location":"Bloque1_POO/03_genericidad_contenedores/#set","title":"Set","text":"<p>Un Set es una colecci\u00f3n que no permite elementos duplicados y no mantiene orden posicional. Implementaciones comunes: HashSet (sin orden, alto rendimiento), LinkedHashSet (mantiene orden de inserci\u00f3n) y TreeSet (mantiene los elementos ordenados).</p>  Set  <p>Conjunto de emails registrados en un sistema \u2192 no deben existir duplicados, el orden no importa.</p> <p>Colecci\u00f3n de cartas en un juego \u2192 una carta no puede estar dos veces en la mano del jugador.</p> <p>Lista de alumnos que han entregado un trabajo \u2192 se garantiza unicidad, sin importar el orden.</p> <p>Set</p> <p>Operaciones Set</p>"},{"location":"Bloque1_POO/03_genericidad_contenedores/#map","title":"Map","text":"<p>Un Map asocia claves \u00fanicas con valores, sin admitir claves duplicadas. Permite obtener vistas de claves, valores y pares clave\u2013valor. Implementaciones comunes: HashMap (r\u00e1pido, sin orden), LinkedHashMap (orden de inserci\u00f3n) y TreeMap (ordenado por claves).</p>  Map  <p>Diccionario espa\u00f1ol\u2013ingl\u00e9s \u2192 cada palabra (clave) se asocia a una traducci\u00f3n (valor).</p> <p>Agenda telef\u00f3nica \u2192 cada persona (clave) tiene un n\u00famero de tel\u00e9fono (valor).</p> <p>Notas de los alumnos en una asignatura \u2192 scada matr\u00edcula (clave) corresponde a una calificaci\u00f3n (valor).</p> <p>Map</p> <p>Operaciones Map</p>"},{"location":"Bloque1_POO/03_genericidad_contenedores/#queue","title":"Queue","text":"<p>Una Queue es una colecci\u00f3n que sigue la sem\u00e1ntica FIFO (primero en entrar, primero en salir). Se usa para gestionar elementos en orden de llegada. Se implementa habitualmente con LinkedList o con clases espec\u00edficas como PriorityQueue.</p>  Queue  <p>Cola de impresi\u00f3n en una oficina \u2192 el primer documento enviado es el primero en imprimirse.</p> <p>Atenci\u00f3n al cliente en un banco \u2192 los clientes son atendidos en el orden de llegada.</p> <p>Procesamiento de tareas en un sistema operativo \u2192 las tareas se ejecutan siguiendo la pol\u00edtica FIFO.</p> <p>Queue</p> <p>Operaciones Queue</p>"},{"location":"Bloque1_POO/03_genericidad_contenedores/#deque","title":"Deque","text":"<p>Un Deque (Double Ended Queue) permite insertar y eliminar elementos por ambos extremos. Puede funcionar como cola (FIFO) o como pila (LIFO). Implementaciones comunes: ArrayDeque y LinkedList.</p>  Deque  <p>Navegador web con botones Atr\u00e1s y Adelante \u2192 permite acceder tanto al historial previo como al siguiente.</p> <p>Gesti\u00f3n de un buffer de mensajes \u2192 se insertan por un extremo y se eliminan por ambos, seg\u00fan la necesidad.</p> <p>Implementaci\u00f3n de un algoritmo de backtracking (ej. resolver un laberinto) \u2192 puede comportarse como pila (LIFO) o como cola (FIFO).</p> <p>Deque</p> <p>Operaciones Deque</p> <p>Comparativa de colecciones en Java</p>"},{"location":"Bloque1_POO/03_genericidad_contenedores/#jerarquia-de-interfaces-de-colecciones","title":"Jerarqu\u00eda de Interfaces de Colecciones","text":""},{"location":"Bloque1_POO/03_genericidad_contenedores/#collectiont","title":"<code>Collection&lt;T&gt;</code>","text":"<p>Interfaz base para la mayor\u00eda de contenedores.   </p> <p>Operaciones principales:  </p> <ul> <li>add, addAll \u2192 a\u00f1adir elementos.    </li> <li>remove, removeAll, clear \u2192 eliminar elementos.    </li> <li>size, contains, containsAll \u2192 consultas de estado.    </li> <li>iterator() \u2192 obtener un iterador para recorrer la colecci\u00f3n.  </li> </ul>"},{"location":"Bloque1_POO/03_genericidad_contenedores/#iteradores","title":"Iteradores","text":"<p>Los iteradores son objetos que permiten recorrer un contenedor. - Pueden acceder, eliminar o a\u00f1adir elementos.   - No se permiten modificaciones externas mientras un iterador recorre la colecci\u00f3n.    </p> <p>M\u00e9todos b\u00e1sicos de <code>Iterator&lt;T&gt;</code>:  </p> <ul> <li><code>hasNext()</code> </li> <li><code>next()</code> </li> <li><code>remove()</code> </li> </ul>"},{"location":"Bloque1_POO/03_genericidad_contenedores/#interfaces-derivadas-de-collection","title":"Interfaces derivadas de Collection","text":""},{"location":"Bloque1_POO/03_genericidad_contenedores/#sett-y-sortedsett","title":"<code>Set&lt;T&gt;</code> y <code>SortedSet&lt;T&gt;</code>","text":"<ul> <li><code>Set</code>: no admite elementos repetidos.    </li> <li> <p><code>SortedSet</code>: adem\u00e1s mantiene los elementos ordenados.  </p> </li> <li> <p>Los objetos deben implementar <code>Comparable&lt;T&gt;</code> o suministrar un <code>Comparator&lt;T&gt;</code>.    </p> </li> <li>Orden natural: <code>compareTo</code>.    </li> <li>Orden alternativo: <code>Comparator&lt;T&gt;</code> mediante <code>compare(a,b)</code>.  </li> </ul>"},{"location":"Bloque1_POO/03_genericidad_contenedores/#listt","title":"<code>List&lt;T&gt;</code>","text":"<ul> <li>A\u00f1ade propiedad posicional a los elementos.    </li> <li>Operaciones t\u00edpicas: <code>add(i,e)</code>, <code>remove(i)</code>, <code>get(i)</code>, <code>set(i,e)</code>.    </li> <li>Puede obtener un ListIterator que ampl\u00eda las funcionalidades de <code>Iterator</code>.    </li> </ul>"},{"location":"Bloque1_POO/03_genericidad_contenedores/#mapkv-y-sortedmapkv","title":"<code>Map&lt;K,V&gt;</code> y <code>SortedMap&lt;K,V&gt;</code>","text":"<ul> <li>Colecci\u00f3n de pares clave-valor.    </li> <li>No admite claves repetidas.    </li> <li>Permite obtener:  </li> <li>Conjunto de claves (<code>keySet()</code>).    </li> <li>Colecci\u00f3n de valores (<code>values()</code>).    </li> <li>Conjunto de pares (<code>entrySet()</code>).    </li> </ul> <p><code>SortedMap&lt;K,V&gt;</code>: garantiza que las claves est\u00e1n ordenadas.  </p>"},{"location":"Bloque1_POO/03_genericidad_contenedores/#implementaciones-de-contenedores-en-java","title":"Implementaciones de Contenedores en Java","text":"<ul> <li>List </li> <li><code>LinkedList&lt;T&gt;</code> \u2192 lista doblemente enlazada.    </li> <li> <p><code>ArrayList&lt;T&gt;</code> \u2192 vector din\u00e1mico con acceso r\u00e1pido por posici\u00f3n.    </p> </li> <li> <p>Set / SortedSet </p> </li> <li><code>HashSet&lt;T&gt;</code> \u2192 basado en tabla hash (alto rendimiento).    </li> <li><code>LinkedHashSet&lt;T&gt;</code> \u2192 mantiene el orden de inserci\u00f3n.    </li> <li> <p><code>TreeSet&lt;T&gt;</code> \u2192 mantiene orden natural o definido por comparador.    </p> </li> <li> <p>Map / SortedMap </p> </li> <li><code>HashMap&lt;K,V&gt;</code> \u2192 tabla hash.    </li> <li><code>LinkedHashMap&lt;K,V&gt;</code> \u2192 mantiene orden de inserci\u00f3n.    </li> <li><code>TreeMap&lt;K,V&gt;</code> \u2192 mantiene las claves ordenadas.    </li> </ul>"},{"location":"Bloque1_POO/03_genericidad_contenedores/#requisitos-de-implementacion","title":"Requisitos de Implementaci\u00f3n","text":"<ul> <li><code>equals()</code> debe estar correctamente redefinido para el buen funcionamiento de <code>contains</code> y <code>remove</code>.    </li> <li><code>hashCode()</code> debe ser consistente con <code>equals()</code>.    </li> <li><code>Comparable&lt;T&gt;</code> o <code>Comparator&lt;T&gt;</code> se requieren para contenedores ordenados (<code>TreeSet</code>, <code>TreeMap</code>).    </li> </ul> <p>Reglas: - Si dos objetos son iguales seg\u00fan <code>equals()</code>, deben devolver el mismo <code>hashCode()</code>. - <code>hashCode()</code> se puede implementar sumando los <code>hashCode()</code> de los atributos usados en <code>equals()</code>.    </p> <p>Iteradores</p> <p>Comparadores</p>"},{"location":"Bloque1_POO/03_genericidad_contenedores/#comparativa-de-colecciones-en-java","title":"Comparativa de colecciones en java","text":"Colecci\u00f3n Permite duplicados Orden Clave-Valor Acceso t\u00edpico Implementaciones comunes List S\u00ed Mantiene orden de inserci\u00f3n, acceso posicional por \u00edndice No Acceso r\u00e1pido por \u00edndice en <code>ArrayList</code>; eficiente en inserciones/borrados con <code>LinkedList</code> ArrayList, LinkedList Set No No garantiza orden (<code>HashSet</code>), orden de inserci\u00f3n (<code>LinkedHashSet</code>), orden natural o por comparador (<code>TreeSet</code>) No B\u00fasqueda de pertenencia (<code>contains</code>) HashSet, LinkedHashSet, TreeSet Map Claves: NoValores: S\u00ed No garantiza orden (<code>HashMap</code>), orden de inserci\u00f3n (<code>LinkedHashMap</code>), orden natural de claves (<code>TreeMap</code>) S\u00ed Acceso r\u00e1pido por clave HashMap, LinkedHashMap, TreeMap Queue S\u00ed FIFO (primero en entrar, primero en salir) No Inserci\u00f3n y extracci\u00f3n en un extremo LinkedList, PriorityQueue Deque S\u00ed FIFO o LIFO (ambos extremos) No Inserci\u00f3n y extracci\u00f3n en ambos extremos ArrayDeque, LinkedList"},{"location":"Bloque1_POO/03_iteradores/","title":"Iteradores","text":""},{"location":"Bloque1_POO/03_iteradores/#motivacion-y-objetivo","title":"Motivaci\u00f3n y objetivo","text":"<p>Los iteradores permiten recorrer los elementos de una colecci\u00f3n de manera uniforme y segura, sin necesidad de conocer los detalles de su estructura interna. Constituyen una abstracci\u00f3n que separa la l\u00f3gica de acceso de la implementaci\u00f3n del contenedor.</p> <p>Frente al uso de bucles indexados, los iteradores reducen errores, simplifican el c\u00f3digo y permiten recorrer cualquier colecci\u00f3n de forma homog\u00e9nea.</p>"},{"location":"Bloque1_POO/03_iteradores/#conceptos-basicos-iterable-e-iterator","title":"Conceptos b\u00e1sicos: Iterable e Iterator","text":"<p>En Java, la interfaz <code>Iterable&lt;T&gt;</code> define el contrato que permite recorrer los elementos de una colecci\u00f3n. Contiene un \u00fanico m\u00e9todo:</p> <pre><code>Iterator&lt;T&gt; iterator();\n</code></pre> <p>El objeto que devuelve este m\u00e9todo es una instancia de una clase que implementa la interfaz <code>Iterator&lt;E&gt;</code>, que define los m\u00e9todos necesarios para recorrer una colecci\u00f3n:</p> <pre><code>boolean hasNext();\nE next();\nvoid remove();\n</code></pre> <ul> <li>Iterable representa algo que se puede recorrer.  </li> <li>Iterator representa el mecanismo que permite recorrerlo.</li> </ul> <p>La colecci\u00f3n implementa <code>Iterable</code>, y a trav\u00e9s de su m\u00e9todo <code>iterator()</code> produce un <code>Iterator</code> que gestiona la secuencia de acceso a los elementos.</p>"},{"location":"Bloque1_POO/03_iteradores/#formas-de-iterar-colecciones","title":"Formas de iterar colecciones","text":"<p>En Java existen distintas formas de iterar una colecci\u00f3n:</p>"},{"location":"Bloque1_POO/03_iteradores/#usando-iterator","title":"Usando Iterator","text":"<p>Es la forma m\u00e1s expl\u00edcita de recorrer una colecci\u00f3n. Se obtiene un objeto <code>Iterator</code> y se usan sus m\u00e9todos <code>hasNext()</code> y <code>next()</code>:</p> <pre><code>Iterator&lt;String&gt; it = lista.iterator();\nwhile (it.hasNext()) {\n    System.out.println(it.next());\n}\n</code></pre>"},{"location":"Bloque1_POO/03_iteradores/#usando-bucle-for-tradicional","title":"Usando bucle for tradicional","text":"<p>Se puede usar el <code>Iterator</code> dentro de un bucle for cl\u00e1sico, inicializando, comprobando la condici\u00f3n y avanzando manualmente.</p>"},{"location":"Bloque1_POO/03_iteradores/#usando-for-each-enhanced-for","title":"Usando for-each (enhanced for)","text":"<p>El bucle <code>for-each</code> permite recorrer cualquier objeto que implemente <code>Iterable</code> de forma m\u00e1s legible:</p> <pre><code>for (String elemento : lista) {\n    System.out.println(elemento);\n}\n</code></pre> <p>Es la forma m\u00e1s com\u00fan y legible de iterar cuando no se necesita eliminar o modificar elementos durante la iteraci\u00f3n.</p>"},{"location":"Bloque1_POO/03_iteradores/#cuando-usar-cada-forma","title":"Cu\u00e1ndo usar cada forma","text":"<ul> <li>for-each: preferible por claridad cuando no se requiere eliminar elementos.  </li> <li>Iterator: cuando se va a eliminar o modificar elementos de la colecci\u00f3n durante el recorrido.  </li> <li>for tradicional: \u00fatil en casos concretos donde se necesita un control m\u00e1s detallado.</li> </ul>"},{"location":"Bloque1_POO/03_iteradores/#casos-particulares-de-colecciones","title":"Casos particulares de colecciones","text":""},{"location":"Bloque1_POO/03_iteradores/#list-y-set","title":"List y Set","text":"<p>Las listas (<code>List</code>) mantienen el orden de inserci\u00f3n y permiten elementos duplicados. Su iteraci\u00f3n respeta ese orden. Los conjuntos (<code>Set</code>) no garantizan un orden determinado (salvo en implementaciones espec\u00edficas como <code>LinkedHashSet</code> o <code>TreeSet</code>).</p>"},{"location":"Bloque1_POO/03_iteradores/#map","title":"Map","text":"<p>Los mapas no implementan <code>Iterable</code> directamente, pero ofrecen vistas iterables a trav\u00e9s de sus m\u00e9todos:</p> <ul> <li><code>keySet()</code> \u2014 devuelve un conjunto con las claves.  </li> <li><code>values()</code> \u2014 devuelve una colecci\u00f3n con los valores.  </li> <li><code>entrySet()</code> \u2014 devuelve un conjunto de pares clave-valor (<code>Map.Entry&lt;K,V&gt;</code>).</li> </ul> <p>Estas vistas permiten recorrer las entradas del mapa usando <code>for-each</code> o <code>Iterator</code>.</p>"},{"location":"Bloque1_POO/03_iteradores/#listiterator","title":"ListIterator","text":"<p>Para listas, Java ofrece una interfaz m\u00e1s avanzada: <code>ListIterator&lt;E&gt;</code>. Permite recorrer en ambos sentidos, insertar o eliminar elementos y conocer la posici\u00f3n actual en la lista.</p>"},{"location":"Bloque1_POO/03_iteradores/#eliminacion-segura-durante-la-iteracion","title":"Eliminaci\u00f3n segura durante la iteraci\u00f3n","text":"<p>Modificar una colecci\u00f3n mientras se recorre con un <code>Iterator</code> requiere cuidado. Si se usa directamente un m\u00e9todo del contenedor (por ejemplo, <code>list.remove()</code>), puede producirse una excepci\u00f3n <code>ConcurrentModificationException</code>.</p> <p>Para eliminar elementos de forma segura, se debe usar el m\u00e9todo <code>remove()</code> del propio iterador, que elimina el \u00faltimo elemento devuelto por <code>next()</code>:</p> <pre><code>Iterator&lt;String&gt; it = lista.iterator();\nwhile (it.hasNext()) {\n    String elemento = it.next();\n    if (elemento.isEmpty()) {\n        it.remove();\n    }\n}\n</code></pre>"},{"location":"Bloque1_POO/03_iteradores/#buenas-practicas-y-recomendaciones","title":"Buenas pr\u00e1cticas y recomendaciones","text":"<ul> <li>Usar for-each cuando solo se necesita leer los elementos.  </li> <li>Usar Iterator si se van a eliminar elementos durante el recorrido.  </li> <li>Evitar modificar la colecci\u00f3n directamente mientras se itera sobre ella.  </li> <li>Mantener los bucles cortos y claros.  </li> <li>Elegir la forma de iteraci\u00f3n m\u00e1s adecuada seg\u00fan el tipo de colecci\u00f3n y la operaci\u00f3n deseada.</li> </ul>"},{"location":"Bloque1_POO/03_iteradores/#iterables-personalizados","title":"Iterables personalizados","text":"<p>Cualquier clase puede implementar la interfaz <code>Iterable&lt;T&gt;</code> para permitir que sus instancias sean recorridas mediante un <code>for-each</code>.</p> <p>Esto resulta \u00fatil cuando se desea que los usuarios de una clase puedan iterar sobre sus elementos internos de forma natural.</p> <pre><code>class Contenedor implements Iterable&lt;Elemento&gt; {\n    private List&lt;Elemento&gt; elementos;\n\n    public Iterator&lt;Elemento&gt; iterator() {\n        return elementos.iterator();\n    }\n}\n</code></pre> <p>Un <code>Iterable</code> debe proporcionar iteradores independientes (cada llamada a <code>iterator()</code> deber\u00eda devolver un nuevo objeto) y, si es posible, definir un orden de recorrido coherente.</p>"},{"location":"Bloque1_POO/03_iteradores/#resumen-conceptual-iterable-iterator-comparable-y-comparator","title":"Resumen conceptual: Iterable, Iterator, Comparable y Comparator","text":"Elemento Tipo de interfaz Qu\u00e9 representa D\u00f3nde se implementa M\u00e9todo(s) principal(es) Prop\u00f3sito Ejemplo de uso <code>Iterable&lt;T&gt;</code> De capacidad / cualidad La colecci\u00f3n puede ser recorrida En las clases de colecci\u00f3n (<code>List</code>, <code>Set</code>, <code>Queue</code>, etc.) <code>iterator()</code> Producir un iterador que recorra sus elementos <code>lista.iterator()</code> devuelve un <code>Iterator</code> <code>Iterator&lt;E&gt;</code> De comportamiento funcional El objeto que realiza el recorrido sobre los elementos En clases internas de las colecciones <code>hasNext()</code>, <code>next()</code>, <code>remove()</code> Recorrer una colecci\u00f3n elemento a elemento <code>it.hasNext()</code> / <code>it.next()</code> <code>Comparable&lt;T&gt;</code> De comportamiento funcional El objeto sabe compararse consigo mismo En la propia clase del objeto <code>compareTo(T o)</code> Definir el orden natural de los objetos <code>Collections.sort(lista)</code> usa <code>compareTo()</code> <code>Comparator&lt;T&gt;</code> De comportamiento funcional externo Un objeto que compara dos instancias Fuera de la clase (otra clase o expresi\u00f3n lambda) <code>compare(T o1, T o2)</code> Definir \u00f3rdenes alternativos sin modificar la clase <code>Collections.sort(lista, comparador)</code>"},{"location":"Bloque1_POO/03_iteradores/#en-resumen-conceptual","title":"En resumen conceptual","text":"<ul> <li><code>Iterable</code> define una capacidad: la de poder ser recorrido.  </li> <li><code>Iterator</code> define un comportamiento: c\u00f3mo se realiza ese recorrido.  </li> <li><code>Comparable</code> define un comportamiento interno: c\u00f3mo un objeto se compara consigo mismo.  </li> <li><code>Comparator</code> define un comportamiento externo: c\u00f3mo comparar objetos seg\u00fan un criterio distinto.</li> </ul>"},{"location":"Bloque1_POO/03_iteradores_comparadores/","title":"Resumen conceptual: Iterable, Iterator, Comparable y Comparator","text":"Elemento Tipo de interfaz Qu\u00e9 representa D\u00f3nde se implementa M\u00e9todo(s) principal(es) Prop\u00f3sito Ejemplo de uso <code>Iterable&lt;T&gt;</code> De capacidad / cualidad La colecci\u00f3n puede ser recorrida En las clases de colecci\u00f3n (<code>List</code>, <code>Set</code>, <code>Queue</code>, etc.) <code>iterator()</code> Producir un iterador que recorra sus elementos <code>lista.iterator()</code> devuelve un <code>Iterator</code> <code>Iterator&lt;E&gt;</code> De comportamiento funcional El objeto que realiza el recorrido sobre los elementos En clases internas de las colecciones <code>hasNext()</code>, <code>next()</code>, <code>remove()</code> Recorrer una colecci\u00f3n elemento a elemento <code>it.hasNext()</code> / <code>it.next()</code> <code>Comparable&lt;T&gt;</code> De comportamiento funcional El objeto sabe compararse consigo mismo En la propia clase del objeto <code>compareTo(T o)</code> Definir el orden natural de los objetos <code>Collections.sort(lista)</code> usa <code>compareTo()</code> <code>Comparator&lt;T&gt;</code> De comportamiento funcional externo Un objeto que compara dos instancias Fuera de la clase (otra clase o expresi\u00f3n lambda) <code>compare(T o1, T o2)</code> Definir \u00f3rdenes alternativos sin modificar la clase <code>Collections.sort(lista, comparador)</code>"},{"location":"Bloque1_POO/03_iteradores_comparadores/#en-resumen-conceptual","title":"En resumen conceptual","text":"<ul> <li><code>Iterable</code> define una capacidad: la de poder ser recorrido.  </li> <li><code>Iterator</code> define un comportamiento: c\u00f3mo se realiza ese recorrido.  </li> <li><code>Comparable</code> define un comportamiento interno: c\u00f3mo un objeto se compara consigo mismo.  </li> <li><code>Comparator</code> define un comportamiento externo: c\u00f3mo comparar objetos seg\u00fan un criterio distinto.</li> </ul>"},{"location":"Bloque1_POO/03_java_collections_framework/","title":"Java Collections Framework (JCF)","text":"<p>Las colecciones en Java forman parte del framework de colecciones de Java, conocido como Java Collections Framework (JCF). Este framework est\u00e1 incluido en el paquete est\u00e1ndar de Java, espec\u00edficamente en el paquete <code>java.util</code>. Fue introducido en la versi\u00f3n 1.2 de Java (Java 2) y ofrece un conjunto de interfaces, clases y m\u00e9todos para almacenar y manipular grupos de objetos (tambi\u00e9n llamados colecciones).</p> <p></p>"},{"location":"Bloque1_POO/03_java_collections_framework/#componentes-del-java-collections-framework","title":"Componentes del Java Collections Framework","text":""},{"location":"Bloque1_POO/03_java_collections_framework/#interfaces","title":"Interfaces","text":"<p>Las interfaces principales del framework son:</p> <ul> <li> <p>Collection \u2192 La interfaz ra\u00edz de la mayor\u00eda de las colecciones.   Define las operaciones b\u00e1sicas comunes: a\u00f1adir, eliminar, recorrer o consultar elementos.</p> </li> <li> <p>List \u2192 Extiende <code>Collection</code>. Define colecciones ordenadas que permiten elementos duplicados   (por ejemplo, <code>ArrayList</code>, <code>Vector</code>, <code>LinkedList</code>).</p> </li> <li> <p>Set \u2192 Extiende <code>Collection</code>. Define colecciones que no permiten elementos duplicados   (por ejemplo, <code>HashSet</code>, <code>LinkedHashSet</code>, <code>TreeSet</code>).</p> </li> <li> <p>SortedSet \u2192 Extiende <code>Set</code>. Mantiene los elementos ordenados seg\u00fan el orden natural o un comparador.  </p> </li> <li> <p>NavigableSet \u2192 Extiende <code>SortedSet</code>. Permite obtener elementos mayores o menores al dado, de forma eficiente.</p> </li> <li> <p>Queue \u2192 Extiende <code>Collection</code>. Define colecciones en las que los elementos se manejan en un orden espec\u00edfico,   como en una cola (por ejemplo, <code>LinkedList</code>, <code>PriorityQueue</code>).</p> </li> </ul>"},{"location":"Bloque1_POO/03_java_collections_framework/#clases-de-implementacion","title":"Clases de implementaci\u00f3n","text":"<p>Clases concretas que implementan las interfaces principales:</p> <ul> <li><code>ArrayList</code>, <code>Vector</code>, <code>LinkedList</code> \u2192 para List.  </li> <li><code>HashSet</code>, <code>LinkedHashSet</code>, <code>TreeSet</code> \u2192 para Set.  </li> <li><code>LinkedList</code>, <code>PriorityQueue</code> \u2192 para Queue.</li> </ul>  Orientaci\u00f3n a Interfaces  <p>Los atributos de datos que hacen referencia a contenedores deben declararse usando tipos de datos propios de interfaces y no de clases.</p> <p> Por ejemplo, hacer declaraciones del tipo:</p> <p>private List = new ArrayList&lt;&gt;(); <p>Y no del tipo:</p> <p>private ArrayList = new ArrayList&lt;&gt;();"},{"location":"Bloque1_POO/03_java_collections_framework/#notas-sobre-la-jerarquia","title":"Notas sobre la jerarqu\u00eda","text":"<ul> <li>Las l\u00edneas continuas del diagrama indican que una interfaz extiende otra (<code>extends</code>).  </li> <li>Las l\u00edneas punteadas indican que una clase implementa una interfaz (<code>implements</code>).  </li> <li><code>Collection</code> es la interfaz base de la jerarqu\u00eda, mientras que <code>List</code>, <code>Set</code> y <code>Queue</code> son sus subinterfaces principales.  </li> <li><code>Map</code> no hereda de <code>Collection</code>, pero forma parte del Java Collections Framework.</li> </ul>"},{"location":"Bloque1_POO/03_java_collections_framework/#algoritmos","title":"Algoritmos","text":"<p>El framework tambi\u00e9n provee m\u00e9todos para realizar operaciones comunes sobre colecciones, tales como:</p> <ul> <li>B\u00fasqueda.  </li> <li>Ordenaci\u00f3n.  </li> <li>Mezcla o manipulaci\u00f3n de elementos.  </li> </ul> <p>Estos m\u00e9todos est\u00e1n disponibles en la clase de utilidades <code>Collections</code> del paquete <code>java.util</code>.</p>"},{"location":"Bloque1_POO/03_operaciones/","title":"Operaciones sobre colecciones en Java","text":""},{"location":"Bloque1_POO/03_operaciones/#list-listas","title":"List (Listas)","text":"<p>Una lista es una colecci\u00f3n ordenada que permite elementos duplicados y acceso por \u00edndice.</p> <p>Operaciones est\u00e1ndar - <code>add(E e)</code>: a\u00f1ade un elemento al final de la lista. - <code>get(int index)</code>: devuelve el elemento en una posici\u00f3n espec\u00edfica (por \u00edndice). - <code>set(int index, E e)</code>: reemplaza el elemento en la posici\u00f3n dada. - <code>remove(int index)</code>: elimina el elemento en la posici\u00f3n especificada. - <code>size()</code>: devuelve el n\u00famero de elementos en la lista. - <code>isEmpty()</code>: verifica si la lista est\u00e1 vac\u00eda. - <code>contains(Object o)</code>: verifica si la lista contiene un elemento espec\u00edfico. - <code>indexOf(Object o)</code>: devuelve el \u00edndice de la primera aparici\u00f3n de un elemento (o <code>-1</code> si no se encuentra). - <code>lastIndexOf(Object o)</code>: devuelve el \u00edndice de la \u00faltima aparici\u00f3n de un elemento. - <code>clear()</code>: elimina todos los elementos de la lista.</p> <p>Operaciones opcionales - <code>add(int index, E e)</code>: inserta un elemento en una posici\u00f3n espec\u00edfica. - <code>remove(Object o)</code>: elimina la primera ocurrencia de un elemento si est\u00e1 presente. - <code>subList(int fromIndex, int toIndex)</code>: devuelve una vista de la lista entre dos \u00edndices. - <code>iterator()</code>: devuelve un iterador sobre los elementos de la lista.</p>"},{"location":"Bloque1_POO/03_operaciones/#set-conjuntos","title":"Set (Conjuntos)","text":"<p>Un conjunto es una colecci\u00f3n que no permite duplicados y no garantiza el orden de los elementos.</p> <p>Operaciones est\u00e1ndar - <code>add(E e)</code>: a\u00f1ade un elemento al conjunto si no est\u00e1 presente. - <code>contains(Object o)</code>: verifica si el conjunto contiene un elemento. - <code>remove(Object o)</code>: elimina un elemento si est\u00e1 presente. - <code>size()</code>: devuelve el n\u00famero de elementos en el conjunto. - <code>isEmpty()</code>: verifica si el conjunto est\u00e1 vac\u00edo. - <code>iterator()</code>: devuelve un iterador sobre los elementos del conjunto.</p> <p>Operaciones opcionales - <code>addAll(Collection&lt;? extends E&gt; c)</code>: a\u00f1ade todos los elementos de la colecci\u00f3n dada al conjunto, si no est\u00e1n presentes. - <code>removeAll(Collection&lt;?&gt; c)</code>: elimina todos los elementos presentes en la colecci\u00f3n dada. - <code>retainAll(Collection&lt;?&gt; c)</code>: conserva solo los elementos que est\u00e1n en el conjunto y en la colecci\u00f3n dada. - <code>clear()</code>: elimina todos los elementos del conjunto.</p>"},{"location":"Bloque1_POO/03_operaciones/#map-mapas","title":"Map (Mapas)","text":"<p>Un mapa es una colecci\u00f3n que asocia claves a valores. No permite claves duplicadas.</p> <p>Operaciones est\u00e1ndar - <code>put(K key, V value)</code>: a\u00f1ade una asociaci\u00f3n clave-valor al mapa. - <code>get(Object key)</code>: devuelve el valor asociado con la clave especificada. - <code>remove(Object key)</code>: elimina la asociaci\u00f3n de la clave especificada. - <code>containsKey(Object key)</code>: verifica si el mapa contiene una clave especificada. - <code>containsValue(Object value)</code>: verifica si el mapa contiene un valor especificado. - <code>size()</code>: devuelve el n\u00famero de asociaciones clave-valor en el mapa. - <code>isEmpty()</code>: verifica si el mapa est\u00e1 vac\u00edo. - <code>clear()</code>: elimina todas las asociaciones del mapa.</p> <p>Operaciones opcionales - <code>putIfAbsent(K key, V value)</code>: a\u00f1ade la asociaci\u00f3n si la clave no est\u00e1 ya presente en el mapa. - <code>putAll(Map&lt;? extends K, ? extends V&gt; m)</code>: copia todas las asociaciones del mapa especificado a este mapa. - <code>replace(K key, V value)</code>: reemplaza el valor asociado a la clave especificada si est\u00e1 presente. - <code>entrySet()</code>: devuelve una vista de conjunto de las asociaciones clave-valor del mapa. - <code>keySet()</code>: devuelve una vista de conjunto de las claves contenidas en este mapa. - <code>values()</code>: devuelve una colecci\u00f3n de los valores contenidos en el mapa.</p>"},{"location":"Bloque1_POO/03_operaciones/#queue-colas","title":"Queue (Colas)","text":"<p>Una cola es una colecci\u00f3n que opera con el principio FIFO (First-In, First-Out).</p> <p>Operaciones est\u00e1ndar - <code>offer(E e)</code>: inserta un elemento en la cola; devuelve <code>false</code> si no puede ser insertado. - <code>poll()</code>: devuelve y elimina el primer elemento de la cola. Devuelve <code>null</code> si est\u00e1 vac\u00eda. - <code>peek()</code>: devuelve pero no elimina el primer elemento de la cola. Devuelve <code>null</code> si est\u00e1 vac\u00eda. - <code>isEmpty()</code>: verifica si la cola est\u00e1 vac\u00eda. - <code>size()</code>: devuelve el n\u00famero de elementos en la cola.</p> <p>Operaciones opcionales - <code>add(E e)</code>: a\u00f1ade un elemento a la cola. Lanza una excepci\u00f3n si no puede ser a\u00f1adido. - <code>remove()</code>: devuelve y elimina el primer elemento. Lanza una excepci\u00f3n si la cola est\u00e1 vac\u00eda. - <code>element()</code>: devuelve pero no elimina el primer elemento. Lanza una excepci\u00f3n si la cola est\u00e1 vac\u00eda.</p>"},{"location":"Bloque1_POO/03_operaciones/#deque-deques","title":"Deque (Deques)","text":"<p>Un deque (Double Ended Queue) es una cola que permite a\u00f1adir y eliminar elementos desde ambos extremos.</p> <p>Operaciones est\u00e1ndar - <code>addFirst(E e)</code>: inserta un elemento al inicio del deque. - <code>addLast(E e)</code>: inserta un elemento al final del deque. - <code>removeFirst()</code>: elimina y devuelve el primer elemento del deque. - <code>removeLast()</code>: elimina y devuelve el \u00faltimo elemento del deque. - <code>getFirst()</code>: devuelve pero no elimina el primer elemento. Lanza excepci\u00f3n si est\u00e1 vac\u00edo. - <code>getLast()</code>: devuelve pero no elimina el \u00faltimo elemento. Lanza excepci\u00f3n si est\u00e1 vac\u00edo.</p> <p>Operaciones opcionales - <code>offerFirst(E e)</code>: intenta a\u00f1adir un elemento al principio sin lanzar excepciones. - <code>offerLast(E e)</code>: intenta a\u00f1adir un elemento al final sin lanzar excepciones. - <code>pollFirst()</code>: devuelve y elimina el primer elemento, o <code>null</code> si el deque est\u00e1 vac\u00edo. - <code>pollLast()</code>: devuelve y elimina el \u00faltimo elemento, o <code>null</code> si el deque est\u00e1 vac\u00edo. - <code>peekFirst()</code>: devuelve pero no elimina el primer elemento, o <code>null</code> si el deque est\u00e1 vac\u00edo. - <code>peekLast()</code>: devuelve pero no elimina el \u00faltimo elemento, o <code>null</code> si el deque est\u00e1 vac\u00edo. - <code>push(E e)</code>: inserta un elemento al frente (equivalente a <code>addFirst()</code>). - <code>pop()</code>: elimina y devuelve el primer elemento (equivalente a <code>removeFirst()</code>).</p>"},{"location":"Bloque2_Eventos_GUI/01_codigos1/","title":"Eventos y clases anidadas  -- s7d1","text":""},{"location":"Bloque2_Eventos_GUI/01_codigos1/#definiciones-y-ejemplos-ilustrativos","title":"Definiciones y ejemplos ilustrativos","text":""},{"location":"Bloque2_Eventos_GUI/01_codigos1/#eventos","title":"Eventos","text":""},{"location":"Bloque2_Eventos_GUI/01_codigos2/","title":"Eventos y clases anidadas   -- s7d2","text":""},{"location":"Bloque2_Eventos_GUI/01_codigos2/#definiciones-y-ejemplos-ilustrativos","title":"Definiciones y ejemplos ilustrativos","text":""},{"location":"Bloque2_Eventos_GUI/01_codigos2/#clases-anidadas","title":"Clases anidadas","text":""},{"location":"Bloque2_Eventos_GUI/01_eventos_clases_anidadas/","title":"Introducci\u00f3n, gestores de eventos y clases anidadas","text":"<p>Contenido en construcci\u00f3n</p> <p>Ejemplos pr\u00e1cticos 1</p> <p>Ejemplos pr\u00e1cticos 2</p>"},{"location":"Bloque2_Eventos_GUI/02_interfaz_grafica/","title":"Interfaz gr\u00e1fica de usuarios","text":"<p>Contenido en construcci\u00f3n</p>"},{"location":"Bloque2_Eventos_GUI/03_componentes_layouts_navegacion/","title":"Componentes, layouts y navegaci\u00f3n","text":"<p>Contenido en construcci\u00f3n</p>"},{"location":"Bloque3_Concurrente_Distribuida/01_concurrencia_sincronizacion/","title":"Introducci\u00f3n a la concurrencia y sincronizaci\u00f3n","text":"<p>Contenido en construcci\u00f3n</p>"},{"location":"Bloque3_Concurrente_Distribuida/02_comunicacion_paralelismo/","title":"Comunicaci\u00f3n entre hilos y paralelismo","text":"<p>Contenido en construcci\u00f3n</p>"},{"location":"Bloque3_Concurrente_Distribuida/03_programacion_distribuida/","title":"Introducci\u00f3n a la programaci\u00f3n distribuida","text":"<p>Contenido en construcci\u00f3n</p>"}]}