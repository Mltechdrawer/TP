{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tecnolog\u00edas de Programaci\u00f3nBienvenido a Tecnolog\u00edas de Programaci\u00f3n","text":""},{"location":"#tecnologias-de-programacion_1","title":"\ud83d\udcf1 Tecnolog\u00edas de programaci\u00f3n","text":"<p>Tecnolog\u00edas de Programaci\u00f3n es una asignatura obligatoria del 2.\u00ba curso del Grado en Ingenier\u00eda Inform\u00e1tica (1.er semestre, 6 ECTS). Su objetivo es dotar al alumnado de una formaci\u00f3n avanzada en t\u00e9cnicas y paradigmas de programaci\u00f3n que consolidan y ampl\u00edan los conocimientos adquiridos en Fundamentos de Programaci\u00f3n I y II.</p> <p>La asignatura combina teor\u00eda, ejercicios pr\u00e1cticos y actividades de laboratorio. Se fomenta la aplicaci\u00f3n de los conceptos en el dise\u00f1o y desarrollo de programas, as\u00ed como la reflexi\u00f3n cr\u00edtica sobre las soluciones propuestas. El aprendizaje progresivo a lo largo de los tres bloques permite al estudiante adquirir competencias clave para desenvolverse en entornos profesionales donde se requieren aplicaciones modulares, interactivas y con capacidad de ejecuci\u00f3n en paralelo o distribuida.</p> <p>El curso se apoya en un enfoque pr\u00e1ctico con trabajos individuales y en equipo, reforzando la capacidad de aplicar conceptos te\u00f3ricos a problemas reales de programaci\u00f3n. Esta asignatura constituye una base s\u00f3lida para asignaturas posteriores relacionadas con la ingenier\u00eda del software, los sistemas distribuidos y la inteligencia artificial.</p> <p>Profesorado:</p> <ul> <li> <p>David Freire Obreg\u00f3n. Profesor de pr\u00e1cticas. Coordinador  </p> </li> <li> <p>Ignacio Jos\u00e9 L\u00f3pez Rodr\u00edguez.</p> </li> <li> <p>Mar\u00eda Dolores Afonso Su\u00e1rez. </p> </li> </ul> <p></p> <p> </p> <p>\u00a9 2025 Mar\u00eda Dolores Afonso Su\u00e1rez. Este material se distribuye bajo licencia Creative Commons Atribuci\u00f3n 4.0 Internacional (CC BY 4.0).</p>"},{"location":"contenidos/","title":"Contenidos","text":"<p>Tecnolog\u00edas de Programaci\u00f3n (TP) Los bloques est\u00e1n dise\u00f1ados para guiar al estudiante desde los fundamentos avanzados de POO hasta los paradigmas de programaci\u00f3n concurrente y distribuida. El objetivo es consolidar las bases de un programador profesional capaz de crear aplicaciones robustas, modulares y eficientes.</p> <p>BLOQUE 1. Conceptos avanzados de Programaci\u00f3n Orientada a Objetos revisa y ampl\u00eda los fundamentos de POO, profundizando en modularidad, herencia y reutilizaci\u00f3n de c\u00f3digo. Se abordan tambi\u00e9n la genericidad y los contenedores como ejemplos de aplicaci\u00f3n, proporcionando una visi\u00f3n madura del dise\u00f1o orientado a objetos.</p> <p>BLOQUE 2. Fundamentos de la Programaci\u00f3n Guiada por Eventos e Interfaz Gr\u00e1fica introduce el paradigma basado en eventos y el dise\u00f1o de interfaces. Se trabaja con gestores de eventos, clases anidadas, componentes y layouts para construir aplicaciones interactivas y usables.</p> <p>BLOQUE 3. Programaci\u00f3n Concurrente y Distribuida explora los principios de la concurrencia (sincronizaci\u00f3n, comunicaci\u00f3n entre hilos, paralelismo) y una introducci\u00f3n a la programaci\u00f3n distribuida, competencias clave para sistemas modernos y escalables.</p>"},{"location":"Bloque1_POO/01Java_vs_Python/","title":"Java vs Python","text":"<p>Este tema presenta una comparaci\u00f3n entre dos de los lenguajes de programaci\u00f3n m\u00e1s influyentes y utilizados en la actualidad: Java y Python. Ambos tienen fortalezas y limitaciones, y su elecci\u00f3n depende en gran medida del tipo de aplicaci\u00f3n que se desee desarrollar.</p>"},{"location":"Bloque1_POO/01Java_vs_Python/#sintaxis","title":"Sintaxis","text":"<ul> <li>Java: Su sintaxis es m\u00e1s estricta, requiere punto y coma al final de cada sentencia y la declaraci\u00f3n expl\u00edcita de tipos. Esto fuerza al programador a ser m\u00e1s detallista y riguroso desde el principio.</li> <li>Python: Su sintaxis es mucho m\u00e1s simple y legible, no necesita punto y coma ni declaraci\u00f3n previa de tipos. Esto facilita la escritura de programas cortos y prototipos r\u00e1pidos.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#tipado","title":"Tipado","text":"<ul> <li>Java: Est\u00e1ticamente tipado. Los tipos de las variables son fijos y se conocen en tiempo de compilaci\u00f3n. Esto puede reducir errores en ejecuci\u00f3n y mejorar la eficiencia.</li> <li>Python: Din\u00e1micamente tipado. El tipo de las variables puede cambiar durante la ejecuci\u00f3n. Esto proporciona mayor flexibilidad pero puede provocar errores en tiempo de ejecuci\u00f3n si no se controla bien.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#velocidad-de-ejecucion","title":"Velocidad de ejecuci\u00f3n","text":"<ul> <li>Java: Generalmente m\u00e1s r\u00e1pido porque el c\u00f3digo se compila a bytecode y se ejecuta en la JVM (Java Virtual Machine), lo que optimiza el rendimiento.</li> <li>Python: M\u00e1s lento porque se interpreta l\u00ednea por l\u00ednea. Aunque existen int\u00e9rpretes optimizados, en aplicaciones de gran escala puede ser menos eficiente.</li> </ul> <p>Velocidad de ejecuci\u00f3n</p>"},{"location":"Bloque1_POO/01Java_vs_Python/#compilacion-vs-interpretacion","title":"Compilaci\u00f3n vs Interpretaci\u00f3n","text":"<ul> <li>Java: Es un lenguaje compilado a bytecode, que despu\u00e9s se ejecuta en la JVM. Esto permite portabilidad entre sistemas y cierto equilibrio entre rendimiento y flexibilidad.</li> <li>Python: Lenguaje interpretado, ejecutado l\u00ednea por l\u00ednea. Esto facilita la depuraci\u00f3n y flexibilidad, pero penaliza la velocidad.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#uso-de-memoria-y-gestion","title":"Uso de memoria y gesti\u00f3n","text":"<ul> <li>Java: Utiliza m\u00e1s memoria, pero su gesti\u00f3n se realiza mediante un recolector de basura robusto que maneja autom\u00e1ticamente la memoria no utilizada.</li> <li>Python: Su consumo de memoria suele ser menor, aunque tambi\u00e9n implementa mecanismos de recolecci\u00f3n de basura.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#paradigma-de-programacion","title":"Paradigma de programaci\u00f3n","text":"<ul> <li>Java: Lenguaje orientado a objetos puro. Todo debe formar parte de una clase. Aunque soporta elementos funcionales (como lambdas), su enfoque central es OOP.</li> <li>Python: Soporta m\u00faltiples paradigmas: orientaci\u00f3n a objetos, programaci\u00f3n funcional y programaci\u00f3n procedimental. Es m\u00e1s flexible y adaptable.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#bibliotecas-y-ecosistema","title":"Bibliotecas y ecosistema","text":"<ul> <li>Java: Ecosistema muy s\u00f3lido, especialmente en aplicaciones empresariales, m\u00f3viles (Android) y web de gran escala.</li> <li>Python: Ecosistema con gran popularidad en ciencia de datos, inteligencia artificial y aprendizaje autom\u00e1tico. Destaca por bibliotecas como NumPy, Pandas o TensorFlow.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#portabilidad","title":"Portabilidad","text":"<ul> <li>Java: Altamente portable gracias a la JVM. El lema \u201cwrite once, run anywhere\u201d refleja esta fortaleza.</li> <li>Python: Tambi\u00e9n portable, pero en ocasiones depende de bibliotecas externas que pueden no estar disponibles en todas las plataformas.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#aplicaciones-comunes","title":"Aplicaciones comunes","text":"<ul> <li>Java: Usado en aplicaciones empresariales, m\u00f3viles (Android) y sistemas web de gran rendimiento y escala.</li> <li>Python: Predomina en ciencia de datos, inteligencia artificial, automatizaci\u00f3n de tareas y desarrollo r\u00e1pido de prototipos.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#comunidad-y-aprendizaje","title":"Comunidad y aprendizaje","text":"<ul> <li>Java: Considerado m\u00e1s dif\u00edcil de aprender al inicio por la complejidad de su sintaxis y la necesidad de definir estructuras m\u00e1s r\u00edgidas.</li> <li>Python: Lenguaje valorado como uno de los m\u00e1s accesibles para principiantes. Su sintaxis clara y directa lo convierten en una excelente opci\u00f3n para iniciarse en la programaci\u00f3n.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#resumen","title":"Resumen","text":"<ul> <li>Java: Ideal para aplicaciones grandes, multiplataforma y de alto rendimiento. Aporta robustez y seguridad.</li> <li>Python: Flexible, sencillo de aprender y con un enorme protagonismo en \u00e1reas emergentes como la IA y la ciencia de datos.</li> </ul>"},{"location":"Bloque1_POO/01_codigos/","title":"Tema \u00b7 Repaso de Programaci\u00f3n Orientada a Objetos","text":"<p>Ejemplos de c\u00f3digo </p>"},{"location":"Bloque1_POO/01_codigos/#velocidad-de-ejecucion","title":"Velocidad de ejecuci\u00f3n","text":""},{"location":"Bloque1_POO/01_codigos/#java","title":"Java","text":"<pre><code>public class VelocidadJava {\n    public static void main(String[] args) {\n        long startTime = System.nanoTime();\n\n        int suma = 0;\n        for (int i = 0; i &lt; 1000000; i++) {\n            suma += i;\n        }\n\n        long endTime = System.nanoTime();\n        System.out.println(\"Tiempo de ejecuci\u00f3n en Java: \" + (endTime - startTime) + \" nanosegundos.\");\n    }\n}\n// Java. Valores aproximados a: 3927653 nanosegundos (unos 4 milisegundos)\n</code></pre> <pre><code>import time\n\nstart_time = time.time()\n\nsuma = 0\nfor i in range(1000000):\n    suma += i\n\nend_time = time.time()\nprint(\"Tiempo de ejecuci\u00f3n en Python:\", (end_time - start_time), \"segundos\")\n\n// Python. Valores aproximados a: 0.13556790351867676 segundos (unos 135 milisegundos)\n</code></pre>"},{"location":"Bloque1_POO/01_codigos/#abstraccion","title":"Abstracci\u00f3n","text":"<pre><code>// Clase abstracta que define el comportamiento de un Vehiculo\nabstract class Vehiculo {\n    // M\u00e9todo abstracto: las subclases deben implementar c\u00f3mo encender el veh\u00edculo\n    public abstract void encender();\n\n    // M\u00e9todo abstracto: las subclases deben implementar c\u00f3mo apagar el veh\u00edculo\n    public abstract void apagar();\n\n    // M\u00e9todo com\u00fan que puede ser usado por todas las subclases\n    public void mostrarTipo() {\n        System.out.println(\"Este es un veh\u00edculo.\");\n    }\n}\n\n// Clase concreta que extiende de la clase abstracta Vehiculo\nclass Coche extends Vehiculo {\n    // Implementaci\u00f3n del m\u00e9todo encender\n    public void encender() {\n        System.out.println(\"El coche est\u00e1 encendido.\");\n    }\n\n    // Implementaci\u00f3n del m\u00e9todo apagar\n    public void apagar() {\n        System.out.println(\"El coche est\u00e1 apagado.\");\n    }\n}\n\n// Clase principal que usa la abstracci\u00f3n\npublic class Main {  \n    public static void main(String[] args) {\n        // Creamos un objeto de tipo Coche\n        Coche miCoche = new Coche();\n\n        // Usamos los m\u00e9todos abstractos implementados\n        miCoche.encender();\n        miCoche.mostrarTipo();\n        miCoche.apagar();\n\n        // Intentar crear un objeto de la clase abstracta (esto va a generar un error de compilaci\u00f3n)\n        Vehiculo miVehiculo = new Vehiculo();  // &lt;-- Esto genera un error\n    }\n}\n</code></pre>"},{"location":"Bloque1_POO/01_codigos/#encapsulamiento","title":"Encapsulamiento","text":"<pre><code>class Circulo {\n    // Al ser private solo los m\u00e9todos de esta clase pueden acceder a ellos\n    private String color;\n    private int radio;\n    private int x, y;\n\n    // El constructor permite crear objetos c\u00edrculo con valores iniciales para sus atributos \n    public Circulo(String color, int radio, int x, int y) {\n        this.color = color;\n        this.radio = radio;\n        this.x = x;\n        this.y = y;\n    }\n    // M\u00e9todos que pueden alterar  los atributos de forma controlada\n        public void cambiarTamano(int nuevoRadio) {\n        this.radio = nuevoRadio;\n    }\n\n    public void cambiarPosicion(int nuevaX, int nuevaY) {\n        this.x = nuevaX;\n        this.y = nuevaY;\n    }\n    // Encapsula la representaci\u00f3n del objeto\n    public void mostrar() {\n        System.out.println(\"C\u00edrculo de color \" + color + \", radio \" + radio +\n                           \", en la posici\u00f3n (\" + x + \", \" + y + \")\");\n    }\n}\n// Clase principal. Ejemplo de uso de encapsulamiento.\npublic class Main {\n    public static void main(String[] args) {\n        Circulo circulo1 = new Circulo(\"Rojo\", 50, 100, 100);\n        Circulo circulo2 = new Circulo(\"Verde\", 30, 200, 150);\n        Circulo circulo3 = new Circulo(\"Azul\", 70, 300, 250);\n\n        circulo1.mostrar();\n        circulo2.mostrar();\n        circulo3.mostrar();\n        // Solo llama a los m\u00e9todos p\u00fablicos, no le interesa como se realizan\n        circulo1.cambiarTamano(80);\n        circulo1.cambiarPosicion(150, 200);\n\n        circulo1.mostrar();\n    }\n}\n\n</code></pre>"},{"location":"Bloque1_POO/01_codigos/#herencia","title":"Herencia","text":"<pre><code>class Animal {\n    private final String nombre;\n    Animal(String nombre) { this.nombre = nombre; }\n    public void sonar() { System.out.println(nombre + \": hace un sonido gen\u00e9rico\"); }\n    public String getNombre() { return nombre; }\n}\n\nclass Perro extends Animal {\n    Perro(String nombre) { super(nombre); }\n    // Anotaci\u00f3n de un m\u00e9todo, que indica que se sobreescribe\n    @Override public void sonar() { System.out.println(getNombre() + \": \u00a1guau!\"); }\n    public void traerPelota() { System.out.println(getNombre() + \" trae la pelota\"); }\n}\n\npublic class Main { // \u2190 Aseg\u00farate de que el archivo se llame Main.java\n    public static void main(String[] args) {\n        Animal a = new Animal(\"Animal\");\n        Animal p = new Perro(\"Toby\");\n        a.sonar();\n        p.sonar();\n        if (p instanceof Perro) ((Perro) p).traerPelota();\n    }\n}\n</code></pre>"},{"location":"Bloque1_POO/01_codigos/#polimorfismo","title":"Polimorfismo","text":"<pre><code>// Superclase/abstracci\u00f3n\nabstract class Figura {\n    private final String nombre;\n    Figura(String nombre) { this.nombre = nombre; }\n\n    public String getNombre() { return nombre; }\n\n    // M\u00e9todo polim\u00f3rfico: cada subclase lo implementa a su manera\n    public abstract double area();\n\n    // Comportamiento com\u00fan que tambi\u00e9n puede sobrescribirse\n    public void dibujar() {\n        System.out.println(\"Dibujando \" + nombre + \" gen\u00e9rico\");\n    }\n}\n\n// Subclase 1: Circulo\nclass Circulo extends Figura {\n    private final double radio;\n    //Especializa la figura para un c\u00edrculo\n    Circulo(double radio) {\n        super(\"c\u00edrculo\");\n        this.radio = radio;\n    }\n    @Override public double area() { return Math.PI * radio * radio; }\n    @Override public void dibujar() { System.out.println(\"Dibujando un c\u00edrculo\"); }\n}\n\n// Subclase 2: Rect\u00e1ngulo\nclass Rectangulo extends Figura {\n    private final double ancho, alto;\n    // Especializa la figura para un rect\u00e1ngulo\n    Rectangulo(double ancho, double alto) {\n        super(\"rect\u00e1ngulo\");\n        this.ancho = ancho; this.alto = alto;\n    }\n    @Override public double area() { return ancho * alto; }\n    // Usa el dibujar() heredado si no lo sobrescribes\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        // Polimorfismo: misma referencia (Figura), distintos objetos concretos\n        Figura[] figuras = { new Circulo(2.0), new Rectangulo(3.0, 4.0) };\n\n        for (Figura f : figuras) {\n            f.dibujar();                              // despacho din\u00e1mico\n            System.out.printf(\"\u00c1rea de %s: %.2f%n\", \n                              f.getNombre(), f.area()); // llama al override adecuado\n        }\n\n        // Otra muestra de polimorfismo en un m\u00e9todo que recibe la superclase\n\n        procesar(new Circulo(5.0));       // usa procesar(Figura f)\n        procesar(new Rectangulo(2.0, 6.0)); // usa procesar(Figura f)\n        procesar(new Circulo(3.0), \"extra\"); // usa procesar(Circulo c, String msg)\n    }\n    // Polimorfismo din\u00e1mico (sobrescritura)\n    static void procesar(Figura f) {\n        // procesar se resuelve en tiempo de compilaci\u00f3n\n        System.out.println(\"Procesando \" + f.getClass().getSimpleName()\n                           + \" con \u00e1rea \" + f.area());\n                           //f.area se resuelve en tiempo de ejecuci\u00f3n\n    }\n    // Sobrecarga espec\u00edfica para Circulo\n    static void procesar(Circulo c) {\n        System.out.println(\"Procesando espec\u00edficamente un c\u00edrculo con radio \"\n                           + c.area());\n    }\n\n    // Otra sobrecarga con par\u00e1metros adicionales\n    // Esta es una sobrecarga est\u00e1tica, se decide en tiempo de compilaci\u00f3n porque los par\u00e1metros coinciden exactamente\n    static void procesar(Circulo c, String msg) {\n        System.out.println(\"Procesando c\u00edrculo con mensaje: \" + msg \n                           + \" y \u00e1rea \" + c.area());\n    }\n}\n</code></pre> \ud83d\udca1 Overrride vs Overload  <p> Override (area(), dibujar()): </p> <p> - Misma firma que en la superclase. </p> <p> - Decide en tiempo de ejecuci\u00f3n qu\u00e9 versi\u00f3n usar. </p> <p> Overload (procesar(Figura), procesar(Circulo), procesar(Circulo,String)): </p> <p> - Mismo nombre, distinta lista de par\u00e1metros. </p> <p> - Decide en tiempo de compilaci\u00f3n qu\u00e9 versi\u00f3n usar. </p>"},{"location":"Bloque1_POO/01_codigos/#clases-y-objetos","title":"Clases y objetos","text":"<pre><code>class Persona {\n    String nombre;\n    int edad;\n\n    void saludar() {\n        System.out.println(\"Hola, me llamo \" + nombre);\n    }\n}\n\n// Creaci\u00f3n de un objeto\nPersona p1 = new Persona();\np1.nombre = \"Ana\";\np1.edad = 25;\np1.saludar();\n</code></pre>"},{"location":"Bloque1_POO/01_repaso_poo/","title":"Tema \u00b7 Repaso de Programaci\u00f3n Orientada a Objetos","text":"<p>La Programaci\u00f3n Orientada a Objetos (POO) es un paradigma de programaci\u00f3n que organiza el software en torno a entidades llamadas objetos, los cuales agrupan datos y comportamientos relacionados. Este enfoque resulta fundamental en la ingenier\u00eda del software moderna y sirve como base para muchos lenguajes de programaci\u00f3n actuales, como Java, C++ o Python.</p>"},{"location":"Bloque1_POO/01_repaso_poo/#1-principios-basicos-de-la-poo","title":"1. Principios b\u00e1sicos de la POO","text":""},{"location":"Bloque1_POO/01_repaso_poo/#abstraccion","title":"Abstracci\u00f3n","text":"<p>La abstracci\u00f3n consiste en identificar las caracter\u00edsticas esenciales de una entidad del mundo real y representarlas en un modelo computacional.  </p> <p>Ejemplo Abstracci\u00f3n</p>"},{"location":"Bloque1_POO/01_repaso_poo/#encapsulacion","title":"Encapsulaci\u00f3n","text":"<p>La encapsulaci\u00f3n protege el acceso directo a los datos internos de un objeto, control\u00e1ndolo mediante m\u00e9todos definidos. Esto mejora la seguridad y reduce la dependencia entre m\u00f3dulos.  </p> <p>Ejemplo Encapsulamiento</p>"},{"location":"Bloque1_POO/01_repaso_poo/#herencia","title":"Herencia","text":"<p>La herencia permite que una clase (subclase) herede atributos y m\u00e9todos de otra (superclase). Facilita la reutilizaci\u00f3n de c\u00f3digo y la creaci\u00f3n de jerarqu\u00edas l\u00f3gicas.  </p> <p>Ejemplo Herencia</p>"},{"location":"Bloque1_POO/01_repaso_poo/#polimorfismo","title":"Polimorfismo","text":"<p>El polimorfismo permite que un mismo m\u00e9todo tenga comportamientos distintos seg\u00fan el contexto o la clase que lo implemente.  </p> <p>Ejemplo Polimorfismo</p>"},{"location":"Bloque1_POO/01_repaso_poo/#2-objetos-y-clases","title":"2. Objetos y clases","text":"<ul> <li>Clase: Es la plantilla que define las propiedades (atributos) y comportamientos (m\u00e9todos).  </li> <li>Objeto: Es una instancia concreta de una clase, que posee valores espec\u00edficos para sus atributos.  </li> </ul> <p>Ejemplo Clase y objeto</p>"},{"location":"Bloque1_POO/01_repaso_poo/#3-ventajas-de-la-poo","title":"3. Ventajas de la POO","text":"<ul> <li>Modularidad: el c\u00f3digo se organiza en componentes independientes.  </li> <li>Reutilizaci\u00f3n: se puede extender y adaptar c\u00f3digo existente sin reescribirlo.  </li> <li>Mantenibilidad: facilita la lectura, depuraci\u00f3n y evoluci\u00f3n del software.  </li> <li>Escalabilidad: permite modelar sistemas complejos con jerarqu\u00edas de clases y objetos.</li> </ul>"},{"location":"Bloque1_POO/01_repaso_poo/#4-poo-en-la-practica","title":"4. POO en la pr\u00e1ctica","text":"<p>En la actualidad, la POO se integra con otros paradigmas. Lenguajes como Java siguen una orientaci\u00f3n a objetos estricta, mientras que Python o C# permiten combinarla con enfoques funcionales y procedimentales. El repaso de estos conceptos es crucial para afrontar los siguientes temas del bloque, donde se profundizar\u00e1 en aspectos avanzados como modularidad, herencia compleja, genericidad y el uso de contenedores.</p>"},{"location":"Bloque1_POO/01_repaso_poo/#5-conclusion","title":"5. Conclusi\u00f3n","text":"<p>La Programaci\u00f3n Orientada a Objetos constituye una base s\u00f3lida para el desarrollo de software moderno. Sus principios permiten construir sistemas m\u00e1s claros, mantenibles y robustos, y son fundamentales para abordar los contenidos m\u00e1s avanzados de la asignatura.</p> <p>Java vs Python</p>"},{"location":"Bloque1_POO/02_codigos1/","title":"Modularidad, Herencia y Reusabilidad","text":""},{"location":"Bloque1_POO/02_codigos1/#definiciones-y-ejemplos-ilustrativos","title":"Definiciones y ejemplos ilustrativos","text":""},{"location":"Bloque1_POO/02_codigos1/#tipos-primitivos-paso-por-valor","title":"Tipos primitivos - paso por valor","text":"<pre><code>public class PasoPorValorPrimitivo {\n    public static void main(String[] args) {\n        int numero = 10;\n        cambiarValor(numero);\n        System.out.println(\"Valor despu\u00e9s de llamar al m\u00e9todo: \" + numero); // Imprime 10\n    }\n\n    public static void cambiarValor(int valor) {\n        valor = 20; // Esta modificaci\u00f3n no afecta a 'numero' en el m\u00e9todo main\n    }\n}\n// En los tipos de datos primitivos se pasa una copia del valor.\n</code></pre> \ud83d\udca1 Paso de par\u00e1metros <p>En los tipos de datos primitivos se pasa una copia del valor. </p>"},{"location":"Bloque1_POO/02_codigos1/#objetos-paso-por-referencia","title":"Objetos - paso por referencia","text":"<pre><code>public class PasoPorValorReferencia {\n    public static void main(String[] args) {\n        MiObjeto objeto = new MiObjeto();\n        objeto.valor = 10;\n\n        modificarObjeto(objeto);\n        System.out.println(\"Valor despu\u00e9s de llamar al m\u00e9todo: \" + objeto.valor); // Imprime 20\n    }\n\n    public static void modificarObjeto(MiObjeto obj) {\n        obj.valor = 20; // Modifica el valor del objeto original\n    }\n}\n\nclass MiObjeto {\n    int valor;\n}\n\n</code></pre> \ud83d\udca1 Paso de par\u00e1metros <p>En los objtos se pasa una copia de la referncia, por lo que ambos apuntan al mismo objeto.  Esto permite modificar el objeto original a trav\u00e9s de la referencia. </p>"},{"location":"Bloque1_POO/02_codigos1/#paso-por-referencia-ejemplo","title":"Paso por referencia. Ejemplo.","text":"<pre><code>public class ReferenciaEjemplo {\n    public static void main(String[] args) {\n        // Creamos un objeto de la clase String\n        String mensaje = \"Hola, mundo\";\n\n        // Creamos otra referencia que apunta al mismo objeto\n        String otraReferencia = mensaje;\n\n        // Mostramos el contenido de ambas referencias\n        System.out.println(\"Mensaje original: \" + mensaje);\n        System.out.println(\"Otra referencia: \" + otraReferencia);\n\n        // Modificamos la referencia 'mensaje'\n        mensaje = \"Nuevo mensaje\";\n\n        // Mostramos el contenido despu\u00e9s de la modificaci\u00f3n\n        System.out.println(\"Mensaje despu\u00e9s de modificar: \" + mensaje);\n        System.out.println(\"Contenido de otra referencia: \" + otraReferencia);\n    }\n}\n</code></pre>"},{"location":"Bloque1_POO/02_codigos1/#calculadora-secuencial","title":"Calculadora secuencial","text":"<pre><code>import java.util.Scanner;\n\npublic class CalculadoraSecuencial {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        // Solicitar el primer n\u00famero\n        System.out.println(\"Ingrese el primer n\u00famero:\");\n        double num1 = scanner.nextDouble();\n\n        // Solicitar el segundo n\u00famero\n        System.out.println(\"Ingrese el segundo n\u00famero:\");\n        double num2 = scanner.nextDouble();\n\n        // Solicitar la operaci\u00f3n a realizar\n        System.out.println(\"Ingrese la operaci\u00f3n (+, -, *, /):\");\n        char operacion = scanner.next().charAt(0);\n\n        // Variable para almacenar el resultado\n        double resultado = 0;\n\n        // Realizar la operaci\u00f3n\n        switch (operacion) {\n            case '+':\n                resultado = num1 + num2;\n                break;\n            case '-':\n                resultado = num1 - num2;\n                break;\n            case '*':\n                resultado = num1 * num2;\n                break;\n            case '/':\n                if (num2 != 0) {\n                    resultado = num1 / num2;\n                } else {\n                    System.out.println(\"Error: Divisi\u00f3n por cero no permitida.\");\n                    return;\n                }\n                break;\n            default:\n                System.out.println(\"Operaci\u00f3n no v\u00e1lida.\");\n                return;\n        }\n\n        // Mostrar el resultado\n        System.out.println(\"El resultado es: \" + resultado);\n    }\n}\n</code></pre>"},{"location":"Bloque1_POO/02_codigos1/#calculadora-orientada-a-objetos","title":"Calculadora orientada a objetos","text":"<pre><code>import java.util.Scanner;\n\n// Clase Calculadora con los m\u00e9todos para cada operaci\u00f3n\nclass Calculadora {\n    // M\u00e9todo para sumar\n    public double sumar(double a, double b) {\n        return a + b;\n    }\n\n    // M\u00e9todo para restar\n    public double restar(double a, double b) {\n        return a - b;\n    }\n\n    // M\u00e9todo para multiplicar\n    public double multiplicar(double a, double b) {\n        return a * b;\n    }\n\n    // M\u00e9todo para dividir\n    public double dividir(double a, double b) {\n        if (b == 0) {\n            System.out.println(\"Error: Divisi\u00f3n por cero no permitida.\");\n            return 0; // O lanzar una excepci\u00f3n dependiendo del caso\n        }\n        return a / b;\n    }\n}\n\npublic class CalculadoraOrientadaObjetos {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        Calculadora calculadora = new Calculadora();\n\n        // Solicitar el primer n\u00famero\n        System.out.println(\"Ingrese el primer n\u00famero:\");\n        double num1 = scanner.nextDouble();\n\n        // Solicitar el segundo n\u00famero\n        System.out.println(\"Ingrese el segundo n\u00famero:\");\n        double num2 = scanner.nextDouble();\n\n        // Solicitar la operaci\u00f3n a realizar\n        System.out.println(\"Ingrese la operaci\u00f3n (+, -, *, /):\");\n        char operacion = scanner.next().charAt(0);\n\n        // Variable para almacenar el resultado\n        double resultado = 0;\n\n        // Realizar la operaci\u00f3n mediante los m\u00e9todos de la clase Calculadora\n        switch (operacion) {\n            case '+':\n                resultado = calculadora.sumar(num1, num2);\n                break;\n            case '-':\n                resultado = calculadora.restar(num1, num2);\n                break;\n            case '*':\n                resultado = calculadora.multiplicar(num1, num2);\n                break;\n            case '/':\n                resultado = calculadora.dividir(num1, num2);\n                break;\n            default:\n                System.out.println(\"Operaci\u00f3n no v\u00e1lida.\");\n                return;\n        }\n\n        // Mostrar el resultado\n        System.out.println(\"El resultado es: \" + resultado);\n    }\n}\n\n</code></pre> \ud83d\udca1 Detalles <p>La clase Calculadora encapsula toda la l\u00f3gica de las operaciones matem\u00e1ticas. Esto significa que la funcionalidad est\u00e1 agrupada en un \u00fanico lugar y separada de otras partes del programa (como la entrada y salida de datos en el main). </p> <p>Ventaja Si un m\u00f3dulo (la clase Calculadora) tiene un fallo o necesita ser mejorado, es f\u00e1cil modificarlo sin afectar a otras partes del c\u00f3digo. Esto facilita la localizaci\u00f3n de errores y la evoluci\u00f3n del software.</p>"},{"location":"Bloque1_POO/02_codigos1/#calculadora-orientada-a-objetos-potencia","title":"Calculadora orientada a objetos - potencia","text":"<pre><code>// Aprovechamos la modularidad incluyendo el m\u00e9todo potencia en la clase calculadora\n// de esta forma se pueden agregar nuevas funcionalidades sin alterar significativamente\n// la estructura del programa.\n\nimport java.util.Scanner;\n\n// Clase Calculadora con los m\u00e9todos para cada operaci\u00f3n\nclass Calculadora {\n    // M\u00e9todo para sumar\n    public double sumar(double a, double b) {\n        return a + b;\n    }\n\n    // M\u00e9todo para restar\n    public double restar(double a, double b) {\n        return a - b;\n    }\n\n    // M\u00e9todo para multiplicar\n    public double multiplicar(double a, double b) {\n        return a * b;\n    }\n\n    // M\u00e9todo para dividir\n    public double dividir(double a, double b) {\n        if (b == 0) {\n            System.out.println(\"Error: Divisi\u00f3n por cero no permitida.\");\n            return 0; // O lanzar una excepci\u00f3n dependiendo del caso\n        }\n        return a / b;\n    }\n\n    // Nuevo m\u00e9todo para calcular la potencia\n    public double potencia(double base, double exponente) {\n        return Math.pow(base, exponente);\n    }\n}\n\npublic class CalculadoraOrientadaObjetosPotencia {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        Calculadora calculadora = new Calculadora();\n\n        // Solicitar el primer n\u00famero\n        System.out.println(\"Ingrese el primer n\u00famero:\");\n        double num1 = scanner.nextDouble();\n\n        // Solicitar el segundo n\u00famero\n        System.out.println(\"Ingrese el segundo n\u00famero:\");\n        double num2 = scanner.nextDouble();\n\n        // Solicitar la operaci\u00f3n a realizar\n        System.out.println(\"Ingrese la operaci\u00f3n (+, -, *, /, ^):\");\n        char operacion = scanner.next().charAt(0);\n\n        // Variable para almacenar el resultado\n        double resultado = 0;\n\n        // Realizar la operaci\u00f3n mediante los m\u00e9todos de la clase Calculadora\n        switch (operacion) {\n            case '+':\n                resultado = calculadora.sumar(num1, num2);\n                break;\n            case '-':\n                resultado = calculadora.restar(num1, num2);\n                break;\n            case '*':\n                resultado = calculadora.multiplicar(num1, num2);\n                break;\n            case '/':\n                resultado = calculadora.dividir(num1, num2);\n                break;\n            case '^':  // Nueva operaci\u00f3n para calcular la potencia\n                resultado = calculadora.potencia(num1, num2);\n                break;\n            default:\n                System.out.println(\"Operaci\u00f3n no v\u00e1lida.\");\n                return;\n        }\n\n        // Mostrar el resultado\n        System.out.println(\"El resultado es: \" + resultado);\n    }\n}\n\n</code></pre> \ud83d\udca1 Detalles <p>La clase Calculadora puede ser utilizada en otros programas. Si en al\u00fan otro sistema es necesario realizar operaciones m\u00e1tem\u00e1ticas, se podr\u00eda integrar f\u00e1cilmente la clase sin necesidad de reescribir la l\u00f3gica. </p> <p>Ventajas: </p> <p>- Reutilizaci\u00f3n. Evita la duplicaci\u00f3n de c\u00f3digo, lo que mejora la eficiencia y reduce la posibilidad de errores.</p> <p>- Mantenimiento. Si el c\u00f3digo crece o cambia, se puede realizar sin modificar el flujo principal de la aplicaci\u00f3n. Adem\u00e1s, cualquier correcci\u00f3n que se deba hacer se puede realizar directamente en la clase Calculadora sin tocar otras partes del c\u00f3digo. El c\u00f3digo estar\u00e1 mejor organizado.</p> <p>- Flexibilidad. Se puede extender la clase Calculadora sin modificarla directamente, utilizando herencia o composici\u00f3n. Se podr\u00eda crear una nueva clase, como CalculadoraAvanzada, que extienda la funcionalidad de la calculadora b\u00e1sica, y siga reutilizando el c\u00f3digo existente.</p> <p>- Encapsulamiento. La l\u00f3gica de cada operaci\u00f3n (suma, resta, multiplicaci\u00f3n y divisi\u00f3n) est\u00e1 contenida dentro de m\u00e9todos privados a la clase Calculadora. Esto significa que el main no necesita saber c\u00f3mo se implementa cada operaci\u00f3n; solo llama a los m\u00e9todos correspondientes. Al ocultar los detalles internos, el c\u00f3digo que interact\u00faa con la clase Calculadora (como el c\u00f3digo del main) es m\u00e1s simple y menos propenso a errores. Adem\u00e1s, si cambia la implementaci\u00f3n interna (por ejemplo, optimizando el c\u00e1lculo de la multiplicaci\u00f3n), el resto del programa no se ve afectado.</p> <p>- Escalabilidad. La capacidad para adaptarse al crecimiento, tanto en tama\u00f1o como en complejidad. : La estructura orientada a objetos es naturalmente m\u00e1s escalable. A medida que el programa crezca (por ejemplo, a\u00f1adiendo nuevas funciones o integraciones), se pueden mantener las operaciones matem\u00e1ticas en la clase Calculadora o derivarlas a subclases especializadas sin tener que reestructurar el flujo general del programa.</p>"},{"location":"Bloque1_POO/02_codigos1/#calculadora-orientada-a-objetos-potencia-interfaz","title":"Calculadora orientada a objetos - potencia - interfaz","text":"<pre><code>import java.util.Scanner;\n\n// Interfaz Operacion que define un m\u00e9todo para ejecutar cualquier operaci\u00f3n\ninterface Operacion {\n    double ejecutar(double a, double b);\n}\n\n// Clase para sumar\nclass Suma implements Operacion {\n    @Override\n    public double ejecutar(double a, double b) {\n        return a + b;\n    }\n}\n\n// Clase para restar\nclass Resta implements Operacion {\n    @Override\n    public double ejecutar(double a, double b) {\n        return a - b;\n    }\n}\n\n// Clase para multiplicar\nclass Multiplicacion implements Operacion {\n    @Override\n    public double ejecutar(double a, double b) {\n        return a * b;\n    }\n}\n\n// Clase para dividir\nclass Division implements Operacion {\n    @Override\n    public double ejecutar(double a, double b) {\n        if (b == 0) {\n            System.out.println(\"Error: Divisi\u00f3n por cero no permitida.\");\n            return 0;\n        }\n        return a / b;\n    }\n}\n\n// Clase para potencia\nclass Potencia implements Operacion {\n    @Override\n    public double ejecutar(double base, double exponente) {\n        return Math.pow(base, exponente);\n    }\n}\n\n// Clase Calculadora que usa la interfaz Operacion\nclass Calculadora {\n    public double operar(Operacion operacion, double a, double b) {\n        return operacion.ejecutar(a, b);\n    }\n}\n\npublic class CalculadoraOrientadaObjetosPotenciaInterfaz {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        Calculadora calculadora = new Calculadora();\n\n        // Solicitar el primer n\u00famero\n        System.out.println(\"Ingrese el primer n\u00famero:\");\n        double num1 = scanner.nextDouble();\n\n        // Solicitar el segundo n\u00famero\n        System.out.println(\"Ingrese el segundo n\u00famero:\");\n        double num2 = scanner.nextDouble();\n\n        // Solicitar la operaci\u00f3n a realizar\n        System.out.println(\"Ingrese la operaci\u00f3n (+, -, *, /, ^):\");\n        char operacion = scanner.next().charAt(0);\n\n        // Variable para almacenar el resultado\n        double resultado = 0;\n\n        // Definir la operaci\u00f3n basada en la entrada\n        Operacion op = null;\n        switch (operacion) {\n            case '+':\n                op = new Suma();\n                break;\n            case '-':\n                op = new Resta();\n                break;\n            case '*':\n                op = new Multiplicacion();\n                break;\n            case '/':\n                op = new Division();\n                break;\n            case '^':\n                op = new Potencia();\n                break;\n            default:\n                System.out.println(\"Operaci\u00f3n no v\u00e1lida.\");\n                return;\n        }\n\n        // Realizar la operaci\u00f3n mediante la interfaz Operacion\n        if (op != null) {\n            resultado = calculadora.operar(op, num1, num2);\n        }\n\n        // Mostrar el resultado\n        System.out.println(\"El resultado es: \" + resultado);\n    }\n}\n</code></pre>"},{"location":"Bloque1_POO/02_codigos1/#diagrama-de-modulos","title":"Diagrama de m\u00f3dulos","text":""},{"location":"Bloque1_POO/02_codigos1/#relacion-real","title":"Relaci\u00f3n real","text":"<ul> <li>La clase Calculadora es una clase independiente que contiene los m\u00e9todos para realizar las operaciones b\u00e1sicas (suma, resta, multiplicaci\u00f3n y divisi\u00f3n).  </li> <li>La clase CalculadoraOrientadaObjetos es simplemente la clase principal donde se solicita la entrada del usuario y se utiliza un objeto de la clase Calculadora para realizar las operaciones.  </li> </ul>"},{"location":"Bloque1_POO/02_codigos1/#interaccion","title":"Interacci\u00f3n","text":"<p>La clase CalculadoraOrientadaObjetos crea una instancia de Calculadora y llama a sus m\u00e9todos. Es un ejemplo de composici\u00f3n (usar un objeto dentro de otro) y no de herencia.  </p>"},{"location":"Bloque1_POO/02_codigos1/#diferencias-clave","title":"Diferencias clave","text":"<ul> <li>Herencia: Una clase hija hereda los m\u00e9todos y propiedades de la clase padre, y puede sobreescribir o extender la funcionalidad de la clase padre.  </li> <li>Composici\u00f3n: Una clase contiene una instancia de otra clase y utiliza sus m\u00e9todos, pero no hereda de ella.  </li> </ul> <p>En este caso, la clase principal (CalculadoraOrientadaObjetos) utiliza la clase Calculadora, pero no es una subclase de ella.  </p> \ud83d\udca1 extends <p>Solo puedes extender de UNA sola clase (Java no permite herencia m\u00faltiple de clases).</p> <p>Heredas atributos y m\u00e9todos de la superclase.</p> <p>Puedes sobrescribir (override) m\u00e9todos para dar un comportamiento espec\u00edfico.</p> <p>Puedes a\u00f1adir nuevos atributos o m\u00e9todos.</p> <p>extends significa: soy un tipo m\u00e1s espec\u00edfico de esa clase.</p> \ud83d\udca1 implements <p>Una interfaz define un contrato (qu\u00e9 m\u00e9todos debe tener la clase), pero no la implementaci\u00f3n.</p> <p>Una clase puede implementar varias interfaces \u2192 es la forma de tener herencia m\u00faltiple en Java.</p> <p>Obliga a la clase a implementar todos los m\u00e9todos declarados en la interfaz (salvo que la clase sea abstracta).</p> <p>Puedes a\u00f1adir nuevos atributos o m\u00e9todos.</p> <p>implements significa: cumplo el contrato de esta interfaz.</p>"},{"location":"Bloque1_POO/02_codigos1/#conclusion","title":"Conclusi\u00f3n","text":"<p>Esto significa que la relaci\u00f3n entre ambas clases es de uso o colaboraci\u00f3n, y no de herencia.  </p>"},{"location":"Bloque1_POO/02_codigos2/","title":"Modularidad, Herencia y Reusabilidad","text":""},{"location":"Bloque1_POO/02_codigos2/#definiciones-y-ejemplos-ilustrativos","title":"Definiciones y ejemplos ilustrativos","text":""},{"location":"Bloque1_POO/02_codigos2/#metodos-constructores-accesores-transformadores-y-productores","title":"M\u00e9todos: constructores, accesores, transformadores y productores","text":"<pre><code>public class Persona {\n    // Atributos privados de la clase\n    private String nombre;\n    private int edad;\n    private double altura;\n\n    // *** Constructor: Se utiliza para inicializar los atributos de la clase cuando se crea un objeto\n    public Persona(String nombre, int edad, double altura) {\n        this.nombre = nombre;\n        this.edad = edad;\n        this.altura = altura;\n    }\n\n    // *** M\u00e9todo Accesor (getter): Permite acceder al valor del atributo 'nombre'\n    public String getNombre() {\n        return nombre;\n    }\n\n    // *** M\u00e9todo Accesor (getter): Permite acceder al valor del atributo 'edad'\n    public int getEdad() {\n        return edad;\n    }\n\n    // *** M\u00e9todo Accesor (getter): Permite acceder al valor del atributo 'altura'\n    public double getAltura() {\n        return altura;\n    }\n\n    // *** M\u00e9todo Transformador (setter): Permite modificar el valor del atributo 'nombre'\n    public void setNombre(String nombre) {\n        this.nombre = nombre;\n    }\n\n    // *** M\u00e9todo Transformador (setter): Permite modificar el valor del atributo 'edad'\n    public void setEdad(int edad) {\n        this.edad = edad;\n    }\n\n    // *** M\u00e9todo Transformador (setter): Permite modificar el valor del atributo 'altura'\n    public void setAltura(double altura) {\n        this.altura = altura;\n    }\n\n    // *** M\u00e9todo Productor: Crea y devuelve una cadena con la informaci\u00f3n de la persona\n    public String informacionCompleta() {\n        return \"Nombre: \" + nombre + \", Edad: \" + edad + \" a\u00f1os, Altura: \" + altura + \" m\";\n    }\n\n    // *** M\u00e9todo Productor: Calcula el a\u00f1o de nacimiento de la persona basado en su edad\n    public int calcularAnioNacimiento() {\n        int anioActual = java.util.Calendar.getInstance().get(java.util.Calendar.YEAR);\n        return anioActual - edad;\n    }\n\n    // M\u00e9todo principal para probar la clase Persona\n    public static void main(String[] args) {\n        // Creaci\u00f3n de un objeto de la clase Persona usando el constructor\n        Persona persona = new Persona(\"Juan\", 25, 1.75);\n\n        // Uso de los m\u00e9todos accesores\n        System.out.println(\"Nombre: \" + persona.getNombre());\n        System.out.println(\"Edad: \" + persona.getEdad());\n        System.out.println(\"Altura: \" + persona.getAltura());\n\n        // Uso de los m\u00e9todos transformadores\n        persona.setNombre(\"Carlos\");\n        persona.setEdad(30);\n        persona.setAltura(1.80);\n\n        // Mostrar la informaci\u00f3n completa usando el m\u00e9todo productor\n        System.out.println(\"Informaci\u00f3n actualizada: \" + persona.informacionCompleta());\n\n        // Uso de otro m\u00e9todo productor\n        System.out.println(\"A\u00f1o de nacimiento: \" + persona.calcularAnioNacimiento());\n    }\n}\n</code></pre> \ud83d\udca1 Caracter\u00edsticas <p>Los atributos (nombre, edad, altura) son privados (-).</p> <p>Todos los m\u00e9todos son p\u00fablicos (+).</p> <p>Esto es un caso cl\u00e1sico de encapsulaci\u00f3n fuerte:</p> <p>Los datos se ocultan (private).</p> <p>Se accede a ellos solo a trav\u00e9s de getters y setters.</p> <p>El usuario de la clase no puede manipular directamente los atributos.</p>"},{"location":"Bloque1_POO/02_codigos2/#metodos-constructores-accesores-transformadores-y-productores_1","title":"M\u00e9todos: constructores, accesores, transformadores y productores","text":"<pre><code>public class PersonaNiveles {\n    // Atributos de la clase con diferentes modificadores de acceso\n    private String nombre;   // Solo accesible desde dentro de la clase Persona\n    protected int edad;      // Accesible desde la clase Persona y sus subclases (en el mismo paquete o diferentes paquetes)\n    public double altura;    // Accesible desde cualquier clase\n\n    // *** Constructor p\u00fablico: Se utiliza para inicializar los atributos de la clase cuando se crea un objeto\n    public PersonaNiveles(String nombre, int edad, double altura) {\n        this.nombre = nombre;\n        this.edad = edad;\n        this.altura = altura;\n    }\n\n    // *** M\u00e9todo Accesor (getter) p\u00fablico: Permite acceder al valor del atributo 'nombre'\n    public String getNombre() {\n        return nombre;\n    }\n\n    // *** M\u00e9todo Accesor (getter) protegido: Permite acceder al valor del atributo 'edad'\n    protected int getEdad() {\n        return edad;\n    }\n\n    // *** M\u00e9todo Accesor (getter) p\u00fablico: Permite acceder al valor del atributo 'altura'\n    public double getAltura() {\n        return altura;\n    }\n\n    // *** M\u00e9todo Transformador (setter) p\u00fablico: Permite modificar el valor del atributo 'nombre'\n    public void setNombre(String nombre) {\n        this.nombre = nombre;\n    }\n\n    // *** M\u00e9todo Transformador (setter) protegido: Permite modificar el valor del atributo 'edad'\n    protected void setEdad(int edad) {\n        this.edad = edad;\n    }\n\n    // *** M\u00e9todo Transformador (setter) p\u00fablico: Permite modificar el valor del atributo 'altura'\n    public void setAltura(double altura) {\n        this.altura = altura;\n    }\n\n    // *** M\u00e9todo Productor p\u00fablico: Crea y devuelve una cadena con la informaci\u00f3n de la persona\n    public String informacionCompleta() {\n        return \"Nombre: \" + nombre + \", Edad: \" + edad + \" a\u00f1os, Altura: \" + altura + \" m\";\n    }\n\n    // *** M\u00e9todo Productor protegido: Calcula el a\u00f1o de nacimiento de la persona basado en su edad\n    protected int calcularAnioNacimiento() {\n        int anioActual = java.util.Calendar.getInstance().get(java.util.Calendar.YEAR);\n        return anioActual - edad;\n    }\n\n    // M\u00e9todo principal para probar la clase PersonaNiveles\n    public static void main(String[] args) {\n        // Creaci\u00f3n de un objeto de la clase PersonaNiveles usando el constructor\n        PersonaNiveles persona = new PersonaNiveles(\"Juan\", 25, 1.75);\n\n        // Uso de los m\u00e9todos accesores\n        System.out.println(\"Nombre: \" + persona.getNombre());\n        System.out.println(\"Edad: \" + persona.getEdad());\n        System.out.println(\"Altura: \" + persona.getAltura());\n\n        // Uso de los m\u00e9todos transformadores\n        persona.setNombre(\"Carlos\");\n        persona.setEdad(30);\n        persona.setAltura(1.80);\n\n        // Mostrar la informaci\u00f3n completa usando el m\u00e9todo productor\n        // Genera una cadena completa con la informaci\u00f3n de la persona\n\n        System.out.println(\"Informaci\u00f3n actualizada: \" + persona.informacionCompleta());\n\n        // Uso de otro m\u00e9todo productor\n        // Calcula y devuelve el a\u00f1o de nacimiento basado en la edad\n        System.out.println(\"A\u00f1o de nacimiento: \" + persona.calcularAnioNacimiento());\n    }\n}\n\n// Nota:\n// Aunque el atributo nombre es private, su valor \n//se puede mostrar porque el m\u00e9todo getNombre() es public y \n//proporciona un medio autorizado y controlado para acceder a \n//ese valor desde fuera de la clase.\n//El uso de atributos private junto con m\u00e9todos public (getters \n//y setters) es un principio fundamental de encapsulaci\u00f3n en la \n//programaci\u00f3n orientada a objetos.\n</code></pre> \ud83d\udca1 Caracter\u00edsticas <p>nombre es privado (-) \u2192 solo accesible desde dentro de la clase.</p> <p>edad es protegido (#) \u2192 accesible desde la clase y las subclases..</p> <p>altura es p\u00fablico (+) \u2192 accesible desde cualquier parte del programa.</p> <p>Lo mismo ocurre con algunos m\u00e9todos:</p> <p>getEdad(), setEdad() y calcularAnioNacimiento() son protegidos.</p> <p>Los dem\u00e1s (getNombre(), getAltura(), etc.) son p\u00fablicos.</p>"},{"location":"Bloque1_POO/02_codigos2/#gestion-de-operaciones","title":"Gesti\u00f3n de operaciones","text":"<pre><code>import java.util.Scanner;\n\n// Clase Cilindro para gestionar las operaciones con el cilindro\nclass Cilindro {\n    private double altura;\n    private double radio;\n\n    // M\u00e9todo para inicializar los valores de altura y radio\n    public void inicializar(double altura, double radio) {\n        this.altura = altura;\n        this.radio = radio;\n    }\n\n    // M\u00e9todo para calcular el volumen del cilindro\n    public double calculaVolumen() {\n        return Math.PI * Math.pow(radio, 2) * altura;\n    }\n}\n\n// Clase principal UsaCilindro\npublic class UsaCilindro {\n    public static void main(String[] args) {\n        double alt, rad;\n\n        // Creaci\u00f3n del objeto Scanner para la entrada de datos\n        Scanner teclado = new Scanner(System.in);\n\n        // Solicitar la altura del cilindro\n        System.out.print(\"Introduce la altura: \");\n        alt = teclado.nextDouble();\n\n        // Solicitar el radio del cilindro\n        System.out.print(\"Introduce el radio: \");\n        rad = teclado.nextDouble();\n\n        // Crear un objeto de la clase Cilindro\n        Cilindro c = new Cilindro();\n        c.inicializar(alt, rad);\n\n        // Calcular y mostrar el volumen del cilindro\n        System.out.println(\"El volumen del cilindro es: \" + c.calculaVolumen());\n\n        // Cerrar el objeto Scanner\n        teclado.close();\n    }\n}\n</code></pre> \ud83d\udca1 Detalles  <p> Detalles. </p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/","title":"Modularidad, Herencia y Reusabilidad","text":""},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#introduccion","title":"Introducci\u00f3n","text":"<p>En el desarrollo de software, conceptos como modularidad, herencia y reusabilidad son esenciales para crear programas m\u00e1s claros, mantenibles y escalables. Estos principios permiten organizar el c\u00f3digo, reducir la duplicaci\u00f3n y facilitar la evoluci\u00f3n de los proyectos.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#modularidad","title":"Modularidad","text":"<p>La modularidad consiste en dividir un programa en componentes o m\u00f3dulos independientes, de manera que cada uno tenga una responsabilidad clara.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#caracteristicas","title":"Caracter\u00edsticas","text":"<ul> <li>Un m\u00f3dulo puede desarrollarse, probarse y mantenerse de forma aislada.</li> <li>Facilita localizar y corregir errores.</li> <li>Permite ampliar la funcionalidad sin afectar a todo el sistema.</li> </ul>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#herencia","title":"Herencia","text":"<p>La herencia permite definir nuevas clases basadas en otras ya existentes, reutilizando atributos y m\u00e9todos y a\u00f1adiendo o especializando funcionalidades.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#conceptos-clave","title":"Conceptos clave","text":"<ul> <li>Superclase (clase base): clase original de la que heredan otras.</li> <li>Subclase (clase derivada): clase que extiende la funcionalidad de la superclase.</li> </ul>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#polimorfismo-y-clases-abstractas","title":"Polimorfismo y Clases Abstractas","text":"<p>El polimorfismo permite que una misma referencia pueda apuntar a objetos de diferentes clases, ejecutando el m\u00e9todo correspondiente seg\u00fan el tipo del objeto real.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#interfaces","title":"Interfaces","text":"<p>Una interfaz define un conjunto de m\u00e9todos sin implementaci\u00f3n. Las clases que la implementan son responsables de definir su funcionamiento.</p> <p>Las interfaces permiten simular la herencia m\u00faltiple y promueven la flexibilidad del dise\u00f1o.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#reusabilidad","title":"Reusabilidad","text":"<p>La reusabilidad consiste en emplear c\u00f3digo existente en diferentes contextos o proyectos, evitando duplicaciones. Se refiere a la capacidad de utilizar las mismas piezas de c\u00f3digo en diferentes partes del programa o en diferentes proyectos.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#beneficios","title":"Beneficios","text":"<ul> <li>Reducci\u00f3n de errores y duplicaciones.</li> <li>Mayor rapidez en el desarrollo.</li> <li>C\u00f3digo m\u00e1s consistente y probado.</li> </ul>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#conclusion","title":"Conclusi\u00f3n","text":"<ul> <li>La modularidad favorece el orden y la claridad.  </li> <li>La herencia y el polimorfismo permiten extender y generalizar comportamientos.  </li> <li>La reusabilidad reduce costes y facilita el mantenimiento.  </li> <li>Las interfaces aportan flexibilidad para dise\u00f1ar sistemas m\u00e1s escalables.</li> </ul> <p>Estos principios son fundamentales en la Programaci\u00f3n Orientada a Objetos (POO) y constituyen la base de un software robusto y adaptable.</p> <p>Ejemplos pr\u00e1cticos 1</p> <p>Ejemplos pr\u00e1cticos 2</p>"},{"location":"Bloque1_POO/03_genericidad_contenedores/","title":"Genericidad; contenedores como ejemplo de aplicaci\u00f3n","text":"<p>Contenido en construcci\u00f3n</p>"},{"location":"Bloque2_Eventos_GUI/01_eventos_clases_anidadas/","title":"Introducci\u00f3n, gestores de eventos y clases anidadas","text":"<p>Contenido en construcci\u00f3n</p>"},{"location":"Bloque2_Eventos_GUI/02_interfaz_grafica/","title":"Interfaz gr\u00e1fica de usuarios","text":"<p>Contenido en construcci\u00f3n</p>"},{"location":"Bloque2_Eventos_GUI/03_componentes_layouts_navegacion/","title":"Componentes, layouts y navegaci\u00f3n","text":"<p>Contenido en construcci\u00f3n</p>"},{"location":"Bloque3_Concurrente_Distribuida/01_concurrencia_sincronizacion/","title":"Introducci\u00f3n a la concurrencia y sincronizaci\u00f3n","text":"<p>Contenido en construcci\u00f3n</p>"},{"location":"Bloque3_Concurrente_Distribuida/02_comunicacion_paralelismo/","title":"Comunicaci\u00f3n entre hilos y paralelismo","text":"<p>Contenido en construcci\u00f3n</p>"},{"location":"Bloque3_Concurrente_Distribuida/03_programacion_distribuida/","title":"Introducci\u00f3n a la programaci\u00f3n distribuida","text":"<p>Contenido en construcci\u00f3n</p>"}]}