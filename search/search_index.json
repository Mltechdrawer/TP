{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tecnolog\u00edas de Programaci\u00f3nBienvenido a Tecnolog\u00edas de Programaci\u00f3n","text":""},{"location":"#tecnologias-de-programacion_1","title":"\ud83d\udcf1 Tecnolog\u00edas de programaci\u00f3n","text":"<p>Tecnolog\u00edas de Programaci\u00f3n es una asignatura obligatoria del 2.\u00ba curso del Grado en Ingenier\u00eda Inform\u00e1tica (1.er semestre, 6 ECTS). Su objetivo es dotar al alumnado de una formaci\u00f3n avanzada en t\u00e9cnicas y paradigmas de programaci\u00f3n que consolidan y ampl\u00edan los conocimientos adquiridos en Fundamentos de Programaci\u00f3n I y II.</p> <p>La asignatura combina teor\u00eda, ejercicios pr\u00e1cticos y actividades de laboratorio. Se fomenta la aplicaci\u00f3n de los conceptos en el dise\u00f1o y desarrollo de programas, as\u00ed como la reflexi\u00f3n cr\u00edtica sobre las soluciones propuestas. El aprendizaje progresivo a lo largo de los tres bloques permite al estudiante adquirir competencias clave para desenvolverse en entornos profesionales donde se requieren aplicaciones modulares, interactivas y con capacidad de ejecuci\u00f3n en paralelo o distribuida.</p> <p>El curso se apoya en un enfoque pr\u00e1ctico con trabajos individuales y en equipo, reforzando la capacidad de aplicar conceptos te\u00f3ricos a problemas reales de programaci\u00f3n. Esta asignatura constituye una base s\u00f3lida para asignaturas posteriores relacionadas con la ingenier\u00eda del software, los sistemas distribuidos y la inteligencia artificial.</p> <p>Profesorado:</p> <ul> <li> <p>David Freire Obreg\u00f3n. Profesor de pr\u00e1cticas. Coordinador  </p> </li> <li> <p>Ignacio Jos\u00e9 L\u00f3pez Rodr\u00edguez.</p> </li> <li> <p>Mar\u00eda Dolores Afonso Su\u00e1rez. </p> </li> </ul> <p></p> <p> </p> <p>\u00a9 2025 Mar\u00eda Dolores Afonso Su\u00e1rez. Este material se distribuye bajo licencia Creative Commons Atribuci\u00f3n 4.0 Internacional (CC BY 4.0).</p>"},{"location":"contenidos/","title":"Contenidos","text":"<p>Tecnolog\u00edas de Programaci\u00f3n (TP) Los bloques est\u00e1n dise\u00f1ados para guiar al estudiante desde los fundamentos avanzados de POO hasta los paradigmas de programaci\u00f3n concurrente y distribuida. El objetivo es consolidar las bases de un programador profesional capaz de crear aplicaciones robustas, modulares y eficientes.</p> <p>BLOQUE 1. Conceptos avanzados de Programaci\u00f3n Orientada a Objetos revisa y ampl\u00eda los fundamentos de POO, profundizando en modularidad, herencia y reutilizaci\u00f3n de c\u00f3digo. Se abordan tambi\u00e9n la genericidad y los contenedores como ejemplos de aplicaci\u00f3n, proporcionando una visi\u00f3n madura del dise\u00f1o orientado a objetos.</p> <p>BLOQUE 2. Fundamentos de la Programaci\u00f3n Guiada por Eventos e Interfaz Gr\u00e1fica introduce el paradigma basado en eventos y el dise\u00f1o de interfaces. Se trabaja con gestores de eventos, clases anidadas, componentes y layouts para construir aplicaciones interactivas y usables.</p> <p>BLOQUE 3. Programaci\u00f3n Concurrente y Distribuida explora los principios de la concurrencia (sincronizaci\u00f3n, comunicaci\u00f3n entre hilos, paralelismo) y una introducci\u00f3n a la programaci\u00f3n distribuida, competencias clave para sistemas modernos y escalables.</p>"},{"location":"Bloque1_POO/01Java_vs_Python/","title":"Java vs Python","text":"<p>Este tema presenta una comparaci\u00f3n entre dos de los lenguajes de programaci\u00f3n m\u00e1s influyentes y utilizados en la actualidad: Java y Python. Ambos tienen fortalezas y limitaciones, y su elecci\u00f3n depende en gran medida del tipo de aplicaci\u00f3n que se desee desarrollar.</p>"},{"location":"Bloque1_POO/01Java_vs_Python/#sintaxis","title":"Sintaxis","text":"<ul> <li>Java: Su sintaxis es m\u00e1s estricta, requiere punto y coma al final de cada sentencia y la declaraci\u00f3n expl\u00edcita de tipos. Esto fuerza al programador a ser m\u00e1s detallista y riguroso desde el principio.</li> <li>Python: Su sintaxis es mucho m\u00e1s simple y legible, no necesita punto y coma ni declaraci\u00f3n previa de tipos. Esto facilita la escritura de programas cortos y prototipos r\u00e1pidos.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#tipado","title":"Tipado","text":"<ul> <li>Java: Est\u00e1ticamente tipado. Los tipos de las variables son fijos y se conocen en tiempo de compilaci\u00f3n. Esto puede reducir errores en ejecuci\u00f3n y mejorar la eficiencia.</li> <li>Python: Din\u00e1micamente tipado. El tipo de las variables puede cambiar durante la ejecuci\u00f3n. Esto proporciona mayor flexibilidad pero puede provocar errores en tiempo de ejecuci\u00f3n si no se controla bien.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#velocidad-de-ejecucion","title":"Velocidad de ejecuci\u00f3n","text":"<ul> <li>Java: Generalmente m\u00e1s r\u00e1pido porque el c\u00f3digo se compila a bytecode y se ejecuta en la JVM (Java Virtual Machine), lo que optimiza el rendimiento.</li> <li>Python: M\u00e1s lento porque se interpreta l\u00ednea por l\u00ednea. Aunque existen int\u00e9rpretes optimizados, en aplicaciones de gran escala puede ser menos eficiente.</li> </ul> <p>Velocidad de ejecuci\u00f3n</p>"},{"location":"Bloque1_POO/01Java_vs_Python/#compilacion-vs-interpretacion","title":"Compilaci\u00f3n vs Interpretaci\u00f3n","text":"<ul> <li>Java: Es un lenguaje compilado a bytecode, que despu\u00e9s se ejecuta en la JVM. Esto permite portabilidad entre sistemas y cierto equilibrio entre rendimiento y flexibilidad.</li> <li>Python: Lenguaje interpretado, ejecutado l\u00ednea por l\u00ednea. Esto facilita la depuraci\u00f3n y flexibilidad, pero penaliza la velocidad.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#uso-de-memoria-y-gestion","title":"Uso de memoria y gesti\u00f3n","text":"<ul> <li>Java: Utiliza m\u00e1s memoria, pero su gesti\u00f3n se realiza mediante un recolector de basura robusto que maneja autom\u00e1ticamente la memoria no utilizada.</li> <li>Python: Su consumo de memoria suele ser menor, aunque tambi\u00e9n implementa mecanismos de recolecci\u00f3n de basura.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#paradigma-de-programacion","title":"Paradigma de programaci\u00f3n","text":"<ul> <li>Java: Lenguaje orientado a objetos puro. Todo debe formar parte de una clase. Aunque soporta elementos funcionales (como lambdas), su enfoque central es OOP.</li> <li>Python: Soporta m\u00faltiples paradigmas: orientaci\u00f3n a objetos, programaci\u00f3n funcional y programaci\u00f3n procedimental. Es m\u00e1s flexible y adaptable.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#bibliotecas-y-ecosistema","title":"Bibliotecas y ecosistema","text":"<ul> <li>Java: Ecosistema muy s\u00f3lido, especialmente en aplicaciones empresariales, m\u00f3viles (Android) y web de gran escala.</li> <li>Python: Ecosistema con gran popularidad en ciencia de datos, inteligencia artificial y aprendizaje autom\u00e1tico. Destaca por bibliotecas como NumPy, Pandas o TensorFlow.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#portabilidad","title":"Portabilidad","text":"<ul> <li>Java: Altamente portable gracias a la JVM. El lema \u201cwrite once, run anywhere\u201d refleja esta fortaleza.</li> <li>Python: Tambi\u00e9n portable, pero en ocasiones depende de bibliotecas externas que pueden no estar disponibles en todas las plataformas.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#aplicaciones-comunes","title":"Aplicaciones comunes","text":"<ul> <li>Java: Usado en aplicaciones empresariales, m\u00f3viles (Android) y sistemas web de gran rendimiento y escala.</li> <li>Python: Predomina en ciencia de datos, inteligencia artificial, automatizaci\u00f3n de tareas y desarrollo r\u00e1pido de prototipos.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#comunidad-y-aprendizaje","title":"Comunidad y aprendizaje","text":"<ul> <li>Java: Considerado m\u00e1s dif\u00edcil de aprender al inicio por la complejidad de su sintaxis y la necesidad de definir estructuras m\u00e1s r\u00edgidas.</li> <li>Python: Lenguaje valorado como uno de los m\u00e1s accesibles para principiantes. Su sintaxis clara y directa lo convierten en una excelente opci\u00f3n para iniciarse en la programaci\u00f3n.</li> </ul>"},{"location":"Bloque1_POO/01Java_vs_Python/#resumen","title":"Resumen","text":"<ul> <li>Java: Ideal para aplicaciones grandes, multiplataforma y de alto rendimiento. Aporta robustez y seguridad.</li> <li>Python: Flexible, sencillo de aprender y con un enorme protagonismo en \u00e1reas emergentes como la IA y la ciencia de datos.</li> </ul>"},{"location":"Bloque1_POO/01_codigos/","title":"Tema \u00b7 Repaso de Programaci\u00f3n Orientada a Objetos","text":"<p>Ejemplos de c\u00f3digo </p>"},{"location":"Bloque1_POO/01_codigos/#velocidad-de-ejecucion","title":"Velocidad de ejecuci\u00f3n","text":""},{"location":"Bloque1_POO/01_codigos/#java","title":"Java","text":"<pre><code>public class VelocidadJava {\n    public static void main(String[] args) {\n        long startTime = System.nanoTime();\n\n        int suma = 0;\n        for (int i = 0; i &lt; 1000000; i++) {\n            suma += i;\n        }\n\n        long endTime = System.nanoTime();\n        System.out.println(\"Tiempo de ejecuci\u00f3n en Java: \" + (endTime - startTime) + \" nanosegundos.\");\n    }\n}\n// Java. Valores aproximados a: 3927653 nanosegundos (unos 4 milisegundos)\n</code></pre> <pre><code>import time\n\nstart_time = time.time()\n\nsuma = 0\nfor i in range(1000000):\n    suma += i\n\nend_time = time.time()\nprint(\"Tiempo de ejecuci\u00f3n en Python:\", (end_time - start_time), \"segundos\")\n\n// Python. Valores aproximados a: 0.13556790351867676 segundos (unos 135 milisegundos)\n</code></pre>"},{"location":"Bloque1_POO/01_codigos/#abstraccion","title":"Abstracci\u00f3n","text":"<pre><code>// Clase abstracta que define el comportamiento de un Vehiculo\nabstract class Vehiculo {\n    // M\u00e9todo abstracto: las subclases deben implementar c\u00f3mo encender el veh\u00edculo\n    public abstract void encender();\n\n    // M\u00e9todo abstracto: las subclases deben implementar c\u00f3mo apagar el veh\u00edculo\n    public abstract void apagar();\n\n    // M\u00e9todo com\u00fan que puede ser usado por todas las subclases\n    public void mostrarTipo() {\n        System.out.println(\"Este es un veh\u00edculo.\");\n    }\n}\n\n// Clase concreta que extiende de la clase abstracta Vehiculo\nclass Coche extends Vehiculo {\n    // Implementaci\u00f3n del m\u00e9todo encender\n    public void encender() {\n        System.out.println(\"El coche est\u00e1 encendido.\");\n    }\n\n    // Implementaci\u00f3n del m\u00e9todo apagar\n    public void apagar() {\n        System.out.println(\"El coche est\u00e1 apagado.\");\n    }\n}\n\n// Clase principal que usa la abstracci\u00f3n\npublic class Main {  \n    public static void main(String[] args) {\n        // Creamos un objeto de tipo Coche\n        Coche miCoche = new Coche();\n\n        // Usamos los m\u00e9todos abstractos implementados\n        miCoche.encender();\n        miCoche.mostrarTipo();\n        miCoche.apagar();\n\n        // Intentar crear un objeto de la clase abstracta (esto va a generar un error de compilaci\u00f3n)\n        Vehiculo miVehiculo = new Vehiculo();  // &lt;-- Esto genera un error\n    }\n}\n</code></pre>"},{"location":"Bloque1_POO/01_codigos/#encapsulamiento","title":"Encapsulamiento","text":"<pre><code>class Circulo {\n    // Al ser private solo los m\u00e9todos de esta clase pueden acceder a ellos\n    private String color;\n    private int radio;\n    private int x, y;\n\n    // El constructor permite crear objetos c\u00edrculo con valores iniciales para sus atributos \n    public Circulo(String color, int radio, int x, int y) {\n        this.color = color;\n        this.radio = radio;\n        this.x = x;\n        this.y = y;\n    }\n    // M\u00e9todos que pueden alterar  los atributos de forma controlada\n        public void cambiarTamano(int nuevoRadio) {\n        this.radio = nuevoRadio;\n    }\n\n    public void cambiarPosicion(int nuevaX, int nuevaY) {\n        this.x = nuevaX;\n        this.y = nuevaY;\n    }\n    // Encapsula la representaci\u00f3n del objeto\n    public void mostrar() {\n        System.out.println(\"C\u00edrculo de color \" + color + \", radio \" + radio +\n                           \", en la posici\u00f3n (\" + x + \", \" + y + \")\");\n    }\n}\n// Clase principal. Ejemplo de uso de encapsulamiento.\npublic class Main {\n    public static void main(String[] args) {\n        Circulo circulo1 = new Circulo(\"Rojo\", 50, 100, 100);\n        Circulo circulo2 = new Circulo(\"Verde\", 30, 200, 150);\n        Circulo circulo3 = new Circulo(\"Azul\", 70, 300, 250);\n\n        circulo1.mostrar();\n        circulo2.mostrar();\n        circulo3.mostrar();\n        // Solo llama a los m\u00e9todos p\u00fablicos, no le interesa como se realizan\n        circulo1.cambiarTamano(80);\n        circulo1.cambiarPosicion(150, 200);\n\n        circulo1.mostrar();\n    }\n}\n\n</code></pre>"},{"location":"Bloque1_POO/01_codigos/#herencia","title":"Herencia","text":"<pre><code>class Animal {\n    private final String nombre;\n    Animal(String nombre) { this.nombre = nombre; }\n    public void sonar() { System.out.println(nombre + \": hace un sonido gen\u00e9rico\"); }\n    public String getNombre() { return nombre; }\n}\n\nclass Perro extends Animal {\n    Perro(String nombre) { super(nombre); }\n    // Anotaci\u00f3n de un m\u00e9todo, que indica que se sobreescribe\n    @Override public void sonar() { System.out.println(getNombre() + \": \u00a1guau!\"); }\n    public void traerPelota() { System.out.println(getNombre() + \" trae la pelota\"); }\n}\n\npublic class Main { // \u2190 Aseg\u00farate de que el archivo se llame Main.java\n    public static void main(String[] args) {\n        Animal a = new Animal(\"Animal\");\n        Animal p = new Perro(\"Toby\");\n        a.sonar();\n        p.sonar();\n        if (p instanceof Perro) ((Perro) p).traerPelota();\n    }\n}\n</code></pre>"},{"location":"Bloque1_POO/01_codigos/#polimorfismo","title":"Polimorfismo","text":"<pre><code>// Superclase/abstracci\u00f3n\nabstract class Figura {\n    private final String nombre;\n    Figura(String nombre) { this.nombre = nombre; }\n\n    public String getNombre() { return nombre; }\n\n    // M\u00e9todo polim\u00f3rfico: cada subclase lo implementa a su manera\n    public abstract double area();\n\n    // Comportamiento com\u00fan que tambi\u00e9n puede sobrescribirse\n    public void dibujar() {\n        System.out.println(\"Dibujando \" + nombre + \" gen\u00e9rico\");\n    }\n}\n\n// Subclase 1: Circulo\nclass Circulo extends Figura {\n    private final double radio;\n    Circulo(double radio) {\n        super(\"c\u00edrculo\");\n        this.radio = radio;\n    }\n    @Override public double area() { return Math.PI * radio * radio; }\n    @Override public void dibujar() { System.out.println(\"Dibujando un c\u00edrculo\"); }\n}\n\n// Subclase 2: Rectangulo\nclass Rectangulo extends Figura {\n    private final double ancho, alto;\n    Rectangulo(double ancho, double alto) {\n        super(\"rect\u00e1ngulo\");\n        this.ancho = ancho; this.alto = alto;\n    }\n    @Override public double area() { return ancho * alto; }\n    // Usa el dibujar() heredado si no lo sobrescribes\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        // Polimorfismo: misma referencia (Figura), distintos objetos concretos\n        Figura[] figuras = { new Circulo(2.0), new Rectangulo(3.0, 4.0) };\n\n        for (Figura f : figuras) {\n            f.dibujar();                              // despacho din\u00e1mico\n            System.out.printf(\"\u00c1rea de %s: %.2f%n\", \n                              f.getNombre(), f.area()); // llama al override adecuado\n        }\n\n        // Otra muestra de polimorfismo en un m\u00e9todo que recibe la superclase\n        procesar(new Circulo(5.0));\n        procesar(new Rectangulo(2.0, 6.0));\n    }\n\n    static void procesar(Figura f) {\n        System.out.println(\"Procesando \" + f.getClass().getSimpleName()\n                           + \" con \u00e1rea \" + f.area());\n    }\n}\n</code></pre>"},{"location":"Bloque1_POO/01_codigos/#clases-y-objetos","title":"Clases y objetos","text":"<pre><code>class Persona {\n    String nombre;\n    int edad;\n\n    void saludar() {\n        System.out.println(\"Hola, me llamo \" + nombre);\n    }\n}\n\n// Creaci\u00f3n de un objeto\nPersona p1 = new Persona();\np1.nombre = \"Ana\";\np1.edad = 25;\np1.saludar();\n</code></pre>"},{"location":"Bloque1_POO/01_repaso_poo/","title":"Tema \u00b7 Repaso de Programaci\u00f3n Orientada a Objetos","text":"<p>La Programaci\u00f3n Orientada a Objetos (POO) es un paradigma de programaci\u00f3n que organiza el software en torno a entidades llamadas objetos, los cuales agrupan datos y comportamientos relacionados. Este enfoque resulta fundamental en la ingenier\u00eda del software moderna y sirve como base para muchos lenguajes de programaci\u00f3n actuales, como Java, C++ o Python.</p>"},{"location":"Bloque1_POO/01_repaso_poo/#1-principios-basicos-de-la-poo","title":"1. Principios b\u00e1sicos de la POO","text":""},{"location":"Bloque1_POO/01_repaso_poo/#abstraccion","title":"Abstracci\u00f3n","text":"<p>La abstracci\u00f3n consiste en identificar las caracter\u00edsticas esenciales de una entidad del mundo real y representarlas en un modelo computacional.  </p> <p>Ejemplo Abstracci\u00f3n</p>"},{"location":"Bloque1_POO/01_repaso_poo/#encapsulacion","title":"Encapsulaci\u00f3n","text":"<p>La encapsulaci\u00f3n protege el acceso directo a los datos internos de un objeto, control\u00e1ndolo mediante m\u00e9todos definidos. Esto mejora la seguridad y reduce la dependencia entre m\u00f3dulos.  </p> <p>Ejemplo Encapsulamiento</p>"},{"location":"Bloque1_POO/01_repaso_poo/#herencia","title":"Herencia","text":"<p>La herencia permite que una clase (subclase) herede atributos y m\u00e9todos de otra (superclase). Facilita la reutilizaci\u00f3n de c\u00f3digo y la creaci\u00f3n de jerarqu\u00edas l\u00f3gicas.  </p> <p>Ejemplo Herencia</p>"},{"location":"Bloque1_POO/01_repaso_poo/#polimorfismo","title":"Polimorfismo","text":"<p>El polimorfismo permite que un mismo m\u00e9todo tenga comportamientos distintos seg\u00fan el contexto o la clase que lo implemente.  </p> <p>Ejemplo Polimorfismo</p>"},{"location":"Bloque1_POO/01_repaso_poo/#2-objetos-y-clases","title":"2. Objetos y clases","text":"<ul> <li>Clase: Es la plantilla que define las propiedades (atributos) y comportamientos (m\u00e9todos).  </li> <li>Objeto: Es una instancia concreta de una clase, que posee valores espec\u00edficos para sus atributos.  </li> </ul> <p>Ejemplo Clase y objeto</p>"},{"location":"Bloque1_POO/01_repaso_poo/#3-ventajas-de-la-poo","title":"3. Ventajas de la POO","text":"<ul> <li>Modularidad: el c\u00f3digo se organiza en componentes independientes.  </li> <li>Reutilizaci\u00f3n: se puede extender y adaptar c\u00f3digo existente sin reescribirlo.  </li> <li>Mantenibilidad: facilita la lectura, depuraci\u00f3n y evoluci\u00f3n del software.  </li> <li>Escalabilidad: permite modelar sistemas complejos con jerarqu\u00edas de clases y objetos.</li> </ul>"},{"location":"Bloque1_POO/01_repaso_poo/#4-poo-en-la-practica","title":"4. POO en la pr\u00e1ctica","text":"<p>En la actualidad, la POO se integra con otros paradigmas. Lenguajes como Java siguen una orientaci\u00f3n a objetos estricta, mientras que Python o C# permiten combinarla con enfoques funcionales y procedimentales. El repaso de estos conceptos es crucial para afrontar los siguientes temas del bloque, donde se profundizar\u00e1 en aspectos avanzados como modularidad, herencia compleja, genericidad y el uso de contenedores.</p>"},{"location":"Bloque1_POO/01_repaso_poo/#5-conclusion","title":"5. Conclusi\u00f3n","text":"<p>La Programaci\u00f3n Orientada a Objetos constituye una base s\u00f3lida para el desarrollo de software moderno. Sus principios permiten construir sistemas m\u00e1s claros, mantenibles y robustos, y son fundamentales para abordar los contenidos m\u00e1s avanzados de la asignatura.</p> <p>Java vs Python</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad%20-%20Codigo/","title":"Modularidad, Herencia y Reusabilidad","text":""},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad%20-%20Codigo/#introduccion","title":"Introducci\u00f3n","text":"<p>En el desarrollo de software, conceptos como modularidad, herencia y reusabilidad son esenciales para crear programas m\u00e1s claros, mantenibles y escalables. Estos principios permiten organizar el c\u00f3digo, reducir la duplicaci\u00f3n y facilitar la evoluci\u00f3n de los proyectos.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad%20-%20Codigo/#modularidad","title":"Modularidad","text":"<p>La modularidad consiste en dividir un programa en componentes o m\u00f3dulos independientes, de manera que cada uno tenga una responsabilidad clara.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad%20-%20Codigo/#caracteristicas","title":"Caracter\u00edsticas","text":"<ul> <li>Un m\u00f3dulo puede desarrollarse, probarse y mantenerse de forma aislada.</li> <li>Facilita localizar y corregir errores.</li> <li>Permite ampliar la funcionalidad sin afectar a todo el sistema.</li> </ul>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad%20-%20Codigo/#ejemplo-en-java","title":"Ejemplo en Java","text":"<pre><code>public class Calculadora {\n    public int suma(int a, int b) { return a + b; }\n    public int resta(int a, int b) { return a - b; }\n    public int multiplica(int a, int b) { return a * b; }\n    public int divide(int a, int b) {\n        if (b == 0) throw new ArithmeticException(\"Divisi\u00f3n por cero\");\n        return a / b;\n    }\n}\n</code></pre> <p>En este caso, toda la l\u00f3gica matem\u00e1tica se encuentra encapsulada en la clase <code>Calculadora</code>, separada de la interacci\u00f3n con el usuario.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad%20-%20Codigo/#herencia","title":"Herencia","text":"<p>La herencia permite definir nuevas clases basadas en otras ya existentes, reutilizando atributos y m\u00e9todos y a\u00f1adiendo o especializando funcionalidades.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad%20-%20Codigo/#conceptos-clave","title":"Conceptos clave","text":"<ul> <li>Superclase (clase base): clase original de la que heredan otras.</li> <li>Subclase (clase derivada): clase que extiende la funcionalidad de la superclase.</li> </ul>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad%20-%20Codigo/#ejemplo-en-java_1","title":"Ejemplo en Java","text":"<pre><code>public class Persona {\n    protected String nombre;\n    protected String telefono;\n\n    public Persona(String nombre, String telefono) {\n        this.nombre = nombre;\n        this.telefono = telefono;\n    }\n}\n\npublic class Alumno extends Persona {\n    private int numExpediente;\n\n    public Alumno(String nombre, String telefono, int numExpediente) {\n        super(nombre, telefono);\n        this.numExpediente = numExpediente;\n    }\n}\n</code></pre> <p>En este ejemplo, <code>Alumno</code> hereda de <code>Persona</code>, reutilizando los atributos y a\u00f1adiendo un campo propio.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad%20-%20Codigo/#polimorfismo-y-clases-abstractas","title":"Polimorfismo y Clases Abstractas","text":"<p>El polimorfismo permite que una misma referencia pueda apuntar a objetos de diferentes clases, ejecutando el m\u00e9todo correspondiente seg\u00fan el tipo del objeto real.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad%20-%20Codigo/#ejemplo-de-clase-abstracta","title":"Ejemplo de clase abstracta","text":"<pre><code>public abstract class FiguraGeometrica {\n    protected float altura;\n    public FiguraGeometrica(float altura) { this.altura = altura; }\n\n    public abstract float areaBase();\n    public abstract float perimetroBase();\n\n    public float volumen() { return altura * areaBase(); }\n}\n</code></pre> <p>Subclases como <code>Cubo</code> o <code>Cilindro</code> implementan los m\u00e9todos abstractos adaptados a su forma.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad%20-%20Codigo/#interfaces","title":"Interfaces","text":"<p>Una interfaz define un conjunto de m\u00e9todos sin implementaci\u00f3n. Las clases que la implementan son responsables de definir su funcionamiento.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad%20-%20Codigo/#ejemplo-en-java_2","title":"Ejemplo en Java","text":"<pre><code>interface Acuatico {\n    void nadar();\n}\n\ninterface Terrestre {\n    void correr();\n}\n\npublic class Cocodrilo implements Acuatico, Terrestre {\n    public void nadar() { System.out.println(\"El cocodrilo nada\"); }\n    public void correr() { System.out.println(\"El cocodrilo corre\"); }\n}\n</code></pre> <p>Las interfaces permiten simular la herencia m\u00faltiple y promueven la flexibilidad del dise\u00f1o.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad%20-%20Codigo/#reusabilidad","title":"Reusabilidad","text":"<p>La reusabilidad consiste en emplear c\u00f3digo existente en diferentes contextos o proyectos, evitando duplicaciones.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad%20-%20Codigo/#beneficios","title":"Beneficios","text":"<ul> <li>Reducci\u00f3n de errores y duplicaciones.</li> <li>Mayor rapidez en el desarrollo.</li> <li>C\u00f3digo m\u00e1s consistente y probado.</li> </ul>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad%20-%20Codigo/#ejemplo-de-reutilizacion-mediante-herencia","title":"Ejemplo de reutilizaci\u00f3n mediante herencia","text":"<pre><code>public class CalculadoraAvanzada extends Calculadora {\n    public double potencia(double base, double exponente) {\n        return Math.pow(base, exponente);\n    }\n}\n</code></pre> <p>Aqu\u00ed <code>CalculadoraAvanzada</code> reutiliza todos los m\u00e9todos de <code>Calculadora</code> y a\u00f1ade nuevas funcionalidades.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad%20-%20Codigo/#conclusion","title":"Conclusi\u00f3n","text":"<ul> <li>La modularidad favorece el orden y la claridad.  </li> <li>La herencia y el polimorfismo permiten extender y generalizar comportamientos.  </li> <li>La reusabilidad reduce costes y facilita el mantenimiento.  </li> <li>Las interfaces aportan flexibilidad para dise\u00f1ar sistemas m\u00e1s escalables.</li> </ul> <p>Estos principios son fundamentales en la Programaci\u00f3n Orientada a Objetos (POO) y constituyen la base de un software robusto y adaptable.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/","title":"Modularidad, Herencia y Reusabilidad","text":""},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#introduccion","title":"Introducci\u00f3n","text":"<p>En el desarrollo de software, conceptos como modularidad, herencia y reusabilidad son esenciales para crear programas m\u00e1s claros, mantenibles y escalables. Estos principios permiten organizar el c\u00f3digo, reducir la duplicaci\u00f3n y facilitar la evoluci\u00f3n de los proyectos.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#modularidad","title":"Modularidad","text":"<p>La modularidad consiste en dividir un programa en componentes o m\u00f3dulos independientes, de manera que cada uno tenga una responsabilidad clara.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#caracteristicas","title":"Caracter\u00edsticas","text":"<ul> <li>Un m\u00f3dulo puede desarrollarse, probarse y mantenerse de forma aislada.</li> <li>Facilita localizar y corregir errores.</li> <li>Permite ampliar la funcionalidad sin afectar a todo el sistema.</li> </ul>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#ejemplo-en-java","title":"Ejemplo en Java","text":"<p>En este caso, .</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#herencia","title":"Herencia","text":"<p>La herencia permite definir nuevas clases basadas en otras ya existentes, reutilizando atributos y m\u00e9todos y a\u00f1adiendo o especializando funcionalidades.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#conceptos-clave","title":"Conceptos clave","text":"<ul> <li>Superclase (clase base): clase original de la que heredan otras.</li> <li>Subclase (clase derivada): clase que extiende la funcionalidad de la superclase.</li> </ul>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#ejemplo-en-java_1","title":"Ejemplo en Java","text":"<p>En este ejemplo, .</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#polimorfismo-y-clases-abstractas","title":"Polimorfismo y Clases Abstractas","text":"<p>El polimorfismo permite que una misma referencia pueda apuntar a objetos de diferentes clases, ejecutando el m\u00e9todo correspondiente seg\u00fan el tipo del objeto real.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#ejemplo-de-clase-abstracta","title":"Ejemplo de clase abstracta","text":""},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#interfaces","title":"Interfaces","text":"<p>Una interfaz define un conjunto de m\u00e9todos sin implementaci\u00f3n. Las clases que la implementan son responsables de definir su funcionamiento.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#ejemplo-en-java_2","title":"Ejemplo en Java","text":"<p>Las interfaces permiten simular la herencia m\u00faltiple y promueven la flexibilidad del dise\u00f1o.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#reusabilidad","title":"Reusabilidad","text":"<p>La reusabilidad consiste en emplear c\u00f3digo existente en diferentes contextos o proyectos, evitando duplicaciones.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#beneficios","title":"Beneficios","text":"<ul> <li>Reducci\u00f3n de errores y duplicaciones.</li> <li>Mayor rapidez en el desarrollo.</li> <li>C\u00f3digo m\u00e1s consistente y probado.</li> </ul>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#ejemplo-de-reutilizacion-mediante-herencia","title":"Ejemplo de reutilizaci\u00f3n mediante herencia","text":"<p>Aqu\u00ed <code>CalculadoraAvanzada</code> reutiliza todos los m\u00e9todos de <code>Calculadora</code> y a\u00f1ade nuevas funcionalidades.</p>"},{"location":"Bloque1_POO/02_modularidad_herencia_reusabilidad/#conclusion","title":"Conclusi\u00f3n","text":"<ul> <li>La modularidad favorece el orden y la claridad.  </li> <li>La herencia y el polimorfismo permiten extender y generalizar comportamientos.  </li> <li>La reusabilidad reduce costes y facilita el mantenimiento.  </li> <li>Las interfaces aportan flexibilidad para dise\u00f1ar sistemas m\u00e1s escalables.</li> </ul> <p>Estos principios son fundamentales en la Programaci\u00f3n Orientada a Objetos (POO) y constituyen la base de un software robusto y adaptable.</p>"},{"location":"Bloque1_POO/03_genericidad_contenedores/","title":"Genericidad; contenedores como ejemplo de aplicaci\u00f3n","text":"<p>Contenido en construcci\u00f3n</p>"},{"location":"Bloque2_Eventos_GUI/01_eventos_clases_anidadas/","title":"Introducci\u00f3n, gestores de eventos y clases anidadas","text":"<p>Contenido en construcci\u00f3n</p>"},{"location":"Bloque2_Eventos_GUI/02_interfaz_grafica/","title":"Interfaz gr\u00e1fica de usuarios","text":"<p>Contenido en construcci\u00f3n</p>"},{"location":"Bloque2_Eventos_GUI/03_componentes_layouts_navegacion/","title":"Componentes, layouts y navegaci\u00f3n","text":"<p>Contenido en construcci\u00f3n</p>"},{"location":"Bloque3_Concurrente_Distribuida/01_concurrencia_sincronizacion/","title":"Introducci\u00f3n a la concurrencia y sincronizaci\u00f3n","text":"<p>Contenido en construcci\u00f3n</p>"},{"location":"Bloque3_Concurrente_Distribuida/02_comunicacion_paralelismo/","title":"Comunicaci\u00f3n entre hilos y paralelismo","text":"<p>Contenido en construcci\u00f3n</p>"},{"location":"Bloque3_Concurrente_Distribuida/03_programacion_distribuida/","title":"Introducci\u00f3n a la programaci\u00f3n distribuida","text":"<p>Contenido en construcci\u00f3n</p>"}]}